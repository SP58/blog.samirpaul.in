<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Networks Notes | Blog - Samir Paul</title><meta name=keywords content="blog,coding,computer-science,computer-networks,computer-networks-notes,notes,computernetwork,computernetworking,computer,ipv,icnd,computertechnology,ccna,routingandswitching,networking,osi-model,computernetworkingtechnology"><meta name=description content="Computer Networks Notes"><meta name=author content="Samir Paul"><link rel=canonical href=https://samirpaul1.github.io/blog/posts/computer-networks-notes/><meta name=google-site-verification content="vJAOBxbJTCK2vXG-hLFeGsoC9hXgFlCpuJJ8AcJLROQ"><meta name=yandex-verification content="fe6a06c57be84984"><meta name=msvalidate.01 content="1A92FC2EC113F8616A21D76DA684A133"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.4b8b7bfa5e8b459c6b8600dee1a156f41831e9846f05dbf422137ff616ddd83e.css integrity="sha256-S4t7+l6LRZxrhgDe4aFW9Bgx6YRvBdv0IhN/9hbd2D4=" rel="preload stylesheet" as=style><link rel=icon href=https://samirpaul1.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://samirpaul1.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://samirpaul1.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://samirpaul1.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://samirpaul1.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Computer Networks Notes"><meta property="og:description" content="Computer Networks Notes"><meta property="og:type" content="article"><meta property="og:url" content="https://samirpaul1.github.io/blog/posts/computer-networks-notes/"><meta property="og:image" content="https://samirpaul1.github.io/blog/assets/img/computer-networks-preview-blog-banner.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-04T15:58:26+08:00"><meta property="article:modified_time" content="2022-03-04T15:58:26+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://samirpaul1.github.io/blog/assets/img/computer-networks-preview-blog-banner.webp"><meta name=twitter:title content="Computer Networks Notes"><meta name=twitter:description content="Computer Networks Notes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://samirpaul1.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Computer Networks Notes","item":"https://samirpaul1.github.io/blog/posts/computer-networks-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Computer Networks Notes","name":"Computer Networks Notes","description":"Computer Networks Notes","keywords":["blog","coding","computer-science","computer-networks","computer-networks-notes","notes","computernetwork","computernetworking","computer","ipv","icnd","computertechnology","ccna","routingandswitching","networking","osi-model","computernetworkingtechnology"],"articleBody":"Chapter 1: Computer Networks and the Internet 1.1 What is the Internet? 1.1.1 A nuts-and-bolts description The Internet is a computer networks that interconnects hundreds of millions of computing devices through the world. Today not only computers and workstation are being connected to the network, therefore the term computer network may sound a bit dated.\nAll the devices connected to the Internet are called hosts or end systems. End systems are connected together by a network of communication links and packets switches.\nDifferent links can transmit data at different rates, with the transmission rate of a link measured in bits/second.\nWhen one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment. The resulting packages of information, called packets, are then sent through the network to the destination and system where they a reassembled into the original data.\nA packet switch takes a packet arriving on one of its incoming communication links and forwards that packet on one of its outgoing communication links. The two most prominent types of packets switches are routers and link switches. The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as route or path.\nEnd systems access the Internet through Internet Service Providers (ISPs), including residential ISPs (cable or phone company), corporate, university ISPs … Each ISP in itself is a network of packet switches and communication links. Lower tier (which interconnect end-systems) ISPs are interconnected through national and international upper tier ISP. An upper-tier ISP consists of high speed routers interconnected with high-speed fiber-optic links. Each ISP network is managed independently.\nEnd systems, packet switches and other pieces of the Internet run protocols that control the sending and receiving of information within the Internet.\n1.1.2 A Services Description The Internet can be described as an infrastructure that provides services to applications. These applications (Web, social networks, VoIP…) are said to be distributed since they involve multiple end systems that exchange data with each other. Internet applications run on end systems, not in the packet switches or routers, packet switches facilitate the exchange of data, but they are not concerned with the application that is the source or sink of data.\nEnd systems attached to the Internet provide and Application Programming Interface (API) that specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system.\n1.1.3 What Is a Protocol? All the activity in the Internet that involves two or more communicating remote entities is governed by a protocol.\nA protocol defines the format and the order of messages exchanged between two or more communicating entities, as weel as the actions taken on the trasmission and/or receipt of a message or other event\n1.2 The Network Edge Computers and other devices connected to the Internet are often referred to as end systems as they sit at the edge of the Internet. They are also called hosts as they host, run, applications programs such as a Web Browser or an email client.\nHosts are sometimes further divided into two categories: clients and servers. The former being desktop, mobile pcs, smartphones, the latter being powerful machines that store and distribute Web pages, streams… Nowadays most of the servers reside in large data centers\n1.2.1 Access Networks They are the networks that physically connect end systems to the first router on a path from the end system to any other distant end system. Examples: mobile network, national or global ISP, local or regional ISP, home networks enterprise networks.\nHome Access: DSL, Cable, FITH, Dial-Up and Satellite Today, the two most prevalent types of broadband residential access are digital subscriber line (DSL) and cable.\nA residence typically obtains DSL access from the telephone company (telco) that provides its wired local phone access. The customer’s telco is therefore its ISP. DSL modem use the existing telephone lines to exchange data with DSLAMs (digital subscriber line access multiplexer) located in the telco local central office. The DSL modem takes digital data and translates it to high-frequency tones for transmission over telephone wires, these analog signals from many houses are translated back into digital format at the DSLAM. The use of different frequencies allows the phone line to carry a high-speed downstream channel, a medium-speed upstream channel and an ordinary two-way telephone channel. Hundreds or even thousands of households connect to a single DSLAM.\nDSL: 24 Mbps downstream and 2.5 Mbps upstream (MAX VALUES). Because of the difference between these two values, the access is said to be asymmetric.\nCable Internet access makes use of the cable television company’s existing cable television infrastructure. Cable modems connect to CMTS (Cablem Modem Termination System) which does the same job the DSLAM does for phone lines. The access is typically asymmetric. CABLE: 42.8 Mbps downstream and 30.7 Mbps upstream (MAX VALUES). Cable Internet access is a shared broadcast medium: each packet travels downstream on every link to every home and viceversa. For this, if several users are simultaneously using the downstream channel, the actual rate will be significantly lower.\nAnother up-and-coming technology that promises very high speeds is fiber to the home (FTTH). The concept is simple: provide an optical fiber path from the Central Office (CO)\nAccess in the Enterprise and the Home: Ethernet and WiFi On corporate and university campuses, and increasingly in home settings, a Local Area Network (LAN) is used to connect an end system to the edge router. Ethernet is by far the most prevalent access technology is corporate, university and home networks. Ethernet uses twisted-pair copper wire to connect to an Ethernet switch which is connected into the larger Internet. The Internet is increasingly accessed wirelessly: wireless users transmit/receive packets to/from an access point connected into the enterprise’s network which in turn is connected to the wired Internet.\nWide-Area Wireless Access: 3G and LTE Smartphones and Tablets employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station operated by the cellular network provider. Third generation (3G) wireless and fourth generation (4G) of wide-area network are being deployed. LTE (“Long-Term Evolution”) has its root in 3G and can potentially achieve rates in excess of 10 Mbps.\n1.2.2 Physical Media The book talks about it in detail but we haven’t talked about it in class\nA bit, when traveling from source to destination, passes through a series of transmitter-receiver pairs, for each pair, the bit is sent by propagating electromagnetic waves or optical pulses across a physical medium. This can take many shapes and forms and doesn’t have to be of the same type for each transmitter-receiver pair along the path. Physical media fall into two categories:\nguided media: the waves are guided along a solid medium (fiber-optic cable, twisted-pair copper wire, coaxial cable) unguided media: the waves propagate in the atmosphere and in outer space (wireless LAN, digital satellite channel) 1.3 The Network Core 1.3.1 Packet Switching In a network application, end systems exchange messages with each other. To send a message from a source end system to a destination end system, the source breaks long messages into smaller chunks of data known as packets. Between source and destination, each packet travels through communication links and packet switches (for which there are two predominant types, routers and link-layer switches). Packets are transmitted over each communication link at a rate equal to the full transmission rate of the link. So, if a source end system or a packet switch is send a packet of L bits over a link with transmission rate R bits/sec, then the time to transmit the packet is L/R seconds.\nStore-and-forward Transmission Most packet switches use store-and-forward transmission at the inputs to the links. Store-and-forward transmission means that the packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. The link must buffer (“store”) the packet’s bits and only after the router has received all of the packet’s bits can it begin to transmit (“forward”) the packet onto the outbound link.\nQueuing Delays and Packet Loss Each packet switch has multiple links attached to it. For each attached link, the packet switch has an output buffer (or output queue) which stores packets that the router is about to send into that link. If an arriving packet needs to be transmitted onto a link but finds the link busy with the transmission of another packet, the arriving packet must wait in the output buffer. Thus, packets suffer output buffer queuing delays which are variable and depend on the level of congestion in the network. Since the amount of buffer space is finite, an arriving packet may find the buffer completely full. In this case, packet loss will occur, either the arriving packet or one of the already queued packets will be dropped.\nForwarding tables and routing protocols In the Internet, every end system has an address called an IP address. When a source end system wants to send a packet to a destination end system, the source includes the destination’s IP address in the packet’s header. Each router has a forwarding table that maps destination addresses (or portions of the destination addresses) to that router’s outbound links. When a packet arrives at the router, the router examines the address and searches its forwarding table, using this destination address, to find the appropriate outbound link. A number of special routing protocols are used to automatically set the forwarding tables.\n1.3.2 Circuit Switching In circuit-switched networks, the resources needed along a path(buffers, link transmission rate) to provide for communication between the end systems are reserved for the duration of the communication sessions. When two hosts want to communicate, the network establishes a dedicated end-to-end connection between them.\nMultiplexing in Circuit-Switched Networks A circuit in a link is implemented with either frequency-division multiplexing (FDM) or time-division multiplexing (TDM). With FDM, the frequency spectrum of a link is divided up among the connections established across the link. The width of the band is called the bandwidth. For a TDM link, time is divided into frames of fixed duration, and each frame is divided into a fixed number of time slots.\nPacket Switching Versus Circuit Switching Packet switching is more flexible, uses resources efficiently and is simpler to implement (even if it requires congestion control). Circuit switching offers performance guarantees but uses resources inefficiently\n1.3.3 A Network of Networks To create the Internet, ISPs must be interconnected, thus creating a network of networks. Much of the evolution of the structure of the Internet is driven by economics and national policy, rather than by performance consideration.\nToday’s Internet is complex, consisting of a dozen or so tier-1 ISPs and hundreds of thousands of lower-tier ISPs. The ISPs are diverse in their coverage, with some spanning multiple continents and oceans, and others limited to narrow geographic regions. The lower-tier ISPs connect to the higher-tier ISPs and the higher-tier ISPs interconnect with one another. Users and content providers are customers of lower-tier ISPs and lower-tier ISPs are customers of higher-tier ISPs. Recently, major content providers (Google) have also created their own networks and connect directly into lower-tier ISPs where possible.\n1.4 Delay, Loss and Throughput in Packet-Switched Networks Computer networks necessarily constrain throughput (the amount of data per second that can be transferred) between end system, introduce delays between end systems and can actually lose packets.\n1.4.1 Overview of Delay in Packet-Switched networks As a packet travels from one node (host or router) to the subsequent host along his path, it suffers from several types of delays at each node along the path.\nTypes of Delay Processing Delay The processing delay consists of the time required to examine the packet’s header and determine where to direct the packet. It may also include other factors, such as the time needed to check for bit-level errors occurred during transmission. They typically are of the order of microseconds or less. After processing the packet is sent to the queue preceding the link to the next router\nQueuing Delay At the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link. It depends on the number of earlier-arriving packets, therefore if the queue is empty, then the packet’s queuing delay will be 0. Typically of the order of microseconds or milliseconds.\nTransmission delays If the length of the packet is L bits, and the transmission rate of the link is R bits/sec, then the transmission delay is L/R. This is the amount of time required to push (transmit) all of the packet’s bits into the link. Typically on the order of microseconds to milliseconds.\nPropagation Delay The time required to propagate a bit from the beginning of the link to the next router is the propagation delay. The bit propagates at the propagation speed of the link, which depends on the physical medium of the link. The propagation delay is the distance between two routers divided by the propagation speed of the link.\nTotal nodal delay it is the summation of the previous delays\n1.4.2 Queuing Delay and Packet Loss The queuing delay depends can vary from packet to packet, therefore when characterizing queuing delay, one typically uses statistical measures, such as average queuing delay, variance of queuing delay, and the probability that the queuing delay exceeds some specified value.\nPacket Loss A queue preceding a link has finite capacity. If a packet finds a full queue, then the router will drop it, the packet will be lost. The fraction of lost packets increases as the traffic intensity increases.\n1.4.3 End-to-End Delay Let’s now consider the total delay, from source to destination (not only the nodal delay). Let’s suppose there are N-1 routers between the source host and the destination host, then the nodal delays accumulate and give an end-to-end delay:\nd(end_end) = N * [d(proc) + d(queue) + d(trans) + d(prop)] 1.4.4 Throughput in Computer Networks Another critical performance measure in computer networks is end-to-end throughput. The instantaneous throughput at any instant of time is the rate (in bits/sec) at which host B is receiving a file. If the file consists of F bits and the transfers takes T seconds to transfer the whole file, then the average throughput of the file is F/T bits/sec. For a simple two-link network, the throughput is the min of all the throughputs, that is the transmission rate of the bottleneck link. Therefore, the constraining factor for throughput in today’s Internet is typically the access network.\n1.5 Protocol Layers and Their Service Models 1.5.1 Layered Architecture A layered architecture allows us to discuss a well-defined, specific part of a large and complex system. This simplification itself is of considerable value by providing modularity, making it much easier to change the implementation of the service provided by the layer: as long as the layer provides the same service to the layer above it, and uses the same services from the layer below it, the remainder of the system remains unchanged when a layer’s implementation is changed.\nProtocol Layering To provide structure to the design of network protocols, the network designers organize protocols in layers. Each protocol belongs to one of the layers. We are interested in the services that a layer offers to the layer above, service model of a layer. When taken together, the protocols of the various layers are called the protocol stack. The Internet protocol stack consists of five layers:\nApplication Transport Network Link Physical Application Layer Where network applications and their applications-layer protocols reside. The Internet’s application layer includes many protocols: HTTP, SMTP, FTP, DNS. An application-layer protocol is distributed over multiple end systems, with the application in one end system using the protocol to exchange packets of information with the application in another end system. This packet of information at the application layer is called message.\nTransport Layer It transports application-layer messages between application endpoints. In the Internet there are two transport protocols: TCP and UDP. TCP provides a connection-oriented service to its application: the service includes guaranteed delivery of application-layer messages to the destination and flow control unit. TCP also breaks long messages into shorter segments and provides a congestion-control mechanism, so that a source throttles its transmission rate when the network is congested. HTTP and SMTP use TCP\nUDP provides a connectionless service to its applications: it’s a no-frills service that provides no guarantees, no reliability, no flow control and no congestion control. A transport-layer packet is called segment Skype uses UDP (speed required)\nNetwork Layer It is responsible for moving network-layer packets known as datagrams from one host to another. The Internet’s network layer includes the IP Protocol. There is only one IP Protocol and all the Internet components that have a network layer must run it. The Internet’s network layer also contains routing protocols that determine the routes that datagrams take between sources and destinations. The Internet has many routing protocols. Often it is simply referred to as the IP protocols, forgetting that it includes routing too.\nLink Layer To move a packet from one node to the next, the network layer relies on the services of the link layer. The services provided by the link layer depend on the specific link-layer protocol that is employed over the link. Examples are Ethernet, WiFi. We will refer to the link-layer packets as frames\nPhysical Layer The job of the physical layer is to move the individual bits within the frame from one node to the next. The protocols are link dependent and further depend of the actual transmission medium of the link.\n1.5.2 Encapsulation Routers and link-layer switches are both packet switches but routers and link-layer switches do not implement all of the layers in the protocol stack: link-layer switches implement Physical and Link while router add the Network Layer too.\nFrom the Application Layer, the message passes to the transport layer, which appends additional information to it (the Header) that will be used by the receiver-side transport layer. The transport layer then adds its own header and passes the datagram to the link layer which adds it own link-layer header information. Thus, we see that at each layer, a packet has two types of fields: header fields and a payload field, the payload typically being the packet from the layer above.\nThe process of encapsulation can be more complex: for example a large message may be divided into multiple transport-layer segments, which will be divided into multiple datagrams….\n1.6 Networks Under Attack Malware Along with all the good files we exchange on the Internet, come malicious software, collectively known as malware that can also enter and infect our devices. Once a device infected, the malware can do all kinds of evil things: deleting files, install spyware… A compromised host may also be enrolled in a network of thousands of similarly compromised devices, known as botnet which can be used for spam or distributed denial-of-service. Much of the malware is self-replicating: it seeks entry into other hosts from the infected machines. Malware can spread in the from of a virus or a worm.\nViruses are malware that requires some form of user interaction to infect the user’s device. Worms are malware that can enter a device without any explicit user interaction. DoS Denial-of-Service attacks render a network, host, or other piece of infrastructure unusable by legittimate users. Most of them fall into one of the three categories:\nVulnerability Attack: a few well-crafted messages are sent to a vulnerable application or operating system running on the targeted host. The service might stop or the host might crash. Bandwidth flooding: a deluge of packets is sent to the targeted host, so many packets that the target’s access link becomes clogged preventing legitimate packets from reaching the server Connection flooding: a large number of half-open or fully open TCP connections are established at the targeted host, which can become so bogged down that it stops accepting legitimate connections. In a distributed DoS (DDoS) attack the attacker controls multiple sources and has each source blast traffic at the target.\nSniffing A passive receiver can record a copy of every packet that passes through the network. It is then called a packet sniffer. Because packet sniffers are passive (they do not inject packets into the channel), they are difficult to detect. Some of the best defenses against packet sniffing involve cryptography.\nSpoofing The ability to inject packets into the Internet with a false source address is known as IP Spoofing and is but one of many ways in which one user can masquerade as another user. To solve this problem we will need end-point authentication.\nThe history of the Internet shaped is structure The Internet was originally designed to be based on the model of a group of mutually trusting users attached to a transparent network, a model in which there is no need for security. Many aspects of the original Internet architecture deeply reflect this notion of mutual trust, such as the ability for one to send a packet to any other user is the default rather than a requested/granted capability. However today’s Internet certainly does not involve “mutually trusted users”: communication among mutually trusted users is the exception rather the rule.\nHistory of Computer Networking and the Internet Chapter 2: Application Layer Network applications are the raison d’être of a computer network. They include text email, remote access to computers, file transfers, the WorldWideWeb (mid 90s), web searching, e-commerce, Twitter/Facebook, Amazon, Netflix, Youtube, WoW…\n2.1 Principles of Network Applications At the core of network application development is writing programs that run on different end systems and communicate with each over the network. The programs running on end systems might be different (server-client architecture) or identical (Peer-to-Peer architecture). Importantly we write programs that run on end systems/hosts, not on network-core devices (routers/link-layer switches).\n2.1.1 Network Application Architectures From the application developer’s perspective, the network architecture is fixed and provides a specific set of services to applications. The application architecture, on the other hand, is chosen by him. In choosing the application architecture, a developer will likely draw one of the two predominant architectural paradigms used in modern network applications:\nClient-server architecture: there is an always on host, called the server which serves requests from many other hosts, called clients: [Web Browser and Web Server]. Clients do not communicate directly with each other. The server has a fixed, well-known address, called an IP address that clients use to connect to him. Often, a single server host is incapable of keeping up with all the requests from clients, for this reason, a data center, housing a large number of hosts, is often used to create a powerful virtual server (via proxyin). P2P architecture: there is minimal or no reliance on dedicated servers in data centers, the application exploits direct communication between pairs of intermittently connected bots, called peers. They are end systems owned and controlled by users. [Bittorrent, Skype]. P2P applications provide self-scalability (the network load is distributed) They are also cost-effective since they don’t require significant infrastructure and server bandwidth. P2P face challenges: ISP Friendly (asymmetric nature of residential ISPs) Security Incentives (convincing users to participate) Some applications have hybrid architectures, such as for many instant messaging applications: a server keeps track of the IP addresses of users, but user-to-user messages are sent directly between users.\n2.1.2 Processes Communicating In the jargon of operating systems, it’s not programs but processes that communicate. A process can be thought of as a program that is running within an end system. Processes on two different end systems communicate with each other by exchanging messages across the computer network: a sending process creates and sends messages into the network, a receiving process receives these messages and possibly responds by sending messages back.\nClient and Server Processes A network application consists of pairs of processes that send messages to each other over a network. For each pair of communicating processes we label:\nthe process that initiates the communication as the client [web browser] the process that waits to be contacted to begin the session as the server [web server] This labels stand even for P2P applications in the context of a communication session.\nThe Interface Between the Process and the Computer Network A process sends messages into, and receives messages from, the network through a software interface called a socket. A socket is the interface between the application layer and the transport layer within a host, it is also referred to as the Application Programming Interface (API) between the application and the network. The application developer has control of everything on the application-layer of the socket but has little control of the transport-layer side of the socket. The only control that he has over the transport-layer is:\nThe choice of the transport protocol Perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum segment sizes Addressing Processes In order for a process running on one host to send packets to a process running on another host, the receiving process needs to have an address. To identify the receiving processes, two pieces of information need to be specified:\nThe address of the host. In the Internet, the host is identified by its IP Address, a 32-bit (or 64) quantity that identifies the host uniquely. An identifier that specifies the receiving process in the destination host: the destination port number. Popular applications have been assigned specific port numbers (web server -\u003e 80) 2.1.3 Transport Services Available to Applications What are the services that a transport-layer protocol can offer to applications invoking it?\nReliable Data Transfer For many applications, such as email, file transfer, web document transfers and financial applications, packet’s drops and data loss can have devastating consequences. If a protocol provides guarantees that the data sent is delivered completely and correctly, it is said to provide reliable data transfer. The sending process can just pass its data into the socket and know with complete confidence that the data will arrive without errors at the receiving process.\nThroughput A transport-layer protocol could provide guaranteed available throughput at some specific rate. Applications that have throughput requirements are said to be bandwidth-sensitive applications.\nTiming A transport-layer protocol can also provide timing guarantees. Example: guarantees that every bit the sender pumps into the socket arrives at the receiver’s socket no more than 100 msec later, interesting for real-time applications such as telephony, virtual environments…\nSecurity A transport-layer protocol can provide an application with one or more security services. It could encrypt all data transmitted by sending process and in the receiving host decrypt it.\n2.1.4 Transport Services Provided by the Internet The Internet makes two transport protocols available to applications: TCP and UDP.\nTCP Services TCP includes a connection-oriented service and a reliable data transfer service:\nConnection-oriented service: client and server exchange transport-layer control information before the application-level messages begin to flow. This so-called handshaking procedure alerts the client and server, allowing them to prepare for an onslaught of packets. Then a TCP connection is said to exist between the sockets of the two processes. When the application finishes sending messages, it must tear down the connection SECURING TCP Nether TCP nor UDP provide encryption. Therefore the Internet community has developed an enhancement for TCP called Secure Sockets Layer (SSL), which not only does everything that traditional TCP does but also provides critical process-to-process security services including encryption, data integrity and end-point authentication. It is not a third protocol, but an enhancement of TCP, the enhancement being implemented in the application layer in both the client and the server side of the application (highly optimized libraries exist). SSL has its own socket API, similar to the traditional one. Sending processes passes cleartext data to the SSL socket which encrypts it.\nReliable data transfer service The communicating processes can rely on TCP to deliver all data sent without error and in the proper order. TCP also includes a congestion-control mechanism, a service for the general welfare of the Internet rather than for the direct benefit of the communicating processes. It throttles a sending process when the network is congested between sender and receiver.\nUDP Services UDP is a no-frills, lightweight transport protocol, providing minimal services. It is connectionless, there’s no handshaking. The data transfer is unreliable: there are no guarantees that the message sent will ever reach the receiving process. Furthermore messages may arrive out of order. UDP does not provide a congestion-control mechanism neither.\nServices Not Provided by Internet Transport Protocols These two protocols do not provide timing or throughput guarantees, services not provided by today’s Internet transport protocols. We therefore design applications to cope, to the greatest extent possible, with this lack of guarantees.\n2.1.5 Application-Layer Protocols An application-layer protocol defines how an application’s processes, running on different end systems, pass messages to each other. It defines:\nThe type of the messages exchanged (request/response) The syntax of the various message types The semantics of the fields (meaning of the information in fields) The rules for determining whem and how a process sends messages and responds to messages 2.2 The Web and HTTP In the early 1990s, a major new application arrived on the scene: the World Wide Web (Berners-Lee 1994), the first application that caught the general public’s eye. The Web operates on demand: users receives what they want, when they want it. It is enormously easy for an individual to make information available over the web, hyperlinks and search engines help us navigate through the ocean of web sites…\n2.2.1 Overview of HTTP The HyperText Transfer Protocol (HTTP), the Web’s application-layer protocol is a the heart of the Web. It is implemented in two programs: a client program and a server program. The two programs talk to each other by exchanging HTTP messages. A Web page (or document) consists of objects. An object is simply a file (HTML file, jpeg image…) that is addressable by a single URL. Most Web pages consist of a base HTML file and several referenced objects. The HTML file references the other objects in the page with the objects’ URLs. Each URL has two components: the hostname of the server that houses the object and the object’s path name. Web Browsers implement the client side of HTTP. HTTP uses TCP as its underlying transport protocol. The server sends requested files to clients without storing any state information about the client: it is a stateless protocol\n2.2.2 Non-Persistent and Persistent Connections In many Internet applications, the client and server communicate for an extended period of time, depending on the application and on how the application is being used, the series of requests may be back-to-back, periodically at regular intervals or intermittently. When this is happening over TCP, the developer must take an important decision: should each request/response pair be sent over a separate TCP connection or should all of the requests and their corresponding responses be sent over the same TCP connection? In the former approach, the application is said to use non-persistent connections and in the latter it is said to use persistent connections By default HTTP uses non-persistent connections but can be configured to be use persistent connections. To estimate the amount of time that elapses when a client requests the base HTML file until the entire file is received by the client we define the round-trip time (RTT) which is the time it takes for a small packet to travel from client to server and then back to the client.\nHTTP with Non-Persistent Connections For the page and each object it contains, a TCP connection must be opened (handshake request, handshake answer), we therefore observe an addition RTT, and for each object we will have a request followed by the reply This model can be expensive on the server side: a new connection needs to be established for each requested object, for each connection a TCP buffer must be allocated along some memory to store TCP variables.\nHTTP with Persistent Connections The server leaves the TCP connection open after sending a response, subsequent requests and responses between the same client and server will be sent over the same connection. In particular an entire web page (text + objects) ca be sent over a single persistent TCP connection, multiple web pages residing on the same server can be sent from the server to the same client over a single persistent TCP connection. These requests can be make back-to-back without waiting for replies to pending requests (pipelining). When the server receives back-to-back requests, it sends the objects back-to-back. If connection isn’t used for a pre-decided amount of time, it will be closed.\n2.2.3 HTTP Message Format Two types of HTTP messages:\nHTTP Request Message GET /somedir/page.html HTTP/1.1 Host: www.someschool.edu Connection: close User-agent: Mozilla/5.0 Accept-language: fr Ordinary ASCII text First line: request line Other lines: header lines the first lines has 3 fields: method field, URL field, HTTP version field: method field possible values: GET, POST, HEAD, PUT, DELETE The majority of HTTP requests use the GET method, used to request an object.\nThe entity body (empty with GET) is used by the POST method, for example for filling out forms. The user is still requesting a Web page but the specific contents of the page depend on what the user entered into the form fields. When POST is used, the entity body contains what the user entered into the form fields. Requests can also be made with GET including the inputted data in the requested URL. The HEAD method is similar to GET, when a server receives it, it responds with an HTTP message but it leaves out the requested object. It is often used for debugging. PUT is often used in conjunction with web publishing tools, to allow users to upload an object to a specific path on the web servers. Finally, DELETE allows a user or application to delete an object on a web server.\nHTTP Response Message A typical HTTP response message:\nHTTP/1.1 200 OK Connection: close Date: ... Server: ... Last-Modified: ... Content-Length: ... Content-Type: text/html (data data data data data ...) Status line: protocol version, status code, corresponding status message six header lines: the connection will be closed after sending the message date and time when the response was created (when the server retrieves the object from the file system, insert object in the message, sends the response message) Type of the server / software Last modified: useful for object caching Content-Length: number of bytes in the object Content-Type entity body: contains the requested object itself (data) Some common status codes:\n200 OK: request succeeded, information returned 301 Moved Permanently: the object has moved, the new location is specified in the header of the response 400 Bad Request: generic error code, request not understood 404 Not Found: The requested document doesn’t exist on the server 505 HTTP Version Not Supported: The requested HTTP protocol version is not supported by the server 2.2.4 User-Server Interaction: Cookies An HTTP server is stateless in order to simplify server design and improves performances. A website can identify users using cookies. Cookie technology has 4 components:\nCookie header in HTTP response message Cookie header in HTTP request message Cookie file on the user’s end-system managed by the browser Back-end database at the Website User connects to website using cookies:\nServer creates a unique identification number and creates an entry in its back-end database indexed by the identification number -server responds to user’s browser including in the header: Set-cookie: identification number The browser will append to the cookie file the hostname of the server and the identification number header Each time the browser will request a page, it will consult the cookie file, extract the identification number for the site and put a cookie header line including the identification number The server can track the user’s activity: it knows exactly what pages, in which order and at what times that identification number has visited. This is also why cookies are controversial: a website can learn a lot about a user and sell this information to a third party.\nTherefore cookies can be used to create a user session layer on top of stateless HTTP.\n2.2.5 Web Caching A Web cache, also called proxy server is a network entity that satisfies HTTP requests on behalf of an origin Web server. It has its own disk storage and keeps copies of recently requested objects in this storage.\nThe browser establishes a TCP connection to the web cache, sending an HTTP request for the object to the Web cache. The web cache checks to see if it has a copy of the object stored locally. If yes, it will return it within an HTTP response message to the browser. If not, the Web cache opens a TCP connection to the origin server, which responds with the requested object. The Web caches receives the object, stores a copy in its storage and sends a copy, within an HTTP response message, to the browser over the existing TCP connection. Therefore a cache is both a server and a client at the same time. Usually caches are purchased and installed by ISPs. They can substantially reduce the response time for a client request and substantially reduce traffic on an institution’s access link to the Internet.\nThrough the use of Content Distribution Networks (CDNs) web caches are increasingly playing an important role in the Internet. A CDN installs many geographically distributed caches throughout the Internet, localizing much of the traffic.\n2.2.6 The Conditional GET Caches introduce a new problem: what if the copy of an object residing in the cache is stale? The conditional GET is used to verify that an object is up to date. An HTTP request message is a conditional get if\nthe request message uses the GET method the request message includes an If-modified-since: header line. A conditional get message is sent from the cache to server which responds only if the object has been modified.\n2.5 DNS - The Internet’s Directory Service One identifier for a host is its hostname [cnn.com, www.yahoo.com]. Hostnames are mnemonic and therefore used by humans. Hosts are also identified by IP addresses.\n2.5.1 Services provided by DNS Routers and use IP addresses. The Internet’s domain name system (DNS) translates hostnames to IP addresses. The DNS is:\nA distributed database implemented in a hierarchy of DNS Servers An application-layer protocol that allows hosts to query the distributed database. DNS servers are often UNIX machines running the Berkeley Internet Name Domaine (BIND) software.\nDNS runs over UDP and uses port 53 It is often employed by other application-layer protocols (HTTP, FTP…) to translate user-supplied hostnames to IP addresses.\nHow it works:\nThe user machine runs the client side of the DNS application The browser extracts www. xxxxx . xxx from the URL and passes the hostname to the client side of the DNS application The DNS sends a query containing the hostname to a DNS server The DNS client eventually receives a reply including the IP address for the hostname The browser can initiate a TCP connection. DNS adds an additional delay\nDNS provides other services in addition to translating hostnames to IP addresses:\nhost aliasing: a host with a complicated hostname can have more alias names. The original one is said to be a canonical hostname. mail server aliasing: to make email servers’ hostnames more mnemonic. This also allows for an e-mail server and an Web server to have the same hostname. load distribution: replicated servers can have the same hostname. In this case, a set of IP addresses is associated with one canonical hostname. When a client make a DNS query for a name mapped to a set of addresses, the server responds with the entire set, but rotates the ordering within each reply. 2.5.2 Overview of How DNS Works From the perspective of the invoking application in the user’s host, DNS is a black box providing a simple, straightforward translation service. Having one single global DNS server would be simple, but it’s not realistic because it would a single point of failure, it would have an impossible traffic volume, it would be geographically too distant from some querying clients, its maintenance would be impossible.\nA Distributed, Hierarchical Database The DNS uses a large number of servers, organized in a hierarchical fashion and distributed around the world.\nThe three classes of DNS servers:\nRoot DNS servers: In the Internet there are 13 root DNS servers, most hosted in North America, each of these is in reality a network of replicated servers, for both security and reliability purposes (total: 247) Top-level domain (TLD) servers: responsible for top-level domains such as com org net edu and govand all of the country top-level domains uk fr jp Authoritative DNS servers: every organization with publicly accessible hosts must provide publicly accessible DNS records that map the names of those hosts to IP addresses. An organization can choose to implement its own authoritative DNS server or to pay to have the records stored in an authoritative DNS of some service provider. Finally there are local DNS servers which is central to the DNS architecture. They are hosted by ISPs. When a hosts connects to one of these, the local DNS server provides the host with the IP addresses of one or more of its local DNS servers. Requests can ho up to the root DNS servers and back down.\nWe can have both recursive and iterative queries. In recursive queries the user sends the request its nearest DNS which will ask to a higher-tier server, which will ask to lower order… the chain goes on until it reaches a DNS that can reply, the reply will follow the inverse path that the request had. In iterative queries the same machine sends requests and receives replies. Any DNS can be iterative or recursive or both.\nDNS Caching DNS extensively exploits DNS caching in order to improve the delay performance and to reduce the number of DNS messages ricocheting around the Internet. In a query chain, when a DNS receives a DNS reply it can cache the mapping in its local memory.\n2.5.3 DNS Records and Messages The DNS servers that implement the DNS distributed database store resource records (RRs) including RRs that provide hostname-to-IP address mappings. Each DNS reply messages carries one or more resource records.\nA resource record is a four-tuple that contains the fields: (Name, Value, Type, TTL) TTL is the time to live of the resource record (when a resource should be removed from a cache). The meaning of Name and Value depend on Type:\nType Name Value A a hostname IP address NS a domain (foo.com) hostname of an authoritative DNS server which knows how to obtain the IP addresses for hosts in the domain. Used to route queries further along in the query chain CNAME a alias name canonical hostname for the name in Name MX alias hostname canonical hostname of a mail server that has an alias hostname Name DNS Messages The only types of DNS messages are DNS queries and reply messages. They have the same format:\nfirst 12 bytes in the header section: 16-bit number identifying the query, which will be copied into the reply query so that the client can match received replies with sent queries. 1 bit query/reply flag (0 query, 1 reply). 1 bit flag authoritative flag set in reply messages when DNS server is an authoritative for a queried name. 1 bit recursion flag if the client desires that the server performs recursion when it doesn’t have a record, 1 bit recursion-available field is set in the reply if the DNS server supports recursion question section: information about the query: name field containing the name being queried, type field answer section: resource records for the name originally queried: Type, Value, TTL. Multiple RRs can be returned if the server has multiple IP addresses authority section: records for other authoritative servers. additional section: other helpful records: canonical hostnames… Inserting Records into the DNS Database We created a new company. Next we register th domain name newcompany.com at a registrar. A registrar is a commercial entity that verifies the uniqueness of the domain name, enters it into the DNS database and collects a small fee for these services. When we register the address, we need the provide the registrar with the IP address of our primary and secondary authoritative DNS servers, that will make sure that a Type NS and a Type A records are entered into the TLD com servers for our two DNS servers.\nFocus on security: DNS vulnerabilities DDoS bandwidth-flooding attack MITM: the mitm answers queries with false replies tricking the user into connecting to another server. The DNS infrastructure can be used to launch a DDoS attack against a targeted host To date, there hasn’t been an attack that that has successfully impeded the DNS service, DNS has demonstrated itself to be surprisingly robust against attacks. However there have been successful reflector attacks, these can be addressed by appropriate configuration of DNS servers.\n2.6 Peer-to-Peer Applications 2.6.1 File Distribution In P2P file distribution, each peer can redistribute any portion of the file it has received to any peers, thereby assisting the server in the distribution process. As of 2012 the most popular P2P file distribution protocol is BitTorrent, developed by Bram Cohen.\nScalability of P2P architectures Denote the upload rate of the server’s access link by $u_s$, the upload rate of the ith peer’s access link by $u_i$ and the download rate of the ith access link by $d_i$, tthe size of the to be distributed in bits () Comparison client-server and P2P.\nClient-Server The server must transmit one copy of the file to N peers, thus it transmits *NF *bits. The time to distribute the file is at least NF/u_s. Denote $d_min = min{ d_i }$ the link with the slowest download rate cannot obtain all F bits in less than $F/d_min$ seconds Therefore: $$ D_{cs} \\geq \\max \\left{ \\frac{NF}{u_s} , \\frac{F}{d_min} \\right} $$\nP2P When a peer receives some file data, it can use its own upload capacity to redistribute the data to other peers.\nAt the beginning of the distribution only the server has the file. It must send all the bits at least once. $D \\geq F/u_s$ The peer with the lowest download rate cannot obtain all F bits of the file in less than $F/d_min $ seconds. The total upload capacity of the system is equal to the summation of the upload rates of the server and of all the peers. The system must upload F bits to N peers, thus delivering a total of NF bits which can’t be done faster that $u_total$. We obtain: $$ D_{P2P} = \\max \\left{ \\frac{F}{u_s} , \\frac{F}{d_{min}} , \\frac{NF}{u_s + \\sum_{i=1}^N u_j} \\right} $$\nBitTorrent In BitTorrent the collection of all peers participating in the distribution of a particular file is called a torrent. Peers in a torrent download equal-size chunks of the file from one another with a typical chunk size of 256 KBytes. At the beginning a peer has no chunks, it accumulates more and more chunks over time. While it downloads chunks it also uploads chunks to other peers. Once a peer has acquired the entire file it may leave the torrent or remain in it and continue to upload chunks to other peers (becoming a seeder). Any peer can leave the torrent at any time and later rejoin it at anytime as well.\nEach torrent has an infrastructure node called a tracker: when a peer joins a torrent, it registers itself with the tracker and periodically informs it that it is still in the torrent. The tracker keeps track of the peers participating in the torrent. A torrent can have up to thousands of peers participating at any instant of time.\nUser joins the torrent, the tracker randomly selects a subset of peers from the set of participating peers. User establishes concurrent TCP connections with all of these peers, called neighboring peers. The neighboring peers can change over time. The user will ask each of his neighboring peers for the list of chunks they have (one list per neighbor). The user starts downloading the chunks that have the fewest repeated copies among the neighbors (rares first technique). In this manner the rarest chunks get more quickly redistributed, roughly equalizing the numbers of copies of each chunk in the torrent.\nEvery 10 seconds the user measures the rate at which she receives bits and determines the four peers that are sending to her at the highest rate. It then reciprocates by sending chunks to these same four peers. The four peers are called unchocked. Every 30 seconds it also choses one additional neighbor and sends it chunks. These peers are called optmistically unchocked.\n2.6.2 Distributed Hash Tables (DHTs) How to implement a simple database in a P2P network? In the P2P system each peer will only hold a small subset of the totality of the (key, value) pairs. Any peer can query the distributed database with a particular key, the database will locate the peers that have the corresponding pair and return the pair to querying peer. Any peer can also insert a new pair in the databse. Such a distributed database is referred to as a distributed hash table (DHT). In a P2P file sharing application a DHT can be used to store the chunks associated to the IP of the peer in possession of them.\nAn approach: Let’s assign an identifier to each peer, where the identifier is an integer in the range [0, 2^n -1] for some fixed n. Such an identifier can be expressed by a n-bit representation. A hash function is used to transform non-integer values into integer values. We suppose that this function is available to all peers. How to assign keys to peers? We assign each (key,value) pair to the peer whose identifier is the closest to key, which is the identifier defined as the closest successor of the key. To avoid having each peer keeping track of all other peers (scalability issue) we use\nCircular DHT If we organize peers into a circle, each peer only keeps track of its immediate successor and predecessor (modulo 2^n). This circular arrangement of peers is a special case of an overlay network: the peers form an abstract logical network which resides above the “underlay” computer network, the overlay links are not physical but virtual liaisons between pairs of peers. A single overlay link typically uses many physical links and physical routers in the underlying network.\nIn the circle a peer asks “who is responsible for key k?” and it sends the message clockwise around the circle. Whenever a peer receives such message, it knows the identifier of its predecessor and predecessor, it can determine whether it is responsible (closest to) for the key in question. If not, it passes the message to its successor. When the message reaches the peer responsible for the key, it can send a message back to the querying peer indicating that it is responsible for that key. Using this system N/2* messages are sent on average (N = number of peers). In designing a DHT there is always a tradeoff between the number of neighbors for each peer and the number of DHT messages needed to resolve a single query. (1 message if each peer keeps track of all other peers; N/2 messages if each knows only 2 neighbors). To improve our circular DHT we could add shortcuts so that each peer not only keeps track of its immediate successor and predecessor but also of relatively small number of shortcut peers scattered around the circle. How many shortcut neighbors? Studies show that DHT can be designed so that the number of neighbors per peer as well as the number of messages per query is O(log *N*) (N the number of peers).\nPeer Churn In a P2P system, a peer can come or go without warning. To keep the DHT overlay in place in presence of a such peer churn we require each peer to keep track (know to IP address) of its predecessor and successor, and to periodically verify that its two successors are alive. If a peer abruptly leaves, its successor and predecessor need to update their information. The predecessor replaces its first successor with its second successor and ask it for the identifier and IP address of its immediate successor.\nWhat if a peer joins? If it only knows one peer, it will ask him what will be his predecessor and successor. The message will reach the predecessor which will send the new arrived its predecessor and successor information. The new arrived can join the DHT making its predecessor successor its own successor and by notifying its predecessor to change its successor information.\n2.7 Socket Programming: Creating Network Applications Only code explication —-\u003e skipping\nChapter 3: Transport Layer 3.1 Introduction and Transport-Layer Services A transport-layer protocol provides for logical communication (as if the hosts running the processes were directly connected) between application processes running on different hosts. Application processes use the logical communication provided by the transport layer to send messages to each other, free from the worry of the details of the physical infrastructure used. Transport-layer protocols are implemented in the end systems but not in network routers. On the sending side, the transport layer converts the application messages into transport-layer packets, known as transport-layer segments. This is done by breaking them into smaller chunks and adding a transport-layer header to each chunk. The transport-layer then passes the segment to the network-layer packet at the sending end-system. On the receiving side, the network layer extracts the transport-layer segment from the datagram and passes the segment up to the transport-layer which then processes the received segment, making the data in the segment available to the received application.\n3.1.1 Relationship Between Transport and Network Layers A transport-layer protocol provides logical communication between processes running on different hosts. Whereas a network-layer protocol provides logical communication between hosts.\n3.1.2 Overview of the Transport Layer in the Internet A TCP/IP network (such as the Internet) makes two distinct transport-layer protocols available to the application layer:\nUDP [ User Datagram Protocol], which provides an unreliable, connectionless service to the invoking application TCP [Transmission Control Protocol] which provides a reliable, connection-oriented service to the invoking application. We need to spend a few words on the network-layer protocol: the Internet network-layer protocol is the IP (Internet Protocol). It provides a logical communication between hosts. The IP service model is a best-effort delivery service: it makes the best effort to deliver segments between hosts, but it doesnt provide guarantees:\nit doesn’t guarantee segment delivery it doesn’t guarantee orderly delivery of segments it doesn’t guarantee the integrity of the data in the segments Thus IP is said to be an unreliable service. Every host has at least one network-layer address a so-called IP address.\nUDP and TCP extend IP’s delivery service between 2 end systems to a delivery service between two processes running on the end systems. Extend host-to-host delivery to process-to-process delivery is called transport-layer multiplexing and demultiplexing. UDP provides process-to-process delivery and error checking services. Therefore it is an unreliable service. TCP provides reliable data transfer using flow control, sequence numbers, acknowledgements and timers. TCP thus converts IP’s unreliable service between end systems into a reliable data transport service between processes. TCP also provides congestion control, a service not really provided to the invoking application as it is to the Internet as a whole: it prevents any TCP connection from swamping the links and routers between communication hosts with an excessive amount of traffic giving each connection traversing a congested link an equal share of the bandwidth.\n3.2 Multiplexing and Demultiplexing Here we’ll cover multiplexing \u0026 demultiplexing in the context of the Internet but a multiplexing/demultiplexing service is needed for all computer networks.\nThe job of delivering the data in a transport-layer segment to the correct socket is called demultiplexing. The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (which will be used in demultiplexing) to create segments and passing the segments to the networks layer is called multiplexing. Therefore sockets need to have unique identifiers and each segment needs to have special fields that indicate the socket to which the segment is delivered. These fields are the source port number field and the destination port number field. Each port number is a 16-bit number ranging from 0 to 65535. Port numbers ranging from 0 to 1023 are called well-known port numbers and are restricted, reserved for us by well-known application protocols such as HTTP (80) and FTP (21). Designing an application, we should assign it a port number.\nConnectionless Multiplexing and Demultiplexing A UDP socket is fully identified by the two-tuple: (destination IP address , destination port number) therefore if two UDP segments have different source IP address and/or source port numbers but have the same destination IP address and destination port number, than the two segments will be directed to the same destination process via the same destination socket. The source port number serves as part of the return address.\nConnection-oriented Multiplexing and Demultiplexing A TCP socket is identified by the four-tuple: (source IP address, source port number, destination IP address, destination port number) When a TCP segment arrives from the network to a host, the host uses all four values to demultiplex the segment to the appropriate socket. Two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP carrying the original connection establishment request) be directed to two different sockets.\nRoutine:\nThe TCP server application always has a welcoming socket that waits for connection establishment requests from TCP clients on port number X The TCP client creates a socket and sends a connection establishment request (a TCP segment including destination port, source port number and a special connection-establishment bit set in the TCP header) The server OS receives the incoming connection-request segment on port X, it locates the server process that is waiting to accept a connection on port number X, then creates a new socket which will be identified by (source port number in the segment (cleint), IP address of source host (client), the destination port number in the segment (its own), its own IP address) With the TCP connection in place, client and server can now send data to each other The server may support many simultaneous TCP connection sockets, with each socket attached to a process and each socket identified by its own four-tuple. When a TCP segment arrives at the host, all the fours fields are used to demultiplex the segment to the appropriate socket.\nPort Scanning Can be used both by attackers and system administrator to find vulnerabilities in the target or to know network applications are running in the network. The most used port scanner is nmap free and open source. For TCP it scans port looking for port accepting connections, for UDP looking for UDP ports that respond to transmitted UDP segments. It then returns a list of open, closed or unreachable ports. A host running nmap can attempt to scan any target anywhere in the Internet\nWeb Servers and TCP In a web server, all segments have destination port 80 and both the initial connection-establishment segments and the segments carrying HTTP request messages will have destination port 80, the server will distinguish clients using the source IP addresses and port numbers. Moreover in today’s high-performing Web, servers often use only one process and create a new thread with a new connection soket for each new client connection.\nIf using persistent HTTP, client and server will exchange messages via the same server socket. If using non-persistent HTTP, a new TCP connection is created and closed for every request/response and hence a new socket is created and closed for every request/response.\n3.3 Connectionless Transport: UDP UDP does multiplexing/demultiplexing, light error checking, nothing more. If the developer chooses UDP, the application is almost directly talking with IP. Note that with UDP there is no handshaking between sending and receiving transport-layer entities before sending a segment. For this reason UDP is said to be connectionless. DNS is an example of an application layer protocol that typically uses UDP: there is no handshaking and when a client doesn’t receive a reply either it tries sending the query to another name server or it informs the invoking application that it can’t get a reply. Why should a developer choose UDP?\nFiner application-level controll over what data is sent and when: as soon as the application passes data to UDP, UDP will package the data inside a segment and immediately pass it to the network layer. TCP’s congestion control can delay the sending of the segment and will try sending the packet until this is received. In real time applications the sending rate is important, so we can trade off some data loss for some sending rate. No connection establishement UDP justs send data without any formal preliminaries without introducing any delay, probably the reason why DNS runs over UDP. No connection state: because a UDP application doesn’t need to keep track of the users or to keep connections alive, it can typically support many more active clients than a TCP application Small packet header overhead TCP has 20 bytes of header overhead in every segment versus the 8 of UDP It is possible for an application developer to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself (eg adding acknowledgement and retransmission mechanisms) but it is a nontrivial task and may keep the developer busy for a long time.\n3.3.1 UDP Segment Structure The UDP header has only four fields, each consisting of two bytes:\nsource port number destination port number checksum (used for error detection.) length (which specifies the number of bytes in the UDP segment, header + data) This length field is needed since the size of the data field may differ from one UDP segment to the next.\n3.3.2 UDP Checksum Provides for error detection, to determine whether the bits in the segment have been altered as it moves from source to destination.\nAt the send side, UDP performs the 1s complement of the sum of all the 16-bit (max 64) words in the segment, with any overflow encountered during the sum being wrapped around. This result is put in the checksum field of the UDP segment header.\nUDP implements error detection according to the end-end principle: certain functionality (error detection in this case) must be implemented on an end-end basis: “functions placed at the lower levels may be redundant or of little value when compared to the cost of providing them at the higher level”.\n3.4 Principles of Reliable Data Transfer It is the responsibility of a realiable data transfer protocol to implement reliable data service: no transferred data bits are corrupted or lost and all are delivered in the order in which they were sent. We will consider the following actions:\nThe sending side of the data transfer protocol will be invoked from above by a call to rdt_send() On the receiving side rdt_rcv() will be called when a packet arrives while deliver_data() will be called when the rdt protocol wants to deliver data to the upper layer. We use the term packet rather than segment because the concepts explained here applies to computer networks in general. We will only consider the case of unidirectional data transfer that is data transfer from the sending to the receiving side. The case of reliable bidirectional (full-duplex) data transfer is not more difficult but more tedious to explain. Nonetheless sending and receiving side will need to transmit packets in both directions.\n3.4.1 Building a Reliable Data Transfer Protocol Finite-state machines (FSM) are boring! And unlikely to be asked at the exam, therefore I decided not to cover them here.\n3.4.2 Pipelined Reliable Data Transfer Protocols In today’s high-speed networks stop-and-wait protocols are simply not tolerable: we cannot send one packet and wait for the ACK and then send the second one, it is inefficient as we can see computing the utilization of the channel:\n$$ U = \\frac{L/R}{RTT+ L/R} $$\nThe solution is simple: rather than operate in a stop-and-wait manner, the sender is allowed to send multiple packets without waiting for acknowledgements. Since the many in-transit send-to-receiver packets can be visualized as filling a pipeline, this technique is known as pipelining.\nSome consequences:\nThe range of sequence numbers must be increased: each in-transit packet must have a unique sequence number Sender and receiver may have to buffer more than one packet. Two basic approaches toward pipelined error recovery can be identified: Go-Back-N and Selective Repeat\n3.4.3 Go-Back-N (GBN) The sender is allowed to send N packets (sender window size = N), the receiver has a window of size 1. If a segment from sender to receiver is lost, the receiver discards all the segments with sequence number greater than the sequence number of the dropped packet, answering with ACK with this sequence number. (no packet re-ordering) The sender will wait for ACK in order to move the window and send new packets. The wait is not infinite, after a certain time a timeout will occur and the sender will retransmit all the packets in the sending window. In a Go-Back-N protocol, acknowledgements are cumulative: if sender receives ACK3 he will know that all the packets from 0 to 3 have been received, even if hasn’t received ACK2.\n3.4.4 Selective Repeat When the window-size and bandwidth-delay product are both large, many packets can be in the pipeline and a single packet error can thus cause GBN to retransmit a large number of packets, many unnecessarily. Selective Repeat avoid unnecessary retransmissions by having the sender retransmit only those that packets it suspects were received in error at the receiver: individual acknowledgements (opposed to cumulative). sender window size = N and receiver window site = N. The sender has a timer for each packet in its window. When a timeout occurs, only the missing packet is resent. The receiver buffers out of order packets.\n3.5 Conncetion-Oriented Transport: TCP 3.5.1 The TCP Connection TCP is said to be connection-oriented because before one application process can begin to send data to another, the two processes must first “handshake” with each other. During the connection establishment, both sides of the connection will initialize many TCP state variables. TCP connection is not an end-to-end TDM or FDM circuit nor is it a virtual circuit as the connection state resides entirely in the two end systems and not in the intermediate network elements. A TCP connection provides a full-duplex service: when a connection between process A and process B, application layer data can flow from A to B and, at the same time, from B to A. TCP is also point-to-point: a connection is always between a single sender and a single receiver, no multicast possible.\nEstablishment of the connection: the client first sends a special TCP segment, the server responds with a second special TCP segment and the client answer again with a third special TCP segment. The first two cannot contain a payload while the third can. Three segments: three-way handshake. Both the sender and the receiver have buffers that are set up during the handshake. The maximum amount if data that can be grabbed and placed in a segment is limited by the maximum segment size (MSS). TCP therefore splits data into smaller chunks and pairs each chunk of client data with a TCP header thereby forming TCP segments which are passed down to the network layer. When TCP receives a segment at the other end, the segment’s data is placed in the TCP connection’s receive buffer. Each side of the connection has its own send buffer and its own receive buffer\n3.5.2 TCP Segment Structure 32 bit sequence number and acknowledgement number necessary for reliable data transmission 16 bit receive window used for flow control, indicates the number of bytes that a receiver is willing to accept 4 bit header length field. The TCP header can be of a variable length due to the TCP options field (usually empty therefore usual length is 20 bytes) options field used to negotiate MSS or as a window scaling factor for use in high speed networks. flag field: 6 bits: ACK used to indicate that the value carried in the acknowledgement field is valid, that is the segment contains an acknowledgement for a segment that has been successfully received. , 3. and 4. RST, SYN, FIN for connection setup and teardown PSH indicates that the receiver should pass the data to upper layer immediately URG indicates that there is data in the segment that the sending side upper layer has marked as urgent. Sequence Numbers and Acknowledgment Numbers TCP views data as an unstructured, but ordered, stream of bytes and TCP’s use of sequence numbers reflects this view: sequence numbers are over the stream of bytes and not over the series of transmitted segments. The sequence number for a segment is the byte-stream number of the first byte in the segment. EX 500,000 bytes, MSS = 1,000 bytes =\u003e 500 segments are created. First is numbered 0, second 1000, third 2000…..\nThe acknowledgement number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B. TCP is said to provide cumulative acknowledgements: if sender receives ACK 536 he will know that all the bytes from 0 to 535 have been well received. What does a host do when it receives out-of-order segments? The receiver buffers the out-of-order bytes and waits for the missing bytes to fill in the gaps. Usually both sides of a TCP connection randomly choose an initial sequence number randomly both for security and for minimizing the possibility that a segment that is still present in the network from an earlier, already terminated connection between two hosts is mistaken for a valid segment in a later connection between these same two hosts.\n3.5.3 Round-Trip Time Estimation and Timeout TCP uses a timeout/retransmit mechanism to recover from lost segments. The question rises: How long should the timeout intervals be? Clearly the timeout should be larger than the connection’s round-trip time? How much larger? How can the RTT be evaluated?\nEstimating the Round-Trip Time The sample RTT, SampleRTT, for a segment is the amount of time between when the segment is sent (passed to network layer) and when an acknowledgement for the segment is received. Most TCP implementations take one SampleRTT at a time: at any point in time, the SampleRTT is being estimated for only one of the transmitted but currently unacknowledged segments, leading to a new value of SampleRTT for approximatively every RTT. TCP never computes a SampleRTT for a segment that has been retransmitted, only for segments transmitted once. In order to estimate a typical RTT, TCP keeps an average called EstimatedRTT of the SampleRTT values. Upon obtaining a new SampleRTT TCP updates this estimation according to the formula:\nEstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT\nwhere usually a = 1/8 = 0.125\nWe note that this weighted average puts more weight on recent samples than on old samples. In statistics such an average is called an exponential weighted moving average (EWMA). It is also useful to having an estimate of the variability of the RTT. We can measure how much SampleRTT typically deviates from EstimatedRTT:\nDevRTT = (1 - b) * DevRTT + b* | SampleRTT - EstimatedRTT |\nWe note that this is an EWMA of the difference of estimated and last measured RTT. The recommended value for b is b = 0.25\nSetting and Managing the Retransmission Timeout Interval TimeoutInterval = EstimatedRTT + 4 * DevRTT\nAn initial TimeoutInterval value of 1 second is recommended. Also when a timeout occurs, the value of TimeoutInterval is doubled in order to avoid a premature timeout occurring for a subsequent segment that will soon be acknowledged. As soon as a segment is received and EstimatedRTT is updated, the TimeoutInterval is again computed using the formula above.\n3.5.4 Reliable Data Transfer TCP creates a reliable data transfer service on top of IP’s unreliable best-effort service. It ensures that the data stream that a process reads out of its TCP receive buffer is uncorrupted, without gaps, without duplication and in sequence. We supposed until now that an individual timer was associated with each transmitted segment. However timer management can require considerable overhead. Thus the recommended TCP timer management procedures (defined by RFC standards) use only a single retransmission timer (it is helpful to think of the timer as being associated with the oldest unacknowledged segment).\nUpon receiving data from the application layer, TCP encapsulates it in a segment and passes to the segment to IP. If the timer is not running for some other segment, TCP starts it when the segment is passed to IP, the timer expiration interval being TimeoutInterval If the timeout occurs, TCP responds by retransmitting the segment that caused the timeout and by restarting the timer An valid acknowledgement segment is received: TCP compares the ACK y value with its sendBase (the sequence number of the oldest unacknowledged byte). If y \u003e sendBase then ACK is acknowledging one or more previously unacknowledged segments (cumulative acknowledgement). The sendBase variable is updated and the timer is restarted if there are not-yet-acknowledged segments. Doubling the Timeout Interval Each time TCP retransmits, it sets the next timeout interval to twice the prevous value. However when the timer is restarted after receiving data from the application layer or after receiving an ACK, the TimeoutInterval is recomputed as described previously\nFast Retransmit The problem with timeout-triggered retransmission is that the timeout period can be relatively long. The sender can however often detect packet loss before the timeout event occurs by noting duplicate ACKs. A duplicate ACK is an ACK that reacknowledges a segment for which the sender has already received an earlier acknowledgement. When the TCP sender receives three duplicate ACK for the same data it takes this as an indication that the segment following the segment that has been ACKed three times has been lost. In the case that three duplicate ACKs are received, the TCP sender performs a fast restransmit: it retransmits the missing segment before that segment’s timer expires.\nGo-Back-N or Selective Repeat? Acknowledgments are cumulative (GBN) but many TCP implementations will buffer correctly received but out-of-order segments. Also consider fast retransmit where only the missing packet is resent (SR) instead of all the window (GBN). We can see that TCP’s error recovery mechanism is categorized as a hybdrid of GB and SR protocols.\n3.5.5 Flow Control The host on each side of a TCP connection set aside a receive buffer for the connection. When TCP receives bytes that are correct and in sequence, it places the data in the receive buffer. The associated application process will read data from this buffer, but necessarily at the instant the data arrives (busy, not interested…). Thus the the sender can easily overflow the connection’s receive bufffer by sending too much data too quickly. To avoid this event, TCP provides a flow-control service. Flow control is a speed-matching service: matching the rate at which the sender is sending against the rate at which the receiving application is reading.\nFlow control and congestion control are not the same!: the former preventing overflow at the receiver side and being actuated only by the two end points, the latter preventing congestion of the network.\nTCP provides flow control by having the sender maintain a variable called the receive window, used to give the sender an idea of how much free buffer space is available at the receiver.\nHost A sends a large file to Host B over TCP.\nB side B allocates a receive buffer to its connection, its size being RcvBuffer B also keeps the variables: LastByteRead (number of last byte in the data stream read by the application process) and LastByteRcvd (the number of the last byte arrived from the network and placed in the receive buffer) We have: LastByteRcvd - LastByteRead \u003c= RcvBuffer (we don’t want overflow!)\nReceive window aka the amount of spare room in the buffer rwnd = RcvBuffer - [LastByteRcvd - LastByteRead] rwnd is dynamic\nA side A keeps track of two variables:\n1. `LastByteSent` 2. `LastByteAcked` Through the connection’s life A must make sure that LastByteSent - LastByteSent \u003c= rwnd\nIf B’s buffer becomes full, he sends rwnd = 0. If B has nothing to send to A, when the application process empties B’s buffer, TCP does not send a new segment with the new value of rwnd to A (TCP sends to A only if it needs to send data or if it needs to send an ACK). Therefore A is never informed that B’s buffer has some free space and he is blocked and can trasmit no more data. To solve this problem, TCP requires A to continue to send segments with one data byte when B’s receive window is 0, these segments will be acknowledged by B. Eventually the buffer will begin to empty and the acknowledgements will contain à non-zero rwnd value.\nWe remember that UDP has no flow control service\n3.5.6 TCP Connection Management How is the connection established? Three-way handshake The client-side TCP sends a special TCP segment to server-side TCP. This segment doesn’t contain any application-layer data but the flag bit SYN is set to 1. The segment is referred to as a SYN segment. The client also randomly chooses an initial sequence number (client_isn) and puts this number in the sequence number field of the initial TCP SYN segment. (randomizing client_isn is interesting to avoid security attacks). The TCP SYN segment arrives at the server-side, it is extracted from the datagram. The server allocates the TCP buffers and variables to the connection and sends a connection-granted segment to the client. This segment also contains no application-layer data. The SYN flag is set to 1, the ACK field in the header is set to client_isn+1. The server chooses its own initial sequence number server_isn and puts this value in the sequence number field of the TCP segment header. This segment is referred to as SYNACK segment. Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client then sends the server yet another segment which acknowledges the SYNACK (server_isn+1 is set the acknowledgement field of the TCP segment header) After this setup, all the segments will have the SYN bit set to 0 in their headers.\nTearing down a TCP connection The client decides to end the connection:\nThe client sends a special TCP segment to the server, this special segment having the FIN bit flag set to 1 in the header. The server receives the segment and sends an acknowledgement to the client. The server then sends its own shutdown segment which also has the FIN bit set to 1 The client acknowledges the server’s shutdown segment. The “resources” (buffers and variables) in the hosts are deallocated. What if the two ends are not ready for communication? A host receives a TCP segment whose port number or source IP address do not match with any of the ongoing sockets in the host -\u003e the host sends a special reset segment to the source (RST flag bit set to 1) and drops the packet (UDP does responds with a special ICMP datagram)\n3.6 Principles of Congestion Control 3.6.1 The Causes and the Costs of Congestion Scenario 1: Two Senders, A Router with Infinite Buffers A -\u003e D, B -\u003e C, A and B connect to the Internet through the same router, B and C connect to the Internet through the same router (pas envie)\n3.7 TCP Congestion Control TCP limits the rate at which it sends traffic into its connection as a function of perceived network congestion. The TCP congestion-control mechanism operating at the sender keeps track of an additional variable: the congestion window, noted cwnd which imposes a constraint on the rate at which a TCP sender can send traffic into the network. Specifically: LastByteSent - LastByteAcked \u003c= min{cwnd, rwnd}. Limiting the amount of unacknowledged data at the sender we can limit the sender’s send rate. At the beginning of each RTT the sender sends cwnd bytes of data and at the end of the RTT he acknowledges. Thus the sender’s send rate is roughly cwnd/RTT bytes/sec. Adjusting the value of cwnd the sender can adjust the rate at which it sends data into the connection. Let now consider a loss event (timeout OR three duplicate ACKs). When there is excessive congestion some router buffers along the path overflows, causing a loss event at the sender which is taken by the sender to be an indication of congestion on the sender-to-receiver path. If there is no congestion then all the acknowledgements will be received at the sender, which will take these arrivals as an indication that segments have been received and that he can increase the congestion window size and hence its transmission rate. If acknowledgements arrive at a slow rate then the congestion window will be increased at a relatively slow rate and, viceversa, it will be increased more quickly if ACKs arrive at a high rate. Because TCP uses acknowledgements to trigger (or clock) its increase in congestion window size, TCP is said to be self-clocking. TCP uses the principles:\nA lost segment implies congestion therefore the sender rate should be decreased. An acknowledged segment means the network’s working, therefore the sender’s rate can be increased (if ACK of unacknowledged segment) Bandwidth probing: the transmission rates increases with ACKs and decreases with loss events: TCP is continuously checking (probing) the congestion state of the network TCP Congestion-Control Algorithm Three components :\n1 - Slow Start When a TCP connection begins, cwnd is usually initialized to a small value of 1 MSS and only one segment is sent. Each acknowledged packet will cause the cwnd to be increased by 1 MSS and the sender will send now two segments (because the window is increased by one for each ack). Therefore the number of segments doubles at each RTT, therefore the sending rate also doubles every RTT. Thus TCP send rate starts slow but grows exponentially during the slow start phase. When does the growth end?\nTimeout: cwnd is set to 1 MSS and the slow start is started anew. Also the variable slow start threshold is initialized: ssthresh = cwnd / 2 - (half of value of cwnd when congestion is detected) When cwnd \u003e= ssthresh slow starts is stopped -\u003e congestion avoidance state Three duplicate ACKs: fast retransmit and fast recovery state 2 - Congestion Avoidance TCP suppose congestion is present, how to adapt? Instead of doubling cwnd every RTT, cwnd is increased by just a single MSS every RTT. When should this linear increase stop?\nTimeout: cwnd is set to 1 MSS, and ssthresh = cwnd (when loss happened) / 2 Three duplicate ACKs: cwnd = (cwnd / 2) + 3 MSS and ssthresh = cwnd (when 3 ACKs received) / 2 -\u003e fast recovery state 3 - Fast Recovery cwnd is increased by 1 MSS for every duplicate ACK received for the missing state that caused TCP to enter this state. When the ACK arrives for the missing segment, TCP goes into Congestion Avoidance after reducing cwnd. If a timeout occurs cwnd is set to 1 MSS and ssthresh is set to half the value of cwnd when the loss event occurred. Fast recovery is recommended but not required in TCP, in fact only the newer version of TCP, TCP Reno incorporated fast recovery.\nMacroscopic Description of TCP Throughput What is the average throughput (average rate) of a long-lived TCP connection? Ignoring the slow start phase (usually very short as the rate grows exponentially). When the window size is w the transmission rate is roughly w/RTT. w is increased by 1 MSS each RTT until a loss event. Denote by W the value of w when a loss event occurs. Then we have\naverage throughput of a connection = (0.75 * W)/RTT\nTCP Over High-Bandwidth Paths Today’s high speed links allow to have huge windows. What happens if one of the segments in the window gets lost? What fraction of the transmitted segments could be lost that would allow the TCP congestion control to achieve the desired rate?\naverage throughput of a connection = (1.22 * MSS)/(RTT * sqrt(L))\nWhere L is the loss rate\nChapter 4: The Network Layer In the chapter, there is an important distinction between the routing and forwarding functions of the network layer. Forwarding involves the transfer of a packet from an incoming link to an outgoing link within a single router while routing involves all of a network’s routers whose collective interactions via routing protocols determine the paths that packets take on their trips from source to destination.\n4.1 Introduction The primary role of routers is to forward datagrams from input links to output links. Routers do not run nor the application-layer or the transport-layer, they go only up until the network layer.\n4.1.1 Forwarding and Routing The role of the network layer is deceptively simple: to move packets from a sending hosts to a receiving host. To do so it performs two important functions:\nForwarding: When a packet arrives to a router’s input link, the router must move the packet to the appropriate output link. It is an action local to the router Routing: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as routing algorithsm. It is a network-wide action Every router has a forwarding table. When a router receives a packet, it extracts a value from a specific field in the header and searches for that value in in the forwarding table. The procedure used to set up and update the table depends on the protocol used. However a router receives and sends routing protocol messages to configure its forwarding table.\nWe also need to mark the distinction between routers and packet switches.\nPacket-switches: performs forwarding according to the value in a field in the header of the packet. Some packet switches called link-layer switches base their forwarding decisions on values in the fields of the link-layer frame (link-layer devices) Routers: base forwarding decisions on the value in the network-layer field. (network-layer devices) but also must implement link layer (no 3 without 2) Connection Setup in some computer networks there is a third really important networks-layer function: connection setup: a path-wide process that sets up connection state in routers.\n4.1.2 Network Service Models The network service model defines the characteristics of end-to-end transport of packets between sending and receiving end systems. Some possible service for a network layer:\nSending side: Guaranteed delivery Guaranteed delivery with bounded delay Flow and receiving side: In-order packet delivery Guaranteed minimal bandwidth Guaranteed maximum jitter (amount of time between transmission of two successive packets at the sender side is equal to the amount of time between their receipt at the destination, or that this spacing changes by no more than some specified value) Security services: encryption for confidentiality, data integrity and source authentication The Internet’s network layer doesn’t provide any of these: it provides a best-effort service there are no timing or bandwidth guarantees, no loss or order guarantees and congestion control indications.\n4.2 Virtual Circuit and Datagrams Networks As in transport layer, the network layer can use connection or connection-less protocols. There however some differences with the transport layer:\nIn the network layer these services are host-to-host services (not the case for the TL, just look at TCP) The network layer provides either a host-to-host connectionless service or a host-to-host connection service but no both. Connection service -\u003e Virtual-Circuit (VC) networks, Connectionless service -\u003e datagram networks 4.2.1 Virtual-Circuit Networks The Internet is a datagram network but many alternative network architectures (ATM) are virtual-circuit networks. The connections in VC are called *virtual circuits (VCs)3. A VC consists of\nA source-to-destination path VC numbers, one for each link along the path Entries in the forwarding table in each router along the path A packet belonging to a virtual circuit will carry a VC number in its header. Because a VC may have different VC numbers on each link, each router must replace the VC number of traversing packets with a new VC number, which is obtained from the forwarding table. How is this determined? Whenever a VC is established across a router, an entry is added to the forwarding table, and one (corresponding to the terminating VC) is removed whenever a VC ends. The routers must maintain connection state information for the ongoing connections (using the tablea). There are 3 phases in a VC:\nVC Setup: sending side contacts networks layer specifying the IP address of the destination. The network sets up the VC. The path is determined as well as the VC number for each link along the path. The forwarding tables are updated and resources reserved. Data transfer: the packets flow VC teardown: The call termination propagates along the path, the forwarding tables are updated During network-layer setup all the routers along the path between source and destination are involved in VC setup, and each router is fully aware of all VCs passing through it (not in TCP: setup and connection only between source and destination). The messages used by end ssystems to initiate or terminate a VC are called signaling messages and the protocols used to exchange them are called signaling protocols.\n4.2.2 Datagram Networks Each time an end system wants to send a packet, it sampts the packet with the address of the destination end system and pops the packet into the network. The routers along the path will use this address to forward it. The router has a forward table that maps destination addresses to link interfaces. When a packet arrives, it reads the destination address, uses the table to determine what link to use, and forwards the packet to that output link interface.\nIf we consider IPv4, addresses are 32 bits long. To avoid having tables with 2^32 entries, routers use prefixes. When there are multiple mathces to one address, the router uses the longest prefix matching rule.\nAlthough routers in datagram networks maintain no connection state information, they nevertheless maintain forwarding state information in their forwarding tables.\n4.2.3 Origins of VC and Datagram Networks VC has its roots in the telephony world, which uses circuits switching too. The datagram model instead comes from the need to simplify as much as possible the network to bring computers together.\n4.3 What’s Inside a Router? Input ports: performs the physical layer functions of incoming link at the router. It is also here that the forwarding table is consulted to determine the output port to which the arriving packet will be forwarded via the switching fabric. Control packets (protocol info) are forwarded to the routing processor. Switching fabric: connects input prots to output ports. Output ports: stores packets received from the switching fabric and performs the necessary link layer and physical layer functions. Routing processor: executes the routing protocols (algorithms), maintains routing tables and attached link state information and computes the forwarding table for the router. Input ports, switching fabric and output ports implement the forwarding function and are almost always implemented in hardware (routing forwarding plane hardware) while the routing processor implements the routing function and is usually implemented in software running on traditional CPU (router control plane)\n4.3.1 Input Processing The packet arrives and the link and phyisical layer unpacking functions are performed. The forwarding table is computed and updated by the routing processor with a shadow copy typically stored at each input port so that forwarding decision can be made locallly without invoking the centralized routing processor on a per packet basis and thus avoiding a centralized processing bottleneck. The table is transferred to ports through separated bus. The lookup is then just a search (implemented in hardware and using high performance algorithms), speed also depends on the memory technology (DRAM, SRAM…). Lookup is important but input processing also consists of\nphysical and link layer processing chekcing the packet’s version number, checksum, time to live…. updating counters for network management. Input ports than moves the packet to the switching fabric (eventually queuing them if this is busy)\n4.3.2 Switching Can be performed in different ways:\nSwitching via memory Switching under the control of the CPU and input and output ports functioned as traditional I/O devices in a traditional operating system. The packet arrives, is copied into the processor memory, the processor determines the output port and copies the packet to the output port’s buffer. No parallel forwarding (only 1 memory read/write bus)\nSwitching via a bus An input port transfers a packet directly to the output port over a shared bus without intervention by the routing processor. The input port pre-pends an internal header to the packet. All the output ports receive the packet but only the one that matches the label in the internal header will keep the packet. The output port will remove this internal header. The switching speed is limited to the bus speed as one packet at a time can cross the bus (multiple arriving packets will have to wait). Sufficient only for small area and enterprise networks\nSwitching via an interconnected network To overcome the bandwidth limitation of a single shared bus a more sophisticated interconnection network can be used. A crossbar switch is an interconnection network consisting of 2N buses that connect N input ports to N output ports. Each vertical bus intersects each horizontal bus at a crosspoint which can be opened or closed at any time by the switch fabric controller. If a packet has to go from input X to output Y, only the crosspoint between the horizontal bus from X and the vertical bus to Y will be closed. Thus packets directed to different output ports can be forwarded simultaneously, but not multiple packets directed to the same output port.\n4.3.3 Output Processing takes packets stored in the output’s port’s memory and transmits them over the output link, thus selecting de dequeuing packets for transmission and performing the necessary link and physical layer transmission functions.\n4.3.4 Where Does Queuing Occur? Queues may form at both the input ports and the output ports. The location and the extent of queuing will depend on traffic load, speed of the switching fabric, and line speed. As the queues grow large, the router’s memory can eventually be exhausted and packet loss will occur. IS THIS USEFUL ? NOT COVERED BY TEACHER\n4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet We know move to study of the network layer in the Internet. There are two versions of the IP (Internet Protocol) in use today: IPv4 and IPv6. There 3 main components in the Internet: the IP Protocol (addressing, datagram format and packet handling conventions), the routing protocol (path selection), the Internet Control Message Protocol (ICMP) (error reporting and network information).\n4.4.1 Datagram Format A network layer packet is referred to as a datagram.\nSome fields:\nVersion number: 4 bits specifying the IP protocol version of the datagram (IPv4 or IPv6 ) Header length: the length of the packet is variable therefore this field tells where the header ends and the data begins. Usually datagrams contain no option so that the typical IP datagram has 20-byte header Type of service (TOS): allows different types of datagrams to be distinguished from each other. (eg real time vs non real time) Datagram length: 16 bits specifying the total length, that is header + data measured in bytes. 16 bits -\u003e max header length = 65535 bytes, but usually datagrams are rarely larger than 1500 bytes. Identifier, flags, fragmentation offset: used for IP fragmentation. (NB: IPv6 doesn’t allow fragmentation at routers) Time-to-live (TTL): used to avoid that datagrams circulate forever. It is decreased by one each time the datagram is processed by a router. When TTL = 0, the datagram is dropped Protocol: only used when datagram reaches its final destination, it specifies what transport protocol to which the data of the datagram should be passed. EX: 6 -\u003e TCP, 17 -\u003e UDP Header checksum: helps the router to detect bit errors in a received IP datagram. Computation: each two bytes in the header are considered as numbers, summed up using the 1s complement arithmetic. The 1s complement of this sum is then put in the checksum field. A router computes the checksum for each datagram. If the computed one doesn’t equal the one in the field then the router has detected an error. Usually the datagram is discarded. As it is recomputed at each router, it may change. Source and destination IP addresses Options: rarely used, dropped by IPv6 Data (payload): usually contains the transport layer segment but can also contain ICMP messages IP Datagram Fragmentation The maximum amount of data that a link layer can carry is called the Maximum Transmission Unit (MTU). As each datagram is encapsulated in a link layer frame, the MTU imposes a hard limit on the length of the datagram. Each of the links along the route can use different link-layer protocols and therefore can have different MTU. We therefore have to break the IP datagram into smaller datagrams, each of which will go in different link layer frames. Each of these smaller datagrams is referred to as a fragment. A fragment must be reassembled before it can be passed to the transport layer. To reduce the workload on routers, the designers of IPv4 decided that reassembling should only be done at the destination end system.\nIn IPv4, to comply with fragmentation, the header contains the fields:\nIdentifiers: identifies the unfragmented datagram (same for all fragments) flags: in particular there is one flag set to 0 if the fragment is the last or to 1 if there are more to come fragmentation offset: an integer x, the data in the fragment should be inserted beginning at byte x * 8 If one fragment contains error or is lost, all the others are dropped and TCP will have the sender retransmit all the data. Fragmentation complicates the network and end systems and can be used in lethal DoS attacks such as the Jolt2 attack\n4.4.2 IPv4 Addressing The boundary between the host and the physical link is called an interface. A router has multiple links connected to it, therefore multiple interfaces and therefore a router has multiple IP addresses and an IP address is technically associated with an interface rather than with a host or router. IPv4 addresses are 32 bits long (4 bytes) -\u003e max 2^32 possible addresses. They are typically writen in dotted decimal notation where each byte of the address is written in deciaml from and separated by a period from the others. EX 193.32.216.9 === 11000001 00100000 11011000 00001001 Each interface on every host (except host behind NATs) must have a unique IP address. How are these computed? A portion is determined by the subnet to which the host is connected. A subnet is the portion of the network interconnected end systems and one one router. (also called IP network or network). IP assigns an address to a subnet x.x.x.x/y where /y notation, sometimes known as a subnet mask indicates that the leftmost y bits of the 32 bit quantity define the subnet address. If y is 24, then any host attached to the a.a.a.0/24 subnet would be required to have an address of the form a.a.a.xxx.\nFIGURE 4.17 WTF\nThe Internet’s address assignment strategy is known as Classless Interdomain Routing (CIDR). It generalizes the notion of subnet addressing. Consider a.b.c.d/x : the x most significant bits constitute the network portion of the IP address and are often referred to as the prefix (or network prefix). EX an organization is assigned a block of contiguous addresses, that is, a range of addresses with a common prefix. When someone outside the organization want to send a datagram to someone inside, he will only need this x bits. The remaining 32-x bits can be thought of as distinguishing among the devices within the organization. These bits may have an additional subnetting structure. There is yet another type of IP address, the IP broadcast address 255.255.255.255. When a datagram is sent to this address, the datagram is delivered to all hosts on the same subnet.\nObtaining a Block of Addresses A network administrator contacts an ISP which would provide a partition of the addresses that had already been allocated to him. EX ISP has 200.23.16.0/20, it splits in 8 equal sized blocks: 200.23.16.0/23, 200.23.18.0/23, 200.23.20.0/23, …, 200.23.30.0/23 Who assigns set of addresses to ISPs? The Internet Corporation for Assigned Names and Numbers (ICANN) which allocates IP addresses, manages DNS root servers, assigns domain names and solves domain name disputes.\nObtaining a Host Address: The Dynamic Host Configuration Protocol Once an organization has obtained a block of addresses, it can assign individual IP addresses to the hosts and router interfaces which are part of it. This can be done either manually (by the network administrator) or automatically by the Dynamic Host Configuration Protocol (DHCP). It can be configured so that a host receives the same IP each time it connects to the network or a temporary IP addresses that will change upon each connection. DHCP also transmits to hosts additional information (subnet mask, address of first-hop = default gateway, address of local DNS server). As it automates the connection of a host into the network, DHCP is often referred to as a plug-and-play protocol. It is also popular in *wireless LANs where hosts join and leave frequently and in residential ISP access networks. DHCP is a client-server protocol, the client being a newly arriving host needing network configuration information and the server being a router or a DHCP relay agent that know the address of a DHCP server for that network. For a new client there is a 4 step process i nthe DHCP protcol:\nDHCP server discovery c (client) looks for a server sending DHCP discover message a UDP packet directed to port 67. This segment is encapsulated in datagram sent to 255.255.255.255 (broadcast address) from address 0.0.0.0 DHCP server offer(s) s (server) replies with a DHCP offer message broadcast to all nodes on the subnet using (sent to 255.255.255.0). c may receiver many of these (more servers) containing the transaction ID, proposed IP address and an address lease time (amout of time for which the address will be valid) DHCP request: c chooses one offer and responds to s with a DHCP request message echoing back the configuration parameters DHCP ACK s responds with DHCP ACK message confirming DHCP also provides a mechanism for renewing the lease on an address.\nNetwork Address Translation (NAT) Every IP-capable device needs an IP address. The number of connected devices grows fast, how to deal with IPv4 address space exhaustion? Network Address Translation (NAT) The NAT-enabled router defines a realm (or private network) (a network whose addresses only have meaning to devices within that network) and it can use the whole 32 bit address space for devices connected to it, it will also have a public address used to communicate with the exterior. The picture is explicative.\nFrom the outside the router looks like a single device with a single IP address. It hides the details of the internal network from the outside world. Internal addresses can be assigned using DHCP.\nProblems with NAT:\nPort number should be used for addressingi processes not hosts Routers shouldn’t have access to the transport layer (ports) NAT violates end-to-end argument (any host should be able to contact any other host) NAT interferes with P2P applications (peers hidden by NAT), therefore the need of connection reversal for NAT traversal UPnP NAT traversal is increasingly provided by Universal Plug and Play. It requires both the host and the NAT to be compatible. Host requests a NAT mapping_ (private IP address, private port number) -\u003e (public IP address, public port number) If the NAT accepts and creates the mapping, then outsiders can create connections to (public IP address, public port number).\n4.4.3 Internet Control Message Protocol ICMP is used to communicate network-layer information between hosts and routers, usually for error reporting (ex Destination network unreachable). ICMP is considered part of IP but architecturally lies just above IP as ICMP messages are carried inside IP datagrams as payloads. ICMP have a type and a code field and carry the header and the first 8 bytes of the datagram that caused the message to be generated in the first place. Ping and traceroute are implemented using ICMP messages\nInspecting datagrams: firewalls and intrusion detection systems Firewalls inspect the datagram and segment header fields denying suspicious datagrams entry into the internal network. Firewalls can block ICMP packages or packets based on port numbers, addresses. Additional protection can be provided by IDS, placed at the boundary of the network, performs deep packet inspection examining not only headers but also payloads (including application layer data). IDS have databases of packet signatures that are know to be dangerous. As packets flow through the IDS, it tries to match them to signatures in its database, if a match is found, an alert is created. IPS (intrusion prevention system) in addition to detecting, also blocks packets raising alerts.\n4.4.4 IPv6 Developed because of IPv4 address space exhaustion\nDatagram format the size of the source and destination addresses is increased from 32 to 128 bits: every grain of sand on the planet can be addressable. Unicast and multicast addresses are joind by the anycast address which allow a datagram to be delivered to any one of a group of hosts. A number of IPv4 fields have been dropped or made optional resulting in a 40-byte fixed-length header which allows faster datagram processing. Flow label not clear definition. 20-bit Version: 4-bit for IPv6 or 4. If ipv6 -\u003e 0110 Traffic class: 8 bit similar to TOS Payload length: 16 bit unsigned integer indicating number of bytes following the 40-byte datagram header Next header: transport layer protocol Hop limit: decremented by one by each router forwarding the datagram, when 0, the datagram is discarded Fragmentation and reassembly cannot be done by intermediate routers, only by source and destination. If a router cannot trasmit a datagram because too big, it drops it and sends back an ICMP error message “Packet too big”. This reduces a lot the workload on the network.\nAs the transport layer and the link layer already perform check-summing, this functionality has been removed from the network layer for faster datagram processing.\nAn option field is no longer part of the header, instead it is one of the possible next headers pointed to from the header. A new version of ICMP has been defined for IPv6 which includes messages adapted to IPv6 (“packet too big”) and replaces IGMP (Internet Group Management Protocol), used to manage a host’s joining and leaving of multicast groups.\nTransitioning from IPv4 to IPv6 IPv6 is back compatible with IPv4 but not viceversa.\nIt’s not humanable possible to decide a date on which all machines would change their protocol. The most straightfoward way is a dual stack approach where IPv6 nodes also have a complete IPv4 implementation. To determine whether anotehr node is IPv6 or IPv4-only DNS can be used, just checking whether the node has a IPv6 address or an IPv4 one. However this will bring about the loss of data in specific IPv6 header fields. Another approach would be tunneling : when two IPv6 nodes are connected by intervening IPv4 routers, we call the IPv4 nodes tunnel, the entire IPv6 datagram is put in the payload field of a IPv4 datagram which will be propagated by the tunnel unaware of the details and received by the destination IPv6 node which is able to extract the IPv6 datagram and to route it. This migration shows the difficulty in changing network-layer protocols.\n4.5 Routing Algorithms A host is attached directly to one router, the default router for the host (also called first hop router). Whenever a host sends a packet, the packet is transferred to its default router, which we’ll call source router, we’ll call the default router for the destination host as the destination router. Routing a packet from source to destination boils down to routing the packet from source router to destination router.\nThe purpose of a routing algorithm is simple: given a set of routers connected by links, it finds a “good” path from source to destination router. A good path is the least expensive one.\nGraphs (see Algorithms course) are used to formulate routing problems, the node representing routers and the edges the links connecting them. Each edge also has a value representing its cost. For any nodes x and y in the G(raph) we denote c(x,y) the cost of the edge between them. If (x,y) doesn’t belong to G, we set c(x,y) = infinity. We only consider undirected graphs. We just have to find the least costly paths between sources and destinations. We can classify routing algorithms in two groups:\nGlobal routing algorithms: compute the least-cost path between a source and a destination using complete, global knowledge about the network. They are often referred to as link-state (LS) algorithms since the algorithm must be aware of the cost of each link in the network Decentralized routing algorthms: compute the least-cost path in an iterative, distributed manner: no node has complete information about the cost of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links. We could also make another classification separating static routing algorithms (routes change very slowly, eg after human intervention) and dynamic routing algorithms( routing change as the load or topology change). Finally another distinction could be made between load-sensitive or load-insensitive algorithms according to whether link costs vary reflecting the level of congestion.\n4.5.1 The Link-State (LS) Routing Algorithm All link costs are known. In practice this is accomplished by having each node broadcast link-state packets to all other nodes in the network, each packet containing the identities and costs of its attached links resulting in all nodes having an identical and complete view of the network (each node could run the algorithm). A link-state algorithm can be Dijkstra’s algorithm or Prim’s algorithm. Code and example page 394\n4.5.2 The Distance-Vector (DV) Routing Algorithm The distance-vector algorithm is iterative, asynchronous and distributed.\nDistributed because each node receives some information from one or more of its directly attached neighbors, performs a calculation and then distributes the results back to its neighbors. iterative: the process continues on until no more information is exchanged between neighbors (self terminating) asynchronous: the nodes are not required to operate in lockstep with each other The least cost between x and y d(x,y) can be determined using the Bellman-Ford equation :\nd(x,y) = min_v {c(x,y) + d(v,y)}\n… to be continued\n4.5.3 Hierarchical Routing In practice it is not possible to have a network of interconnected routers running the same routing algorithm because of two reasons:\nScale if the number of routers is large, running LS or DV algorithms for the whole network becomes prohibitive for memory, processing, storing and timing costs. Administrative autonomoy an organization should be able to organize its network as it wishes, while still being able to connect its network to the outside world. Therefore routers are organized into autonomous systems (ASs), each of which being under the same administrative control. Routers in the same AS run the same routing algorithm and have information about each other. The routing algorithm running within an AS is called an intra-autonomous system routing protocol. In an AS, one or more routers will have the task of being responsible for forwarding packets outside the AS, these routers are called gateway routers. To obtain reachability information from neighboring ASs and propagating the reachability information to all routers interal to its AS, gateway routers use inter-AS routing protocols. Two communicating ASs must run the same inter-AS routing protocol.\nWhen a router needs to forward a packet outside its AS and there are multiple gateway routers, the router has to make a choice. One often employed practice is to use hot-potato routing: the AS gets rid of the packet as quickly as possible (as inexpensively as possible), the router sends the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination. An AS can decide what (internal) destinations to advertise to neighboring ASs: this a policy decision.\n4.6 Routing in the Internet 4.6.1 Intra-AS Routing in the Internet: RIP Intra-AS routing protocols are also known as interior gateway protocols. Historically two of these have been used extensively in the Internet: Routing Information Protocol (RIP) and Open Shortest Path First (OSPF).\nRIP was started for the Xerox Network Systems (XNS) architecture and was was widely deployed after being included in BSD. It is a distance-vector protocol working very similarly to what studied before. RIP uses hop count as a cost metric (each link has cost 1). Costs are from source router a destination subnet (not router-to-router as previously seen). hop = number of subnets traversed along the shortest path from source to destination subnet, including the destination subnet.\nRouting updates [messages] are exchanged between neighbors approximately every 30 seconds using a RIP response message, which contains a list of up to 25 destination subnets within the AS as well as the sender’s distance to each of those subnets. Response messages are also known as RIP advertisements. Each router maintains a RIP table known as a routing table which includes both the router’s distance vector and the router’s forwarding table. There are three columns in it: the destination subnet, the identity of next router along shortest path to reach destination and the number of hops to get to the destination along the shortest path.\nIf a router doesn’t hear from its neighbor for at least once every 180 seconds, that neighbor is considered to be no longer reachable (died or link down). Routers can also request information about its neighbor’s cost to a given destination using RIP’s request messages, which are transmitted over UDP using port 520. RIP is implemented in software but has access to the routing tables through the UNIX kernel.\n4.6.2 Intra-AS Routing in the Internet: OSPF OSPF and the related IS-IS are typically deployed in upper-tier ISPs whereas RIP is deployed in lower-tier ISPs and enterprise networks. Open indicates that the routing protocol speficication is publicly available. It was conceived as the successor to RIP. It is however a link state protocol that uses flooding of link-state information and a Dijkstra least-cost path algorithm: routers construct a complete topological map (graph) of the AS, then run Dijkstra’s algorithm to determine a shortest-path tree to all subnets with itself as the root node. Link costs are individually configured by the networks administrator who might choose to set all the link costs to 1, thus achieving minimum hop routuing or might choose to set the link weights to be inversely proportional to link capacity in order to discourage traffic from using low-bandwidth links. A router broadcasts routing information to all other routers in the AS, not just the neighbors. The broadcast happens whenever there is a change in a link’s state or every 30 minutes if the link’s state doesn’t change. OSPF advertisements are contained in OSPF messages that are carried by IP with an upper-lyerprotocol of 89 for OSPF, therefore OSPF must implement reliable message transfer and link-state broadcast; OSP also checks that links are operational using HELLO messages to attached neighbors. OSPF offers some services:\nsecurity: OSPF messages can be authenticated (not active by default). multiple same-cost paths: two paths having same cost can be used at the same time. integrated support for unicast and multicast routing support for hierarchy within a single routing domain: ability to structure an autonomous system hierarchically. A OSPF AS can be configured hierarchically into areas, each running its own OSPF algorithm, with each router broadcasting its link state to all other routers in that area. Area border routers are responsible for routing packets outside the area and one area is configured to be the backbone area, which routes traffic between other areas in the AS, it contains area border routers but also normal routers. 4.6.3 Inter-AS Routing: BGP The Border Gateway Protocol (BGP) is the de facto standard inter-AS routing protocol in today’s Internet. It provides each AS means to:\nobtain reachability information from neighboring ASs propagate reachability information to all internal routers determine good routes to subnets using reachability information and AS policy. it allows each subnet to advertise its existence to the rest of the Internet Basics It is a very complex algorithm. Routers exchange information over semipermanent TCP connections using port 179. There is typically one such BGP TCP connection for each link directly connecting two routers in two different ASs but there are also semipermanent TCP connections between routers in the same AS. For each connection, the two routers at the end of it are called BGP peers and the connection is called a BGP session. A session spanning two ASs is an external BGP (eBGP) session and BGP sessions between routers within an AS is called an internal BGP (iBGP) session. Destinations are not hosts, but CIDRized prefixes, each representing a subnet or collection of subnets.\nPath Attributes and BGP Routes In BGP an AS is identified by its globally unique AS number (ASN) which is assigned by ICANN regional registries. When a router advertises a prefix across a BGP session, it includes with the prefix a number of BGP attributes, a prefix with its attributes is called a route. Two other important attributes are:\nAS-PATH: contains the ASs through which the advertisement for the prefix has passed. When a prefix is passed into an AS, the AS adds its ASN to the AS-PATH. This attribute is used to detect and prevent looping advertisements (if router sees that its AS is already in AS-PATH, it rejects the ad) and to choose among multiple paths to the same prefix. -NEXT-HOP: the router interface that begins the AS-PATH. BGP also includes attributes allowing routers to assign preferences metrics to the routes and indicating how to prefix was inserted into BGP at the origins. When a router receives a route advertisement, it uses its import policy to decide whether to accept or filter the route and whether to set certain attributes such as the router preference metrics.\nBGP Route Selection The input of the selection is the set of all routes that have been learned and accepted by the router. If two or more routes exist for the same prefix, elimination rules are applied until only one remains.\nChapter 8: Security in Computer Networks 8.1 What is Network Security? Desirable properties of secure communication:\nConfindentiality: only sender and receiver should be able to understand the contents of the transmitted message -\u003e encryption Message integrity: make sure the content of the communication is not altered -\u003e checksum End-point authentication: sender and receiver should be able to confirm the identity of the other party involved in the communication. Operation security: ability to counter attacks to internal networks -\u003e firewalls, IPS, IDS Possible attacks:\neavesdropping: sniffing and recording messages flowing in a channel modification, inserion, deletion of messages or message content These two allow to mount many other types of attacks\n8.2 Principle of Cryptography See Information Science, BA2 ADDITION:\nBlock Ciphers Today there are two broad classes of symmetric encryption techniques: stream ciphers and block ciphers(used for PGP, SSL, IPssec) In a block cipher, the message to be encrypted is processed into blocks of k bis and each block is encrypted independently. To encode a bloc, the cipher uses a on-to-one mapping to map the k-bit block of cleartext to a k-bit block of ciphertext. To avoid bruteforce attacks, cipher blocks usually employ large blocks (k=64) but longer blocks implies longer tables to store the mappings. Block ciphers typically use functions that simulate randomly permuted tables. EX 64 bit input split into 8 8-bit chunks, each of which is processed by a 8-bit to 8-bit table, each chunk having its table. The encrypted chunks are reassembled into a 64 bits message which is fed again to the input. After n such cycles, the function provides a 64-bit block of ciphertext. The key for this block would be the eight permutation tables, assuming that the scramble function is publicly known. Popular block ciphers: DES (Data Encryption Standard), 3DES, AES (Advanced Encryption Standard). These use functions instead of predetermined tables. Each of them uses a string of bits for a key (64-bit blocks with 56-bit key in DES, 128-bits blocks and 128/192/256 bits-long keys)\nCipher-Block Chaining We need to avoid long messages avoiding that two or more identical ciphertexts (produced for identical cleartexts by a symmetric encryption). (I DON’T FINISH THIS PART, IT GOES TOO DEEP INTO ENCRYPTION TECHNIQUES WHICH IS NOT WHAT WE ARE INTERESTED IN)\n8.3 Message Integrity and Digital Signatures We want to provide message integrity (aka message authentication). Message integrity is verified when:\nThe message received indeed originated from the sender The message was not tampered with on its way to the receiver 8.3.1 Cryptographic Hash Functions A hash function takes an input m and computes a fixed length size string H(m) known as a hash. A cryptographic hash function is required to have an additional property:\nit is computationally infeasible to find any two different messages x and y such that H(x) = H(y) Some used cryptographic hashing functions are md5, SHA…\n8.3.2 Message Authentication Code To perform message integrity we also need a shared secret s, called the authentication key. The procedure is then:\nAlice creates message m, concatenates m+s and computes the hash H(m+s) to create the message authentication code (MAC) Alice appends the MAC to the message m creating (m+H(m+s)) Bob receives the message and knowing the hash function and the secret, computes the hash. He creates H(m+s) and compares it with what he received. MAC is nice because it doesn’t require any encryption algorithm The most popular standard of mac today is HMAC which can be used with either MD5 or SHA-1. The problem then is: how to distribute the secret? Physically?\n8.3.3 Digital Signatures A digital signature is a cryptographic technique to indicate the owner or creator of a document or to signify one’s agreement with a document’s content. Just as with handwritten signatures, digital signatures should be created in a way that they are verifiable (prove that the the author of a signature is indeed the author) and nonforgeable** (prove that only that individual could have signed the document). We can use the public and private keys we already created for asymmetric confidentiality. To sign a message m Bob can encrypt the message with the private key (only the matching public key will be able to decrypt). However encryption and decryption and computationally expensive therefore:\nBob computes the hash of the message Bob uses his private key to encrypt the hash Bob contants the encrypted hash and the message Alice can decrypt, find the hash, compute a hash herself check for identity We saw that both digital signatures and MACs involve using a hash function but digital signatures, requiring encryption, need heavier operations and also need a Public Key infrastructure (PKI) with certification authorities.\nPublic Key Certification An important application of digital signatures is public key certification, that is, certifying that a public key belongs to a specific entity. It is used in IPsec and SSL. A Certification Authority binds a public key to a particular entity. It has the follow roles:\nA CA verifies that an entity (person, router, …) is who it says it is. The method depends on the authority The CA creates a cerificate that binds the public key of the entity to the identity. The certificate contains the public key and globally unique identifying information about the owner of the public key. The certificate is digitally signed by the CA 8.4 End-Point Authentication End-point authentication is the process of one entity proving its identity to another entity over a computer network. Authentication must be done solely on the basis of messages and data exchanged as part of an authentication protocol. Typically this would run before the two communicating parties run some other protocol.\nWe can analyze authentication developing a simple algorithm step by step:\nVersion 1.0 Alice simply sends a message to Bob saying “I’m Alice”\nVersion 2.0 Alice and Bob always communicate using the same addresses. Bob can simply check that the message has the source IP of Alice. However is fairly easy to spoof an IP address: crafting a special datagram is feasible using a custom kernel e.g Linux.\nVersion 3.0 Alice and Bob could share a secret password, a secrete between the authenticator and the person being authenticated. Alice: I’m Alice, Password. However password can be eavesdropped, sniffed (read and stored).\nVersion 3.1 We could encrypt the password using a shared symmetric cryptographic key. However this protocol is subject to playback attacks an eavesdropper could sniff the encrypted secret and, without having to decrypt, could send it to impersonate Alice.\nVersion 4.0 To avoid playback attacks we could use the same principle behind TCP’s three way handshake. A nonce is a number that a protocol will use only once in a lifetime. The procedure is then:\nAlice sends: I am Alice bob chooses a nonce and sends it to Alice Alice encrypts it using Alice and Bob’s symmetric secret key and sends the encrypted nonce. Bob decrypts the received nonce and checks for equality with the one he generated. 8.5 Securing e-mail Security functionalities are provided by many layers of the network stack. Why? There is a need for security at higher layers as well as blanket coverage at lower layers and it easier to provide security at higher layers.\n8.5.1 Secure E-Mail What features do we want? Confindentiality, Sender authentication, Receiver authentication.\nConfidentiality: to overcome the problem of sharing a symmetric secret, Alice and Bob use asymmetric cryptography. Bob makes his public key publicly available (key server or web page) and Alice encrypts her message with Bob’s public key. Bob can decrypt using his private key. However asymmetric crypto is quite inefficient. A session key can be used: Alice selects a random symmetric key. She uses it to encrypt the message. She the encrypts this key using Bob’s public key and concatenates the symmetricly encrypted message and the asymmetricly encrypted key. Sender authentication and message integrity: we suppose that Alice and Bob don’t care for confidentiality. They will use digital signatures and message digests. Alice applies a hash function H to her message m, obtain a message digest, signs the digest with her private key to create a digital signature, concatenates the original message with the signature to create a package and sends the package to Bob’s e-mail address. Bob uses Alice’s public key to the digest and compares the result fo this operation with his own hash H of the message. Confidentiality, sender authentication and message integrity: the two procedures above can be combined, message and digest are concatenated and the treated as a new message which is encrypted using the first technique. These techniques suppose however that Alice and Bob are able to exchange their public keys. An intruder could in fact send a public key to Bob pretending to be Alice. Certification is needed.\nPhil Zimmermann and PGP PZ was the creator of PGP. For that he was legally attacked by the US Government, he distributed PGP while it should have stayed a secret weapon in the heads of the defense. The US dropped the case and PGP became the most widely used e-mail encryption software in the world despite the lack of funding, paid staff.\n8.5.2 PGP Pretty Good Privacy (PGP) is an e-mail encryption scheme that has become the De Facto standard. It uses the same design shown above, giving the option of signing, encrypting or both. When PGP is installed, it creates a public key pair for the user, the public key can be posted online while the private key is protected by a password which has to be entered every time the user accesses the private key. A PGP message appears after the MIME header. PGP also provides a mechanism for public key certification. PGP public keys are certified by Web of Trust: Alice can certify any key/username pair when she believes the pair really belong together and, in addition, PGP permits Alice to say that she trusts another user to vouch for the authenticity of more keys. Some PGP users sign each other’s key by holding key-signing parties.\n8.6 Securing TCP Connections: SSL We now move to the transport layer. The enhanced version of TCP is called Secure Socket Layer (SSL), a slightly modified version of SSL v3 called Transport Layer Security (TLS) has been standardized by the IETF. Originally developed by Netscape, SSL has enjoyed broad deployment since its origins, providing secure communication between all recent browsers and online services. SSL provides TCP with confidentiality, data integrity, server authentication and client authentication. SSL is often used over HTTP, however, as it secures TCP, it can be employed by any application that runs over TCP. SSL provides a simple Application Programming Interface with sockets, similar to TCP’s API. When an application wants to use SSL, it must include SSL classes/libraries. Technically SSL resides in the application layer but from the developer’s perspective it is a transport layer protocol that provides TCP’s services enhanced with security services.\n8.6.1 The Big Picture (primitive almost-SSL) Three phases:\nHandshake: Bob initiates a TCP connection is established (TCP SYN, SYNACK, ACK). Bob sends SSL Hello, Alice responds with her certificate containing her public key (the certificate being certified by a CA, Bob is sure that the key belongs to Alice). Bob generates a master secrect (MS), encrypts it with Alice’s public key to create the Encrypted Master Secret (EMS) and sends it to Alice who will decrypt it with her private key to get the MS which can be used for confidentiality and integrity as seen before. Key Derivation instead of using the MS for integrity and confidentiality, it is safer to use different keys for different functions. Therefore both Alice and Bob use the MS to generate: Eb = session encryption key for data Bob -\u003e Alice Mb = session MAC key for data Bob -\u003e Alice Ea = session encryption key for data Alice -\u003e Bob Ma = session MAC key for data Alice -\u003e Bob The MS could simply be split in four chunks, but real SSL does it differently. Data Transfer TCP is a byte-stream protocol, so where would we put the MAC for the integrity check? SSL breaks the data stream into records, appends a MAC to each record and then encrypts record+MAC. However, in a MITM attack, the order of packets could be reversed as TCP sequence numbers are not encrypted. SSL therefore uses sequence numbers. Bob keeps a sequence number counter which begins at zero and is incremented at each record transmission. He includesthe sequence number in the MAC calculation: MAC = hash(data+Mb+SeqNum). Alice tracks Bob’s sequence numbers so that she can verify the MAC. SSL Record The real SSL record:\nType: handshake message, data message, connection teardown message Length: used to extract the records out of the TCP byte stream 8.6.2 A More Complete Picture SSL allows Alice and Bob to agree on the cryptographic algorithms at the beginning of the SSL session, during handshake. Steps:\nThe client sends a list of cryptographic algorithms it supports, along with a client nonce The server chooses a symmetric algorithm (ex: AES), a public key algorithm (ex RSA) and a MAC algorithm. It sends back to the client its choices as well as a certificate and a server nonce. The client verifies the certificate, extracts the server’s public key, generates a Pre-Master Secret (PMS), encrypts it with the server’s public key and sends the encrypted PMS to server. Using the same key derivation function (specified by SSL standard), client and server independently compute the Master Secret (MS) from the PMS and the nonces. The MS is sliced up to create the two encryption and the two MAC keys. Furthemore when the symmetric cipher employs CBC (ex 3DES or AES) the two Initialization Vectors (IVs), one for each side of the connection, are also obtained from hte MS. Henceforth all messages sent between client and server are encrypted and authenticated (using MAC) The client sends a MAC of all the handshake messages The server sends a MAC of the handshake messages. 5 and 6 protect the handshake from tampering: if in the end MAC are not coherent with the previously sent messages, the connection is stopped. (prevents an attacker from impersonating the server and imposing weak algorithms). Nonces are used to avoid connection replay attacks (resending packets sniffed during a previous connection again, using nonces allows to have different MACs and therefore messages at each connection, even if the content of the communication is the same).\nConnection Closure TCP FIN segments can be crafted by an attacker (truncation attack), therefore they cannot be used. The type field of SSL records is used for these purpose, even if it sent in the clear, it is authenticated at the receivers using record’s MAC.\n8.7 Network-Layer Security: IPsec and Virtual Private Networks The IP security protocol is called IPsec, it secures IP datagrams between any two network-layer entities (host, routers)\n8.7.1 IPsec and Virtual Private Networks (VPNs) An institution extending overt multiple geographical regions might want its own IP network so that the machines in it can communicate securely. Such a disjoint network is a private network. A physical private network can be expensive. VPN can be used to deploy and maintain a private network over the existing public Internet. The traffic is sent over the Internet but encrypted before entering the public net. Not all traffic sent into the Internet by the gateway routers or laptops will be IPsec secured (only the portion accessing internal resources)\n8.7.2 The AH and ESP Protocols In the IPsec protocol suite, there are two principal protocols: the Authentication Header (AH) protocol and the Encapsulation Security Payload (ESP) protocol. When a source IPsec entity (router or host) sends secure datagrams to a destination entity it does so with either ESP or AH. AH provides source authentication and data integrity while ESP provides source authentication, data integrity and confidentiality. Because the latter is often critical for VPNs, ESP is much more widely used AH. We will only study ESP.\n8.7.3 Security Associations Before sending IPsec datagrams from source entity to destination entity, source and destination create a network-layer logical connection called security association (SA). SA is a simplex (unidirectional from source to destination) logical connection. If both entities want to send datagrams to each other, then two SAs need to be established, one in each direction. The VPN server (headquarters gateway router) will maintain state information about the SA, which will include:\n32-bit identifier for the SA, called Security Parameter Index (SPI) The origin interface (client outside) of the SA and its destination (its out facing interface) [IP addresses] Type of the encryption used Encryption key Type of the integrity check Authentication key An IPsec entity often maintains state information for many SAs (all outside clients) using its Security Association Database (SAD) which is a data structure in the entity’s OS kernel.\n8.7.4 The IPsec Datagram IPsec has two different packet forms, one for tunnel mode and one for transport mode, the first one, being more appropriate for VPNs, is more widely deployed than the transport mode, we will therefore only focus on it.\nThe headquarters’s gateway receives an IPv4 datagram from inside the network directed to a VPN client outside. Here is what happens:\nIt appends to the back of the original datagram (which includes the original header fields) in the ESP trailer field It encrypts the result using the algorithm and key specified in the SA Appends to the front of the result a ESP Header creating the “enchilada” Creates an authentication MAC over the whole enchilada using algorithm and key specified in the SA Appends the MAC to the back of the enchilada forming the payload Creates a brand new IP header with all the classic IPv4 header fields which it appends before the payload. The protocol number field is set to 50, designating IPsec. The routers along the path will treat the datagram as a normal one, oblivious that it is an IPsec datagram. To decide whether outgoing packets should be treated as above or simply let through, the gateway maintains a Security Policy Database (SPD) which indicates what types of datagrams (as a function of the source and destination IPs and of the protocol) are to be IPsec processed and, for those that are, which SA should be used. IPsec provides confidentiality, source authentication, data integrity, replay-attack prevention.\n8.7.5 IKE: Key Management in IPsec Who/What should populate the SAD? For small VPNs this can be done manually. For larger ones there is the Internet Key Exchange (IKE) protocol. IKE is similar to the handshake in SSL. Here are the steps:\nDuring the first exchange of messages, the two sides use Diffie-Hellman to create a Bi-Directional IKE SA between the routers, which is entirely different form the IPsec SA discussed above. This IKESA provides an authenticated and encrypted channel between the two routers. Keys are established for encryption and authentication for IKESA. Also established is a master secret. During the second exchange of messages, both sides reveal their identity to each other by signing their messages. However the identities are not revealed to an eventual sniffer, since the messages are sent over the IKE sa channel. The two sides also negotiate the IPsec encryption and authentication algorithms to be employed by the IPsec SA. Finally the two sides create an SA n each direction. We have two phases to reduce computational costs: we don’t need asymmetric cryptography during second phase, allowing IKE to generate many SAs with relatively little computational cost.\n8.9 Operational Security: Firewalls and Intrusion Detection Systems 8.9.1 Firewalls A firewall is a combination of hardware and software that isolates an organization’s internal network from the Internet at large, allowing some packets to pass and blocking others. It has three goals\nAll traffic from outside to inside, and vice versa, passes through the firewall Only authorized traffic, as defined by the local security by the local policy, will be allowed to pass. The firewall itself is immune to penetration Firewalls can be classified in three categories:\n1: Traditional Packet Filters Packet filters examine each datagram in isolation determining whether the datagram should be allowed to pass or should be dropped based on administrator-specific rules. Filtering decisions can be based on IP source/destination, protocol type, TCP/UDP, TCP flags/ ICMP message type, rules for leaving/entering, rules for different router interfaces. The parameters are based on the policy of the organization taking account of user productivity and bandwidth usage as well as security concerns.\n2: Stateful Packet Filters Decisions are made on each packet in isolation. Stateful filters track TCP connecions and use this knowledge to make filtering decisions.\n3: Application Gateways Application Gateways look beyond the IP/TCP/UDP headers and make policy decisions based on application data. An Application Gateway is an application-specific server through which all application data must pass. Multiple AG can run on the same host, but each gateway is a separate server with its own processes.\n8.9.2 Intrusion Detection Systems An intrusion detection system (IDS) is a device that alerts when it observes potentially malicious traffic. An intrusion prevention system (IPS) is a device that filters out suspicious traffic. Both types of device perform deep packet inspection: they look beyond the header fields and into the actual application data that the packets carry.\nAn IDS can detect a wide range of attacks, including network mapping, port scans, TCP stack scans, DoS, worms, viruses, OS vulnerability attacks and application vulnerability attacks. An organization can deploy one more IDS sensors in its network. When many are used, they work together, usually coordinated by a central server. More than one is often a good solution as each one compare each passing packet with tens of thousands of signatures. They are usually classified as either signature-based systems or anomaly-based systems. A signature based IDS maintains an extensive database of attack signature, each of which being a set of rules pertaining to an intrusion activity. A signature can be a list of packet characteristics or may relate to a series of packets. They are created by network security engineers researching attacks. The ids sniffs every packet passing by it, comparing it with signatures. Signature based IDS, although widely deployed, have a number of limitations: they require a previous knowledge of the attack to generate an accurate signature, false alarms may be generated, they can be slow and fail to detect attacks if overwhelmed. Anomaly-based packets study normal traffic and looks for statistically unusual events. They don’t rely on previous knowledge of attacks.\nChapter 5: The Link Layer: Links, Access Networks and LANs 5.1 Introduction to the Link Layer Some terminology:\nnode = any device running a link-layer protocol (hosts, routers, switches…) link = communication channels connecting adjacent nodes along the path. Over a given link, a transmitting node encapsulates the datagram in a link-layer frame and transmits the frame into the link. 5.1.1 The Services Provided by The Link Layer Possible services offered by a link-layer protocol include:\nFraming: all link layer protocols encapsulate each network layer datagram within a link-layer frame before transmission. A frame consists of a data field, containing the datagram, and a number of header fields, whose structure is determined by the protocol. Link access: A Medium Access Control (MAC) protocol specifies the rules by which a frame is transmitted onto the link. Reliable delivery: the protocol guarantees to move each datagram across the link without loss or errors. A reliable delivery protocol is often used for links highly prone to errors (WiFi) so that the error can be corrected locally, where it happens, rather than forcing an end-to-end retransmission. However it can represent a significant overhead for low bit-error links (cable) and therefore many wired link-layer protocols do not provide a reliable delivery service. Error detection and correction: signal attenuation and electromagnetic noise can introduce errors. Because there is no need to forward a datagram that has an error, may link-layer protocols provide a mechanism to detect such bit errors so that they can drop the frames. This can be accomplished transmitting error-detection bits in the frame. Link layer error detection is usually more sophisticated and implemented in hardware. 5.1.2 Where Is the Link Layer Implemented? In routers, the link layer is implemented in the line card. Is a host’s link layer implemented in hardware or software? For the most part, the link layer is implemented in a network adapter, sometimes known as network interface card (NIC). At the heart of the NIC is the link-layer controller, usually a single, special purpose chip that implements many of the link-layer services. Thus, much of a link-layer controller’s functionality is implemented in hardware. Part of the link layer is implemented in software that runs on the host’s CPU, this part implement higher-level functionalities. Link-Layer is a combination of hardware and software, the place in the protocol stack where software meets hardware.\n5.2 Error-Detection and -Correction Techniques Error detection and correction allow the receiver to sometimes, but not always, detect that bit errors have occurred. Even with the use of error-detection bits, there still may be undetected bit errors (the receiver is unaware of the presence of corrupted bits). We want to keep the probability of such an event small. Let’s now consider three techniques for detecting errors in the transmitted data: parity checks, checksumming methods and cyclic redundancy checks\n5.2.1 Parity Checks Perhaps the simplest form of error detection is the use of a single parity bit. Suppose that the information to be sent, D, has d bits. In an even parity scheme, the sender simply includes one additional bit and chooses its value such that the total number of 1s in the d+1 bits (original + parity bit) is even. (odd parity scheme, parity bit to one if #1s % 2 != 0). The receiver only needs to count the number of 1s in the d+1 bits. If an odd number of 1 valued bits are found with an even parity scheme, the receiver knows that some odd number of bit error has occurred. If an even number of bit errors occur, this would result in an undetected error. Another approach is to use a two dimensional even parity: the d bits are divided into i rows and j columns. A parity value is computed for each row and for each column. The result i + j + 1 parity bits comprise the error-detection bits. A single bit error in the original d bits will cause the parity of both the column and the row containing the flipped bit to to be in error. The receiver can not only detect the error, but also use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted and correct the error. This technique also allows to detect an error in the parity bits. The ability of the receiver to both detect and correct errors is known as forward error correction (FEC)\n5.2.2 Checksumming Methods The d bits of data are treated as a sequence of k-bit integers for example the Internet checksum already studied: bytes of data are treated as integers and summed, the 1s complement of this sum forms the Internet checksum carried in the header. The receiver checks the checksum by taking the 1s complement of the sum of the received data (including checksum) and checking whether the result is all 1 bits, if there are any 0, an error is indicated. In TCP and UDP the checksum is computed over all fields (header and data). Checksumming methods require little packet overhead but they provide relatively weak protection against errors. Why is checksumming used in transport layer and cyclic redundancy check used at the link layer? Transport layer is implemented in software (OS) and therefore needs a simple and fast error detection scheme while error detection at link layer is implemented in hardware which can perform the more complex CRC operations.\n5.2.3 Cyclic Redundancy Check (CRC) Cyclic Redundancy Check (CRC) codes are also known as polynomial codes since it is possible to view the string to be sent as a polynomial whose coefficients are the 0 and 1 values in the bit string with operation interpreted as polynomial arithmetic. Sender and receiver must agree on a r+1 bit pattern know as generator which we’ll denote as G. We require the leftmost bit of G to be a 1. For a given piece of data D the sender will choose r additional bits, R, and append them to D such that the resulting d + r bit pattern, interpreted as a binary number, is exactly divisible by G using modulo-2 arithmetic. Checking is therefore easy: the receiver divides the d + r received by bits by G, if the remainder is nonzero, an error has occurred, otherwise the data is accepted as being correct. All CRC calculations are done in modulo 2 without carries in addition or borrows in subtraction (+ = - = xor).\n5.3 Multiple Access Links and Protocols There are two types of network links: point-to-point and broadcast links. A point-to-point link consists of a single sender at one end of the link and a single receiver at the other end of the link. A broadcast link can have multiple sending and receiving nodes all connected to the same, single, shared broadcast channel. The term broadcast is used because when any node transmits a frame, the channel broadcasts the frame and each other node receives a copy (ex: ethernet, wireless).\nThe multiple access problem: How to coordinate the access of multiple sending and receiving nodes to a shared broadcast channel? Computer networks have multiple access protocols by which nodes regulate their transmission into the shared broadcast channel. More than two nodes can transmit frames at the same time, which will result in all of the nodes receiving multiple frames at the same time: the frames collide at all of the receivers. Typically in case of collision, none of the receiving nodes can make any sense of any of the frames, they become inextricably tangled together and are therefore lost, the channel being wasted during collision. Thus it is necessary to coordinate the transmission of the active nodes. We can classify multiple access protocols in three categories: channel partitioning protocols, random access protocols, taking-turns protocols.\n5.3.1 Channel Partitioning Protocols TDM and FDM (from circuit switching) are in this category. A third channel partitioning tool is code division multiple access (CDMA) which assigns a different code to each node. Each node then uses its unique code to encode the data bits it sends. If the codes are chosen carefully, then all nodes can transmit simultaneously and yet have their respective receivers correctly receive a sender’s encoded data bits. Originally used in military systems, it’s now widely used for civilian use, particularly in cellular telephony.\n5.3.2 Random Access Protocols A transmitting node always transmits at the full rate of the channel, R bps. When there is a collision, each node involved in the collision repeatedly retransmits its frame until the frame gets through without a collision. But when a node experiences a collision, it waits a random dely before retransmitting the frame. The delay is chosen independently. Here a few of the most commonly used random access protocols:\nSlotted ALOHA All frames consist of L bits, time is divided into slots of size L/R seconds, nodes start to transmit frames only at the beginning of slots. Moreover nodes are synchronized so that each node when the slot begins. If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.\nIf p is a probability then the operation of slotted ALOHA in each node is simple:\neach node waits the beginning of the next slot to transmit the entire frame in a slot If no collision occurs, the frame is considered delivered If collision, this is detect before the end of the slot. The node retransmits its frame in each subsequent slot with probability p (probability of retransmission) until the frame is transmitted without a collision. Slotted ALOHA allows transmission at full rate R, is highly decentralized, and is extremely simple. The computed maximal efficiency (successfully used slots in transmission / total slots) of Slotted ALOHA) is 37% thus the effective transmission rate is 0.37R bps.\nAloha all nodes synchronize their transmissions to start at the beginning of a slot. The node immediately transmits a frame in its entirety in the channel. In case of collision, the node will then immediately retransmit the frame with probability p otherwise the node waits for a frame transmission time, after which it transmits the frame with probability p or wait for another frame with probability 1-p. The maximum efficiency is 1/(2e) but the protocol is fully decentralized.\nCarrier Sense Multiple Access (CSMA) CSMA and CSMA/CD (collision detection) embody two rules:\ncarrier sensing: if a node is transmitting, the others wait until they detect no transmission for a short amount of time and begin transmission. collision detection: a transmitting node listens to the channel while it’s transmitting, if it detects that another node is transmitting, it stops transmitting and waits for a random amount of time before repeating the sense-and-transmit-when-idle-cycle. It is evident that the propagation delay of the channel plays a crucial role: the longer, the larger the chance that a carrier sensing node is not yet able to sense a transmission that has already begun.\nCarrier Sense Multiple Access with Collision Detection (CSMA/CD) When a node detects a collision, it ceases transmission immediately in Collision Detection. A link layer frame is prepared, if the node senses that the channel is idle (no energy is entering the adapter from the channel), it starts to transmit the frame, else it waits until it detects idle. While transmitting, the node monitors the channel for usage from other nodes, if the entire frame is transmitted without detecting usage, then the adapter is finished. If energy is detected from other adapters while transmitting, the node aborts transmission (stops), waits for a random amount of time and then returns to checking for idle.\nThe wait for random amount of time is required in order to avoid the nodes to keep colliding.\nCSMA/CD Efficiency Is the long run fraction of time during which frames are being transmitted without collision. If the propagation delay approaches 0, the efficiency approaches 1. Also if the propagation delay becomes very large, efficiency approaches 1.\n5.3.3 Taking-Turns Protocols There are a lot of them, we’ll cover two of the more important, the first one being the polling protocol. It requires one of the nodes to be designated as a master node which polls each of the nodes in a round-robin fashion. The master tells node 1 that it can transmit up to some maximum number of frames, when node 1 is finished (the master checks for energy in the channel) the master tells the same to node 2 and so on. The polling protocol eliminates the collisions and empty slots that plague random access protocols, resulting in a much higher efficiency. However it introduces a polling delay (the amount of time required to notify a node that it can transmit) [if only one is transmitting, it will have to wait for the master to poll all the others]. Moreover the master node represents a single point of failure.\nThe second protocol is the token-passing protocol in which there is no master method. A small, special purpose frame known as token is exchanged among the nodes in some fixed order. When a node receives a toke, it holds it only if it has some frames to transmit otherwise it immediately forwards it to the next node.If a node has frames to transmit when it receives the token, it sends up to a maximum number of frames and then passes the token. Token passing is decentralized and highly efficient but the failure of one node could crash the entire channel, or a node could neglect to release the token….\n5.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access The Data-Over-Cable-Service-Interface-Specifications specifies the cable data network architecture and its protocols. DOCSIS uses FDM to divide the downstream and upstream network segments into multiple frequency channels. Each upstream and downstream channel is a broadcast channel. Several cable modems share the same upstream channel (frequency) to the CMTS and thus collision can potentially occur. Each upstream channel is divided into intervals of time (TDM-like) each containing a sequence of mini-slots during which cable modems can transmit to the CMTS, which explicitly grants permission to individual modems to transmit during specific mini-slots. This is done sending a special control message known as a MAP message on a downstream channel to specify which cable modem can transmit during which mini-slot. Modems send mini-slot-request frames to the CMTS during a special set of interval mini-slots dedicated for this purpose. The requests are transmitted in a random access manner and may collide with each other. The modem cannot detect activity nor collisions: it simply infers that its request experienced collision if it does not receive a response in the next downstream control message. When a collision is inferred, a modem uses binary exponential backoff to defer the transmission to a future slot.\n5.4 Switched Local Area Networks Switched local networks connect hosts using link-layer switches which do not run networks-layer protocols.\n5.4.1 Link-Layer Addressing and ARP MAC Addresses Network interfaces in hosts and routers have link-layer addresses, however link-layer switches do not have link-layer addresses associated with their interfaces so that they can carry datagrams without having routers or hosts having to explicitly address the frame to the intervening switch. A link-layer address is called LAN address, physical address or MAC address, the last name being the most popular. This address is 6 bytes long, typically expressed in hexadecimal notation. They are supposed to be permanent but can be changed via software. No two adapters have the same address: the IEEE manages the MAC address space, usually assigning a 24 prefix to each manufacturer and letting him choose the content of the remaining 24 bits. MAC address have a flat structure (no hierarchy such as in IP) and do not change. When an adapter wants to send a frame to some destination adapter, it inserts the destination adapter’s MAC address into the frame and then sends the frame into the LAN. An adapter might receive a frame that isn’t addressed to it, when this happens, the adapter checks whether the frame’s destination address matches its own, if not it discards the frame. When a sending adapter want to broadcast to the whole network, it inserts a special MAC broadcast address into the destination address field, for 6bytes addresses that is FF-FF-FF-FF-FF-FF\nAddress Resolution Protocol (ARP) The Address Resolution Protocol (ARP) translates network-layer addresses into link-layer addresses, analogously to DNS, but ARP resolves IP addresses only for hosts and router interfaces on the same subnet. Each host and router has an ARP table which contain mappings of IP addresses to MAC addresses and a time-to-live TTL value which indicates when each mapping will be deleted from the table. A typical TTL is 20 minutes from when an entry is placed in the ARP table. The table does not necessarily contain an entry for every host and router on the subnet. What if a frame has to be sent to an address which does not appear in the table? The sender creates a special packet, an ARP packet, containing the sending and receiving IP and MAC addresses. Both ARP query and response have the same format: the sending forwards the ARP request to the broadcast address (destination address) the frame containing the query is received by all the other adapters in the subnet. Each adapter passes the frame to the ARP module which checks if its IP address matches the destination IP address in the query. The one with a match sends back the response with the desired mapping. The querying can update its table and send the IP datagram encapsulated in a link-layer frame. ARP is plug and play: the table gets build automatically. ARP stands in the boundary between the link and network layers.\nSending a Datagram off the Subnet A datagram that has to be sent out of the subnet is first sent to the first-hop router on the path to the final destination (which is outside the subnet). How is its MAC acquired? Using ARP. When the frame reaches the next-hop router of the destination subnet, it has to be moved inside, the router having to decide what interface to use. This is done using the forwarding table: the router extracts the datagram and checks the destination IP. The datagram is encapsulated again and sent into the subnet, this time the MAC address of the frame is indeed the destination MAC address of the ultimate destination, which the router acquire via ARP.\n5.4.2 Ethernet It has pretty much taken over the wired LAN market. Since its invention in the 70’s, it has grown and become faster. At the beginning the original Ethernet LAN used a coaxial bus to interconnect the nodes, creating a broadcast LAN. By the late 90s, most companies and universities had replaces their LANs with Ethernet installation using a hub-based star topology: hosts and routers are directly connected to a hub with twisted-pair copper wire. A hub is a physical layer device that acts on individual bits rather than frames. When a hub receives a bit, it simply recreates it boosting its energy strength and transmits the bit onto all the other interfaces (it’s still a broadcast LAN). In the early 2000s, the star topology evolved: the hub was replaced with a switch, allowing a collision-less LAN.\nEthernet Frame Structure Data fields (46 to 1,500 bytes): carries the IP datagram (or other network-layer datagram). The MTU (maximum transmission unit) is 1500 bytes, compensated with fragmentation. The minimum is 46, is less, the data is “stuffed” and the receiving network layer uses the length field to eliminate the stuffing Destination address (6 bytes) destination MAC address. Source address (6 bytes) Type field (2 bytes) allows to multiplex network layer protocols (if not only IP is used, also ARP has its own type number 0x0806) Cyclic redundant check (CRC) (4 bytes): used for bit error detection Preamble (8 bytes): the first seven have value 10101010, the last has value 10101011. The first seven serve as “wake up” the receiving side and to synchronize their clocks to that of the sender’s clock the two 1s at the end of byte 8 alerts the receiver that the important stuff is about to come. All of the Ethernet technologies provide connectionless service (no handshaking, similar to UDP) and unrealiable service to the network layer (no ACK, drop in case of errors) which help to make Ethernet simple and cheap. If there are gaps due to discarded Ethernet frames, the fact that the application sees the gaps or not depends on the transport layer protocol used: not with TCP (reliable data transfer), yes with UDP.\nEthernet Technologies There are many variants and flavors of Ethernet which have been standardized over the years by the IEEE. They vary in speed: 10 Megabit, 100 Megabit, 1000 Megabit, 10 Gigabit… They can also vary in the type of traffic they can transport….\n5.4.3 Link-Layer Switches Switch receive and forward frames. They are transparent: adapters address each other, without knowing that the switch is sitting in the middle. As they’re output rate might be smaller than the input rate, they also have buffers to queue frames.\nForwarding and Filtering Filtering is the switch function that determines whether a frame should be forwarded to some interface or should just be dropped. Forwarding is the switch function that the determines the interfaces to which a frame should be directed and then moves the frame to those interfaces. Switch filtering and forwarding are done with a switch table which contains entries for some (not necessarily all) of the hosts and routers on a LAN. Each entry contains: (MAC address, interface leading toward that MAC, time at which the entry was placed in the table) Switches forward frames based on the MAC addresses rather than on IP addresses.\nWhen a switch receives a frame:\nThere is no entry in the table associated with the destination address -\u003e the packet is broadcast through all the interfaces (except the one through which the frame was received) There is an entry in the table that point to the same interface through which the frame was received -\u003e The frame is discarded (filtering) There is an entry in the table that point to an interface different from the one through which the frame was received -\u003e the frame is put in the output buffer preceding the interface discovered thanks to the table (forwarding) Self-Learning The switch table is build automatically, dynamically and autonomously without any intervention from a network administrator: switches are self learning.\nThe switch table is initially empty For each incoming frame, the switch stores in its table the MAC address in the frame’s source address field the interface from which the frame arrived the current time The switch deletes an address in the table if no frame are received with that address as the source after some period (aging time) so that to eliminate unused entries from the table Thus switches are plug-and-play devices: they require no human intervention. Switches are also full-duplex, meaning any interface can send and receive at the same time.\nProperties of Link-Layer Switching Advantages over buses or hubs:\nElimination of collisions: the switch buffers frames and never transmit more than one frame on a segment at any one time. The maximum aggregated throughput is the sum of all the switch interface rates Heterogeneous links: The switch providing isolation, different links can operate at different speeds and run over different media. Therefore switches are ideal for mixing legacy equipment with new equipment. Management: A switch can disconnect a malfunctioning adapter and a cut cable isolates only one host. Switches can gather statistics useful for debugging and planning the evolution of the network. Switches Versus Routers They are both packet switches but switches are layer-2 packet switches while routers are layer-3 packet switches. Switches are plug-and-play, have relatively high filtering and forwarding rates. However to prevent the cycling of broadcast frames, the active topology of a swtiched network is restricted to a spanning tree. A large network requires large ARP tables in hosts and routers and would generate substantial ARP traffic and processing. Switches are also susceptible to broadcast storms: if one goes crazy and send an endless stream of broadcast frames, the others will forward all of the frames resulting in a network collapse. Routers network addressing is hierarchical, packets do not normally cycle and the topology is not limited to a spanning tree even when the network has redundant paths. Therefore packets can use the best path between source and destination. But routers are not plug-and-play (a host need the IP to connect) and often have a larger per-packet processing time than switches. Finally two pronunciation cause a lot of disputes.\nPDF Note👇 ","wordCount":"27760","inLanguage":"en","image":"https://samirpaul1.github.io/blog/assets/img/computer-networks-preview-blog-banner.webp","datePublished":"2022-10-04T15:58:26+08:00","dateModified":"2022-03-04T15:58:26+08:00","author":{"@type":"Person","name":"Samir Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://samirpaul1.github.io/blog/posts/computer-networks-notes/"},"publisher":{"@type":"Organization","name":"Blog - Samir Paul","logo":{"@type":"ImageObject","url":"https://samirpaul1.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://samirpaul1.github.io/blog/ accesskey=h title="Blog - Samir Paul (Alt + H)">Blog - Samir Paul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://samirpaul1.github.io/blog/archives title=Archive><span>Archive</span></a></li><li><a href=https://samirpaul1.github.io/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://samirpaul1.github.io/blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://samirpaul1.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://samirpaul1.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Computer Networks Notes</h1><div class=post-description>Computer Networks Notes</div><div class=post-meta><span title='2022-10-04 15:58:26 +0800 +0800'>October 4, 2022</span>&nbsp;·&nbsp;131 min&nbsp;·&nbsp;27760 words&nbsp;·&nbsp;Samir Paul&nbsp;|&nbsp;<a href="https://twitter.com/intent/follow?screen_name=SamirPaulb" rel="noopener noreferrer" target=_blank>Contact Author</a></div></header><figure class=entry-cover><img loading=lazy src=https://samirpaul1.github.io/blog/assets/img/computer-networks-preview-blog-banner.webp alt="Computer Networks Notes"><p>Computer Networks Notes</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#chapter-1-computer-networks-and-the-internet aria-label="Chapter 1: Computer Networks and the Internet">Chapter 1: Computer Networks and the Internet</a><ul><li><a href=#11-what-is-the-internet aria-label="1.1 What is the Internet?">1.1 What is the Internet?</a><ul><li><a href=#111-a-nuts-and-bolts-description aria-label="1.1.1 A nuts-and-bolts description">1.1.1 A nuts-and-bolts description</a></li><li><a href=#112-a-services-description aria-label="1.1.2 A Services Description">1.1.2 A Services Description</a></li><li><a href=#113-what-is-a-protocol aria-label="1.1.3 What Is a Protocol?">1.1.3 What Is a Protocol?</a></li></ul></li><li><a href=#12-the-network-edge aria-label="1.2 The Network Edge">1.2 The Network Edge</a><ul><li><a href=#121-access-networks aria-label="1.2.1 Access Networks">1.2.1 Access Networks</a><ul><li><a href=#home-access-dsl-cable-fith-dial-up-and-satellite aria-label="Home Access: DSL, Cable, FITH, Dial-Up and Satellite">Home Access: DSL, Cable, FITH, Dial-Up and Satellite</a></li><li><a href=#access-in-the-enterprise-and-the-home-ethernet-and-wifi aria-label="Access in the Enterprise and the Home: Ethernet and WiFi">Access in the Enterprise and the Home: Ethernet and WiFi</a></li><li><a href=#wide-area-wireless-access-3g-and-lte aria-label="Wide-Area Wireless Access: 3G and LTE">Wide-Area Wireless Access: 3G and LTE</a></li></ul></li><li><a href=#122-physical-media aria-label="1.2.2 Physical Media">1.2.2 Physical Media</a></li></ul></li><li><a href=#13-the-network-core aria-label="1.3 The Network Core">1.3 The Network Core</a><ul><li><a href=#131-packet-switching aria-label="1.3.1 Packet Switching">1.3.1 Packet Switching</a><ul><li><a href=#store-and-forward-transmission aria-label="Store-and-forward Transmission">Store-and-forward Transmission</a></li><li><a href=#queuing-delays-and-packet-loss aria-label="Queuing Delays and Packet Loss">Queuing Delays and Packet Loss</a></li><li><a href=#forwarding-tables-and-routing-protocols aria-label="Forwarding tables and routing protocols">Forwarding tables and routing protocols</a></li></ul></li><li><a href=#132-circuit-switching aria-label="1.3.2 Circuit Switching">1.3.2 Circuit Switching</a><ul><li><a href=#multiplexing-in-circuit-switched-networks aria-label="Multiplexing in Circuit-Switched Networks">Multiplexing in Circuit-Switched Networks</a></li><li><a href=#packet-switching-versus-circuit-switching aria-label="Packet Switching Versus Circuit Switching">Packet Switching Versus Circuit Switching</a></li></ul></li><li><a href=#133-a-network-of-networks aria-label="1.3.3 A Network of Networks">1.3.3 A Network of Networks</a></li></ul></li><li><a href=#14-delay-loss-and-throughput-in-packet-switched-networks aria-label="1.4 Delay, Loss and Throughput in Packet-Switched Networks">1.4 Delay, Loss and Throughput in Packet-Switched Networks</a><ul><li><a href=#141-overview-of-delay-in-packet-switched-networks aria-label="1.4.1 Overview of Delay in Packet-Switched networks">1.4.1 Overview of Delay in Packet-Switched networks</a><ul><li><a href=#types-of-delay aria-label="Types of Delay">Types of Delay</a><ul><li><a href=#processing-delay aria-label="Processing Delay">Processing Delay</a></li><li><a href=#queuing-delay aria-label="Queuing Delay">Queuing Delay</a></li><li><a href=#transmission-delays aria-label="Transmission delays">Transmission delays</a></li><li><a href=#propagation-delay aria-label="Propagation Delay">Propagation Delay</a></li><li><a href=#total-nodal-delay aria-label="Total nodal delay">Total nodal delay</a></li></ul></li></ul></li><li><a href=#142-queuing-delay-and-packet-loss aria-label="1.4.2 Queuing Delay and Packet Loss">1.4.2 Queuing Delay and Packet Loss</a><ul><li><a href=#packet-loss aria-label="Packet Loss">Packet Loss</a></li></ul></li><li><a href=#143-end-to-end-delay aria-label="1.4.3 End-to-End Delay">1.4.3 End-to-End Delay</a></li><li><a href=#144-throughput-in-computer-networks aria-label="1.4.4 Throughput in Computer Networks">1.4.4 Throughput in Computer Networks</a></li></ul></li><li><a href=#15-protocol-layers-and-their-service-models aria-label="1.5 Protocol Layers and Their Service Models">1.5 Protocol Layers and Their Service Models</a><ul><li><a href=#151-layered-architecture aria-label="1.5.1 Layered Architecture">1.5.1 Layered Architecture</a><ul><li><a href=#protocol-layering aria-label="Protocol Layering">Protocol Layering</a><ul><li><a href=#application-layer aria-label="Application Layer">Application Layer</a></li><li><a href=#transport-layer aria-label="Transport Layer">Transport Layer</a></li><li><a href=#network-layer aria-label="Network Layer">Network Layer</a></li><li><a href=#link-layer aria-label="Link Layer">Link Layer</a></li><li><a href=#physical-layer aria-label="Physical Layer">Physical Layer</a></li></ul></li></ul></li><li><a href=#152-encapsulation aria-label="1.5.2 Encapsulation">1.5.2 Encapsulation</a></li></ul></li><li><a href=#16-networks-under-attack aria-label="1.6 Networks Under Attack">1.6 Networks Under Attack</a><ul><li><a href=#malware aria-label=Malware>Malware</a></li><li><a href=#dos aria-label=DoS>DoS</a></li><li><a href=#sniffing aria-label=Sniffing>Sniffing</a></li><li><a href=#spoofing aria-label=Spoofing>Spoofing</a></li><li><a href=#the-history-of-the-internet-shaped-is-structure aria-label="The history of the Internet shaped is structure">The history of the Internet shaped is structure</a></li></ul></li><li><a href=#history-of-computer-networking-and-the-internet aria-label="History of Computer Networking and the Internet">History of Computer Networking and the Internet</a></li></ul></li><li><a href=#chapter-2-application-layer aria-label="Chapter 2: Application Layer">Chapter 2: Application Layer</a><ul><li><a href=#21-principles-of-network-applications aria-label="2.1 Principles of Network Applications">2.1 Principles of Network Applications</a><ul><li><a href=#211-network-application-architectures aria-label="2.1.1 Network Application Architectures">2.1.1 Network Application Architectures</a></li><li><a href=#212-processes-communicating aria-label="2.1.2 Processes Communicating">2.1.2 Processes Communicating</a><ul><li><a href=#client-and-server-processes aria-label="Client and Server Processes">Client and Server Processes</a></li><li><a href=#the-interface-between-the-process-and-the-computer-network aria-label="The Interface Between the Process and the Computer Network">The Interface Between the Process and the Computer Network</a></li><li><a href=#addressing-processes aria-label="Addressing Processes">Addressing Processes</a></li></ul></li><li><a href=#213-transport-services-available-to-applications aria-label="2.1.3 Transport Services Available to Applications">2.1.3 Transport Services Available to Applications</a><ul><li><a href=#reliable-data-transfer aria-label="Reliable Data Transfer">Reliable Data Transfer</a></li><li><a href=#throughput aria-label=Throughput>Throughput</a></li><li><a href=#timing aria-label=Timing>Timing</a></li><li><a href=#security aria-label=Security>Security</a></li></ul></li><li><a href=#214-transport-services-provided-by-the-internet aria-label="2.1.4 Transport Services Provided by the Internet">2.1.4 Transport Services Provided by the Internet</a><ul><li><a href=#tcp-services aria-label="TCP Services">TCP Services</a><ul><li><a href=#securing-tcp aria-label="SECURING TCP">SECURING TCP</a></li></ul></li><li><a href=#udp-services aria-label="UDP Services">UDP Services</a></li><li><a href=#services-not-provided-by-internet-transport-protocols aria-label="Services Not Provided by Internet Transport Protocols">Services Not Provided by Internet Transport Protocols</a></li></ul></li><li><a href=#215-application-layer-protocols aria-label="2.1.5 Application-Layer Protocols">2.1.5 Application-Layer Protocols</a></li></ul></li><li><a href=#22-the-web-and-http aria-label="2.2 The Web and HTTP">2.2 The Web and HTTP</a><ul><li><a href=#221-overview-of-http aria-label="2.2.1 Overview of HTTP">2.2.1 Overview of HTTP</a></li><li><a href=#222-non-persistent-and-persistent-connections aria-label="2.2.2 Non-Persistent and Persistent Connections">2.2.2 Non-Persistent and Persistent Connections</a><ul><li><a href=#http-with-non-persistent-connections aria-label="HTTP with Non-Persistent Connections">HTTP with Non-Persistent Connections</a></li><li><a href=#http-with-persistent-connections aria-label="HTTP with Persistent Connections">HTTP with Persistent Connections</a></li></ul></li><li><a href=#223-http-message-format aria-label="2.2.3 HTTP Message Format">2.2.3 HTTP Message Format</a><ul><li><a href=#http-request-message aria-label="HTTP Request Message">HTTP Request Message</a></li><li><a href=#http-response-message aria-label="HTTP Response Message">HTTP Response Message</a></li></ul></li><li><a href=#224-user-server-interaction-cookies aria-label="2.2.4 User-Server Interaction: Cookies">2.2.4 User-Server Interaction: Cookies</a></li><li><a href=#225-web-caching aria-label="2.2.5 Web Caching">2.2.5 Web Caching</a></li><li><a href=#226-the-conditional-get aria-label="2.2.6 The Conditional GET">2.2.6 The Conditional <code>GET</code></a></li></ul></li><li><a href=#25-dns---the-internets-directory-service aria-label="2.5 DNS - The Internet&amp;rsquo;s Directory Service">2.5 DNS - The Internet&rsquo;s Directory Service</a><ul><li><a href=#251-services-provided-by-dns aria-label="2.5.1 Services provided by DNS">2.5.1 Services provided by DNS</a></li><li><a href=#252-overview-of-how-dns-works aria-label="2.5.2 Overview of How DNS Works">2.5.2 Overview of How DNS Works</a><ul><li><a href=#a-distributed-hierarchical-database aria-label="A Distributed, Hierarchical Database">A Distributed, Hierarchical Database</a></li><li><a href=#dns-caching aria-label="DNS Caching">DNS Caching</a></li></ul></li><li><a href=#253-dns-records-and-messages aria-label="2.5.3 DNS Records and Messages">2.5.3 DNS Records and Messages</a><ul><li><a href=#dns-messages aria-label="DNS Messages">DNS Messages</a></li><li><a href=#inserting-records-into-the-dns-database aria-label="Inserting Records into the DNS Database">Inserting Records into the DNS Database</a><ul><li><a href=#focus-on-security-dns-vulnerabilities aria-label="Focus on security: DNS vulnerabilities">Focus on security: DNS vulnerabilities</a></li></ul></li></ul></li></ul></li><li><a href=#26-peer-to-peer-applications aria-label="2.6 Peer-to-Peer Applications">2.6 Peer-to-Peer Applications</a><ul><li><a href=#261-file-distribution aria-label="2.6.1 File Distribution">2.6.1 File Distribution</a><ul><li><a href=#scalability-of-p2p-architectures aria-label="Scalability of P2P architectures">Scalability of P2P architectures</a></li><li><a href=#client-server aria-label=Client-Server>Client-Server</a></li><li><a href=#p2p aria-label=P2P>P2P</a></li><li><a href=#bittorrent aria-label=BitTorrent>BitTorrent</a></li></ul></li><li><a href=#262-distributed-hash-tables-dhts aria-label="2.6.2 Distributed Hash Tables (DHTs)">2.6.2 Distributed Hash Tables (DHTs)</a><ul><ul><ul><li><a href=#an-approach aria-label="An approach:">An approach:</a></li></ul></ul><li><a href=#circular-dht aria-label="Circular DHT">Circular DHT</a></li><li><a href=#peer-churn aria-label="Peer Churn">Peer Churn</a></li></ul></li></ul></li><li><a href=#27-socket-programming-creating-network-applications aria-label="2.7 Socket Programming: Creating Network Applications">2.7 Socket Programming: Creating Network Applications</a></li></ul></li><li><a href=#chapter-3-transport-layer aria-label="Chapter 3: Transport Layer">Chapter 3: Transport Layer</a><ul><li><a href=#31-introduction-and-transport-layer-services aria-label="3.1 Introduction and Transport-Layer Services">3.1 Introduction and Transport-Layer Services</a><ul><li><a href=#311-relationship-between-transport-and-network-layers aria-label="3.1.1 Relationship Between Transport and Network Layers">3.1.1 Relationship Between Transport and Network Layers</a></li><li><a href=#312-overview-of-the-transport-layer-in-the-internet aria-label="3.1.2 Overview of the Transport Layer in the Internet">3.1.2 Overview of the Transport Layer in the Internet</a></li></ul></li><li><a href=#32-multiplexing-and-demultiplexing aria-label="3.2 Multiplexing and Demultiplexing">3.2 Multiplexing and Demultiplexing</a><ul><ul><li><a href=#connectionless-multiplexing-and-demultiplexing aria-label="Connectionless Multiplexing and Demultiplexing">Connectionless Multiplexing and Demultiplexing</a></li><li><a href=#connection-oriented-multiplexing-and-demultiplexing aria-label="Connection-oriented Multiplexing and Demultiplexing">Connection-oriented Multiplexing and Demultiplexing</a><ul><li><a href=#port-scanning aria-label="Port Scanning">Port Scanning</a></li></ul></li><li><a href=#web-servers-and-tcp aria-label="Web Servers and TCP">Web Servers and TCP</a></li></ul></ul></li><li><a href=#33-connectionless-transport-udp aria-label="3.3 Connectionless Transport: UDP">3.3 Connectionless Transport: UDP</a><ul><li><a href=#331-udp-segment-structure aria-label="3.3.1 UDP Segment Structure">3.3.1 UDP Segment Structure</a></li><li><a href=#332-udp-checksum aria-label="3.3.2 UDP Checksum">3.3.2 UDP Checksum</a></li></ul></li><li><a href=#34-principles-of-reliable-data-transfer aria-label="3.4 Principles of Reliable Data Transfer">3.4 Principles of Reliable Data Transfer</a><ul><li><a href=#341-building-a-reliable-data-transfer-protocol aria-label="3.4.1 Building a Reliable Data Transfer Protocol">3.4.1 Building a Reliable Data Transfer Protocol</a></li><li><a href=#342-pipelined-reliable-data-transfer-protocols aria-label="3.4.2 Pipelined Reliable Data Transfer Protocols">3.4.2 Pipelined Reliable Data Transfer Protocols</a></li><li><a href=#343-go-back-n-gbn aria-label="3.4.3 Go-Back-N (GBN)">3.4.3 Go-Back-N (GBN)</a></li><li><a href=#344-selective-repeat aria-label="3.4.4 Selective Repeat">3.4.4 Selective Repeat</a></li></ul></li><li><a href=#35-conncetion-oriented-transport-tcp aria-label="3.5 Conncetion-Oriented Transport: TCP">3.5 Conncetion-Oriented Transport: TCP</a><ul><li><a href=#351-the-tcp-connection aria-label="3.5.1 The TCP Connection">3.5.1 The TCP Connection</a></li><li><a href=#352-tcp-segment-structure aria-label="3.5.2 TCP Segment Structure">3.5.2 TCP Segment Structure</a><ul><li><a href=#sequence-numbers-and-acknowledgment-numbers aria-label="Sequence Numbers and Acknowledgment Numbers">Sequence Numbers and Acknowledgment Numbers</a></li></ul></li><li><a href=#353-round-trip-time-estimation-and-timeout aria-label="3.5.3 Round-Trip Time Estimation and Timeout">3.5.3 Round-Trip Time Estimation and Timeout</a><ul><li><a href=#estimating-the-round-trip-time aria-label="Estimating the Round-Trip Time">Estimating the Round-Trip Time</a></li><li><a href=#setting-and-managing-the-retransmission-timeout-interval aria-label="Setting and Managing the Retransmission Timeout Interval">Setting and Managing the Retransmission Timeout Interval</a></li></ul></li><li><a href=#354-reliable-data-transfer aria-label="3.5.4 Reliable Data Transfer">3.5.4 Reliable Data Transfer</a><ul><li><a href=#doubling-the-timeout-interval aria-label="Doubling the Timeout Interval">Doubling the Timeout Interval</a></li><li><a href=#fast-retransmit aria-label="Fast Retransmit">Fast Retransmit</a></li><li><a href=#go-back-n-or-selective-repeat aria-label="Go-Back-N or Selective Repeat?">Go-Back-N or Selective Repeat?</a></li></ul></li><li><a href=#355-flow-control aria-label="3.5.5 Flow Control">3.5.5 Flow Control</a><ul><ul><li><a href=#b-side aria-label="B side">B side</a></li><li><a href=#a-side aria-label="A side">A side</a></li></ul></ul></li><li><a href=#356-tcp-connection-management aria-label="3.5.6 TCP Connection Management">3.5.6 TCP Connection Management</a><ul><li><a href=#how-is-the-connection-established-three-way-handshake aria-label="How is the connection established? Three-way handshake">How is the connection established? <strong>Three-way handshake</strong></a></li><li><a href=#tearing-down-a-tcp-connection aria-label="Tearing down a TCP connection">Tearing down a TCP connection</a></li><li><a href=#what-if-the-two-ends-are-not-ready-for-communication aria-label="What if the two ends are not ready for communication?">What if the two ends are not ready for communication?</a></li></ul></li></ul></li><li><a href=#36-principles-of-congestion-control aria-label="3.6 Principles of Congestion Control">3.6 Principles of Congestion Control</a><ul><li><a href=#361-the-causes-and-the-costs-of-congestion aria-label="3.6.1 The Causes and the Costs of Congestion">3.6.1 The Causes and the Costs of Congestion</a><ul><li><a href=#scenario-1-two-senders-a-router-with-infinite-buffers aria-label="Scenario 1: Two Senders, A Router with Infinite Buffers">Scenario 1: Two Senders, A Router with Infinite Buffers</a></li></ul></li></ul></li><li><a href=#37-tcp-congestion-control aria-label="3.7 TCP Congestion Control">3.7 TCP Congestion Control</a><ul><li><a href=#tcp-congestion-control-algorithm aria-label="TCP Congestion-Control Algorithm">TCP Congestion-Control Algorithm</a><ul><li><a href=#1---slow-start aria-label="1 - Slow Start">1 - Slow Start</a></li><li><a href=#2---congestion-avoidance aria-label="2 - Congestion Avoidance">2 - Congestion Avoidance</a></li><li><a href=#3---fast-recovery aria-label="3 - Fast Recovery">3 - Fast Recovery</a></li><li><a href=#macroscopic-description-of-tcp-throughput aria-label="Macroscopic Description of TCP Throughput">Macroscopic Description of TCP Throughput</a></li><li><a href=#tcp-over-high-bandwidth-paths aria-label="TCP Over High-Bandwidth Paths">TCP Over High-Bandwidth Paths</a></li></ul></li></ul></li></ul></li><li><a href=#chapter-4-the-network-layer aria-label="Chapter 4: The Network Layer">Chapter 4: The Network Layer</a><ul><li><a href=#41-introduction aria-label="4.1 Introduction">4.1 Introduction</a><ul><li><a href=#411-forwarding-and-routing aria-label="4.1.1 Forwarding and Routing">4.1.1 Forwarding and Routing</a><ul><li><a href=#connection-setup aria-label="Connection Setup">Connection Setup</a></li></ul></li><li><a href=#412-network-service-models aria-label="4.1.2 Network Service Models">4.1.2 Network Service Models</a></li></ul></li><li><a href=#42-virtual--circuit-and-datagrams-networks aria-label="4.2 Virtual  Circuit and Datagrams Networks">4.2 Virtual Circuit and Datagrams Networks</a><ul><li><a href=#421-virtual-circuit-networks aria-label="4.2.1 Virtual-Circuit Networks">4.2.1 Virtual-Circuit Networks</a></li><li><a href=#422-datagram-networks aria-label="4.2.2 Datagram Networks">4.2.2 Datagram Networks</a></li><li><a href=#423-origins-of-vc-and-datagram-networks aria-label="4.2.3 Origins of VC and Datagram Networks">4.2.3 Origins of VC and Datagram Networks</a></li></ul></li><li><a href=#43-whats-inside-a-router aria-label="4.3 What&amp;rsquo;s Inside a Router?">4.3 What&rsquo;s Inside a Router?</a><ul><li><a href=#431-input-processing aria-label="4.3.1 Input Processing">4.3.1 Input Processing</a></li><li><a href=#432-switching aria-label="4.3.2 Switching">4.3.2 Switching</a><ul><li><a href=#switching-via-memory aria-label="Switching via memory">Switching via memory</a></li><li><a href=#switching-via-a-bus aria-label="Switching via a bus">Switching via a bus</a></li><li><a href=#switching-via-an-interconnected-network aria-label="Switching via an interconnected network">Switching via an interconnected network</a></li></ul></li><li><a href=#433-output-processing aria-label="4.3.3 Output Processing">4.3.3 Output Processing</a></li><li><a href=#434-where-does-queuing-occur aria-label="4.3.4 Where Does Queuing Occur?">4.3.4 Where Does Queuing Occur?</a></li></ul></li><li><a href=#44-the-internet-protocol-ip-forwarding-and-addressing-in-the-internet aria-label="4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet">4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet</a><ul><li><a href=#441-datagram-format aria-label="4.4.1 Datagram Format">4.4.1 Datagram Format</a><ul><li><a href=#ip-datagram-fragmentation aria-label="IP Datagram Fragmentation">IP Datagram Fragmentation</a></li></ul></li><li><a href=#442-ipv4-addressing aria-label="4.4.2 IPv4 Addressing">4.4.2 IPv4 Addressing</a><ul><li><a href=#obtaining-a-block-of-addresses aria-label="Obtaining a Block of Addresses">Obtaining a Block of Addresses</a></li><li><a href=#obtaining-a-host-address-the-dynamic-host-configuration-protocol aria-label="Obtaining a Host Address: The Dynamic Host Configuration Protocol">Obtaining a Host Address: The Dynamic Host Configuration Protocol</a></li><li><a href=#network-address-translation-nat aria-label="Network Address Translation (NAT)">Network Address Translation (NAT)</a></li><li><a href=#upnp aria-label=UPnP>UPnP</a></li></ul></li><li><a href=#443-internet-control-message-protocol aria-label="4.4.3 Internet Control Message Protocol">4.4.3 Internet Control Message Protocol</a><ul><li><a href=#inspecting-datagrams-firewalls-and-intrusion-detection-systems aria-label="Inspecting datagrams: firewalls and intrusion detection systems">Inspecting datagrams: firewalls and intrusion detection systems</a></li></ul></li><li><a href=#444-ipv6 aria-label="4.4.4 IPv6">4.4.4 IPv6</a><ul><li><a href=#datagram-format aria-label="Datagram format">Datagram format</a></li><li><a href=#transitioning-from-ipv4-to-ipv6 aria-label="Transitioning from IPv4 to IPv6">Transitioning from IPv4 to IPv6</a></li></ul></li></ul></li></ul></li><li><a href=#45-routing-algorithms aria-label="4.5 Routing Algorithms">4.5 Routing Algorithms</a><ul><ul><li><a href=#451-the-link-state-ls-routing-algorithm aria-label="4.5.1 The Link-State (LS) Routing Algorithm">4.5.1 The Link-State (LS) Routing Algorithm</a></li><li><a href=#452-the-distance-vector-dv-routing-algorithm aria-label="4.5.2 The Distance-Vector (DV) Routing Algorithm">4.5.2 The Distance-Vector (DV) Routing Algorithm</a></li><li><a href=#453-hierarchical-routing aria-label="4.5.3 Hierarchical Routing">4.5.3 Hierarchical Routing</a></li></ul><li><a href=#46-routing-in-the-internet aria-label="4.6 Routing in the Internet">4.6 Routing in the Internet</a><ul><li><a href=#461-intra-as-routing-in-the-internet-rip aria-label="4.6.1 Intra-AS Routing in the Internet: RIP">4.6.1 Intra-AS Routing in the Internet: RIP</a></li><li><a href=#462-intra-as-routing-in-the-internet-ospf aria-label="4.6.2 Intra-AS Routing in the Internet: OSPF">4.6.2 Intra-AS Routing in the Internet: OSPF</a></li><li><a href=#463-inter-as-routing-bgp aria-label="4.6.3 Inter-AS Routing: BGP">4.6.3 Inter-AS Routing: BGP</a><ul><li><a href=#basics aria-label=Basics>Basics</a></li><li><a href=#path-attributes-and-bgp-routes aria-label="Path Attributes and BGP Routes">Path Attributes and BGP Routes</a></li><li><a href=#bgp-route-selection aria-label="BGP Route Selection">BGP Route Selection</a></li></ul></li></ul></li></ul></li><li><a href=#chapter-8-security-in-computer-networks aria-label="Chapter 8: Security in Computer Networks">Chapter 8: Security in Computer Networks</a><ul><li><a href=#81-what-is-network-security aria-label="8.1 What is Network Security?">8.1 What is Network Security?</a></li><li><a href=#82-principle-of-cryptography aria-label="8.2 Principle of Cryptography">8.2 Principle of Cryptography</a><ul><ul><li><a href=#block-ciphers aria-label="Block Ciphers">Block Ciphers</a><ul><li><a href=#cipher-block-chaining aria-label="Cipher-Block Chaining">Cipher-Block Chaining</a></li></ul></li></ul></ul></li><li><a href=#83-message-integrity-and-digital-signatures aria-label="8.3 Message Integrity and Digital Signatures">8.3 Message Integrity and Digital Signatures</a><ul><li><a href=#831-cryptographic-hash-functions aria-label="8.3.1 Cryptographic Hash Functions">8.3.1 Cryptographic Hash Functions</a></li><li><a href=#832-message-authentication-code aria-label="8.3.2 Message Authentication Code">8.3.2 Message Authentication Code</a></li><li><a href=#833-digital-signatures aria-label="8.3.3 Digital Signatures">8.3.3 Digital Signatures</a><ul><li><a href=#public-key-certification aria-label="Public Key Certification">Public Key Certification</a></li></ul></li></ul></li><li><a href=#84-end-point-authentication aria-label="8.4 End-Point Authentication">8.4 End-Point Authentication</a><ul><ul><li><a href=#version-10 aria-label="Version 1.0">Version 1.0</a></li><li><a href=#version-20 aria-label="Version 2.0">Version 2.0</a></li><li><a href=#version-30 aria-label="Version 3.0">Version 3.0</a></li><li><a href=#version-31 aria-label="Version 3.1">Version 3.1</a></li><li><a href=#version-40 aria-label="Version 4.0">Version 4.0</a></li></ul></ul></li><li><a href=#85-securing-e-mail aria-label="8.5 Securing e-mail">8.5 Securing e-mail</a><ul><li><a href=#851-secure-e-mail aria-label="8.5.1 Secure E-Mail">8.5.1 Secure E-Mail</a><ul><li><a href=#phil-zimmermann-and-pgp aria-label="Phil Zimmermann and PGP">Phil Zimmermann and PGP</a></li></ul></li><li><a href=#852-pgp aria-label="8.5.2 PGP">8.5.2 PGP</a></li></ul></li><li><a href=#86-securing-tcp-connections-ssl aria-label="8.6 Securing TCP Connections: SSL">8.6 Securing TCP Connections: SSL</a><ul><li><a href=#861-the-big-picture-primitive-almost-ssl aria-label="8.6.1 The Big Picture (primitive almost-SSL)">8.6.1 The Big Picture (primitive almost-SSL)</a><ul><li><a href=#ssl-record aria-label="SSL Record">SSL Record</a></li></ul></li><li><a href=#862-a-more-complete-picture aria-label="8.6.2 A More Complete Picture">8.6.2 A More Complete Picture</a><ul><li><a href=#connection-closure aria-label="Connection Closure">Connection Closure</a></li></ul></li></ul></li><li><a href=#87-network-layer-security-ipsec-and-virtual-private-networks aria-label="8.7 Network-Layer Security: IPsec and Virtual Private Networks">8.7 Network-Layer Security: IPsec and Virtual Private Networks</a><ul><li><a href=#871-ipsec-and-virtual-private-networks-vpns aria-label="8.7.1 IPsec and Virtual Private Networks (VPNs)">8.7.1 IPsec and Virtual Private Networks (VPNs)</a></li><li><a href=#872-the-ah-and-esp-protocols aria-label="8.7.2 The AH and ESP Protocols">8.7.2 The AH and ESP Protocols</a></li><li><a href=#873-security-associations aria-label="8.7.3 Security Associations">8.7.3 Security Associations</a></li><li><a href=#874-the-ipsec-datagram aria-label="8.7.4 The IPsec Datagram">8.7.4 The IPsec Datagram</a></li><li><a href=#875-ike-key-management-in-ipsec aria-label="8.7.5 IKE: Key Management in IPsec">8.7.5 IKE: Key Management in IPsec</a></li></ul></li><li><a href=#89-operational-security-firewalls-and-intrusion-detection-systems aria-label="8.9 Operational Security: Firewalls and Intrusion Detection Systems">8.9 Operational Security: Firewalls and Intrusion Detection Systems</a><ul><li><a href=#891-firewalls aria-label="8.9.1 Firewalls">8.9.1 Firewalls</a><ul><li><a href=#1-traditional-packet-filters aria-label="1: Traditional Packet Filters">1: Traditional Packet Filters</a></li><li><a href=#2-stateful-packet-filters aria-label="2: Stateful Packet Filters">2: Stateful Packet Filters</a></li><li><a href=#3-application-gateways aria-label="3: Application Gateways">3: Application Gateways</a></li></ul></li><li><a href=#892-intrusion-detection-systems aria-label="8.9.2 Intrusion Detection Systems">8.9.2 Intrusion Detection Systems</a></li></ul></li></ul></li><li><a href=#chapter-5-the-link-layer-links-access-networks-and-lans aria-label="Chapter 5: The Link Layer: Links, Access Networks and LANs">Chapter 5: The Link Layer: Links, Access Networks and LANs</a><ul><li><a href=#51-introduction-to-the-link-layer aria-label="5.1 Introduction to the Link Layer">5.1 Introduction to the Link Layer</a><ul><li><a href=#511-the-services-provided-by-the-link-layer aria-label="5.1.1 The Services Provided by The Link Layer">5.1.1 The Services Provided by The Link Layer</a></li><li><a href=#512-where-is-the-link-layer-implemented aria-label="5.1.2 Where Is the Link Layer Implemented?">5.1.2 Where Is the Link Layer Implemented?</a></li></ul></li><li><a href=#52-error-detection-and--correction-techniques aria-label="5.2 Error-Detection and -Correction Techniques">5.2 Error-Detection and -Correction Techniques</a><ul><li><a href=#521-parity-checks aria-label="5.2.1 Parity Checks">5.2.1 Parity Checks</a></li><li><a href=#522-checksumming-methods aria-label="5.2.2 Checksumming Methods">5.2.2 Checksumming Methods</a></li><li><a href=#523-cyclic-redundancy-check-crc aria-label="5.2.3 Cyclic Redundancy Check (CRC)">5.2.3 Cyclic Redundancy Check (CRC)</a></li></ul></li><li><a href=#53-multiple-access-links-and-protocols aria-label="5.3 Multiple Access Links and Protocols">5.3 Multiple Access Links and Protocols</a><ul><li><a href=#531-channel-partitioning-protocols aria-label="5.3.1 Channel Partitioning Protocols">5.3.1 Channel Partitioning Protocols</a></li><li><a href=#532-random-access-protocols aria-label="5.3.2 Random Access Protocols">5.3.2 Random Access Protocols</a><ul><li><a href=#slotted-aloha aria-label="Slotted ALOHA">Slotted ALOHA</a></li><li><a href=#aloha aria-label=Aloha>Aloha</a></li><li><a href=#carrier-sense-multiple-access-csma aria-label="Carrier Sense Multiple Access (CSMA)">Carrier Sense Multiple Access (CSMA)</a></li><li><a href=#carrier-sense-multiple-access-with-collision-detection-csmacd aria-label="Carrier Sense Multiple Access with Collision Detection (CSMA/CD)">Carrier Sense Multiple Access with Collision Detection (CSMA/CD)</a></li><li><a href=#csmacd-efficiency aria-label="CSMA/CD Efficiency">CSMA/CD Efficiency</a></li></ul></li><li><a href=#533-taking-turns-protocols aria-label="5.3.3 Taking-Turns Protocols">5.3.3 Taking-Turns Protocols</a></li><li><a href=#534-docsis-the-link-layer-protocol-for-cable-internet-access aria-label="5.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access">5.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access</a></li></ul></li><li><a href=#54-switched-local-area-networks aria-label="5.4 Switched Local Area Networks">5.4 Switched Local Area Networks</a><ul><li><a href=#541-link-layer-addressing-and-arp aria-label="5.4.1 Link-Layer Addressing and ARP">5.4.1 Link-Layer Addressing and ARP</a><ul><li><a href=#mac-addresses aria-label="MAC Addresses">MAC Addresses</a></li><li><a href=#address-resolution-protocol-arp aria-label="Address Resolution Protocol (ARP)">Address Resolution Protocol (ARP)</a></li></ul></li><li><a href=#sending-a-datagram-off-the-subnet aria-label="Sending a Datagram off the Subnet">Sending a Datagram off the Subnet</a></li><li><a href=#542-ethernet aria-label="5.4.2 Ethernet">5.4.2 Ethernet</a><ul><li><a href=#ethernet-frame-structure aria-label="Ethernet Frame Structure">Ethernet Frame Structure</a></li><li><a href=#ethernet-technologies aria-label="Ethernet Technologies">Ethernet Technologies</a></li></ul></li><li><a href=#543-link-layer-switches aria-label="5.4.3 Link-Layer Switches">5.4.3 Link-Layer Switches</a></li><li><a href=#forwarding-and-filtering aria-label="Forwarding and Filtering">Forwarding and Filtering</a><ul><li><a href=#self-learning aria-label=Self-Learning>Self-Learning</a></li><li><a href=#properties-of-link-layer-switching aria-label="Properties of Link-Layer Switching">Properties of Link-Layer Switching</a></li><li><a href=#switches-versus-routers aria-label="Switches Versus Routers">Switches Versus Routers</a></li></ul></li><li><a href=#pdf-note aria-label="PDF Note👇">PDF Note👇</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=chapter-1-computer-networks-and-the-internet>Chapter 1: Computer Networks and the Internet<a hidden class=anchor aria-hidden=true href=#chapter-1-computer-networks-and-the-internet>#</a></h1><h2 id=11-what-is-the-internet>1.1 What is the Internet?<a hidden class=anchor aria-hidden=true href=#11-what-is-the-internet>#</a></h2><h3 id=111-a-nuts-and-bolts-description>1.1.1 A nuts-and-bolts description<a hidden class=anchor aria-hidden=true href=#111-a-nuts-and-bolts-description>#</a></h3><p>The Internet is a computer networks that interconnects hundreds of millions of computing devices through the world. Today not only computers and workstation are being connected to the network, therefore the term <em>computer network</em> may sound a bit dated.</p><p>All the devices connected to the Internet are called <strong>hosts</strong> or <strong>end systems</strong>. End systems are connected together by a network of <strong>communication links</strong> and <strong>packets switches</strong>.</p><p>Different links can transmit data at different rates, with the <strong>transmission rate</strong> of a link measured in bits/second.</p><p>When one end system has data to send to another end system, the sending end system <em>segments</em> the data and adds <em>header bytes</em> to each segment. The resulting packages of information, called <strong>packets</strong>, are then sent through the network to the destination and system where they a reassembled into the original data.</p><p>A packet switch takes a packet arriving on one of its incoming communication links and forwards that packet on one of its outgoing communication links. The two most prominent types of packets switches are <strong>routers</strong> and <strong>link switches</strong>. The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as <strong>route</strong> or <strong>path</strong>.</p><p>End systems access the Internet through <strong>Internet Service Providers (ISPs)</strong>, including residential ISPs (cable or phone company), corporate, university ISPs &mldr;
Each ISP in itself is a network of packet switches and communication links.
<em>Lower tier</em> (which interconnect end-systems) ISPs are interconnected through national and international <em>upper tier</em> ISP. An upper-tier ISP consists of high speed routers interconnected with high-speed fiber-optic links. Each ISP network is managed independently.</p><p>End systems, packet switches and other pieces of the Internet run <strong>protocols</strong> that control the sending and receiving of information within the Internet.</p><h3 id=112-a-services-description>1.1.2 A Services Description<a hidden class=anchor aria-hidden=true href=#112-a-services-description>#</a></h3><p>The Internet can be described as <em>an infrastructure that provides services to applications</em>. These applications (Web, social networks, VoIP&mldr;) are said to be <strong>distributed</strong> since they involve multiple end systems that exchange data with each other.
<strong>Internet applications run on end systems, not in the packet switches or routers</strong>, packet switches facilitate the exchange of data, but they are not concerned with the application that is the source or sink of data.</p><p>End systems attached to the Internet provide and <strong>Application Programming Interface (API)</strong> that specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system.</p><h3 id=113-what-is-a-protocol>1.1.3 What Is a Protocol?<a hidden class=anchor aria-hidden=true href=#113-what-is-a-protocol>#</a></h3><p>All the activity in the Internet that involves two or more communicating remote entities is governed by a protocol.</p><p><strong>A protocol defines the format and the order of messages exchanged between two or more communicating entities, as weel as the actions taken on the trasmission and/or receipt of a message or other event</strong></p><h2 id=12-the-network-edge>1.2 The Network Edge<a hidden class=anchor aria-hidden=true href=#12-the-network-edge>#</a></h2><p>Computers and other devices connected to the Internet are often referred to as <em>end systems</em> as they sit at the edge of the Internet. They are also called <em>hosts</em> as they host, run, applications programs such as a Web Browser or an email client.</p><p>Hosts are sometimes further divided into two categories: <em>clients</em> and <em>servers</em>. The former being desktop, mobile pcs, smartphones, the latter being powerful machines that store and distribute Web pages, streams&mldr;
Nowadays most of the servers reside in large <em>data centers</em></p><h3 id=121-access-networks>1.2.1 Access Networks<a hidden class=anchor aria-hidden=true href=#121-access-networks>#</a></h3><p>They are the networks that physically connect end systems to the first router on a path from the end system to any other distant end system.
Examples: mobile network, national or global ISP, local or regional ISP, home networks enterprise networks.</p><h4 id=home-access-dsl-cable-fith-dial-up-and-satellite>Home Access: DSL, Cable, FITH, Dial-Up and Satellite<a hidden class=anchor aria-hidden=true href=#home-access-dsl-cable-fith-dial-up-and-satellite>#</a></h4><p>Today, the two most prevalent types of broadband residential access are <strong>digital subscriber line (DSL)</strong> and <strong>cable</strong>.</p><p>A residence typically obtains DSL access from the telephone company (telco) that provides its wired local phone access. The customer&rsquo;s telco is therefore its ISP.
DSL modem use the existing telephone lines to exchange data with DSLAMs (digital subscriber line access multiplexer) located in the telco local central office. The DSL modem takes digital data and translates it to high-frequency tones for transmission over telephone wires, these analog signals from many houses are translated back into digital format at the DSLAM. The use of different frequencies allows the phone line to carry a high-speed downstream channel, a medium-speed upstream channel and an ordinary two-way telephone channel.
Hundreds or even thousands of households connect to a single DSLAM.</p><p>DSL: 24 Mbps downstream and 2.5 Mbps upstream (MAX VALUES). Because of the difference between these two values, the access is said to be <strong>asymmetric</strong>.</p><p><strong>Cable Internet</strong> access makes use of the cable television company&rsquo;s existing cable television infrastructure. Cable modems connect to CMTS (Cablem Modem Termination System) which does the same job the DSLAM does for phone lines. The access is typically asymmetric.
CABLE: 42.8 Mbps downstream and 30.7 Mbps upstream (MAX VALUES).
Cable Internet access is a shared broadcast medium: each packet travels downstream on every link to every home and viceversa. For this, if several users are simultaneously using the downstream channel, the actual rate will be significantly lower.</p><p>Another up-and-coming technology that promises very high speeds is <strong>fiber to the home (FTTH)</strong>. The concept is simple: provide an optical fiber path from the Central Office (CO)</p><h4 id=access-in-the-enterprise-and-the-home-ethernet-and-wifi>Access in the Enterprise and the Home: Ethernet and WiFi<a hidden class=anchor aria-hidden=true href=#access-in-the-enterprise-and-the-home-ethernet-and-wifi>#</a></h4><p>On corporate and university campuses, and increasingly in home settings, a <strong>Local Area Network (LAN)</strong> is used to connect an end system to the edge router.
Ethernet is by far the most prevalent access technology is corporate, university and home networks. Ethernet uses twisted-pair copper wire to connect to an Ethernet switch which is connected into the larger Internet.
The Internet is increasingly accessed wirelessly: wireless users transmit/receive packets to/from an access point connected into the enterprise&rsquo;s network which in turn is connected to the wired Internet.</p><h4 id=wide-area-wireless-access-3g-and-lte>Wide-Area Wireless Access: 3G and LTE<a hidden class=anchor aria-hidden=true href=#wide-area-wireless-access-3g-and-lte>#</a></h4><p>Smartphones and Tablets employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station operated by the cellular network provider. Third generation (3G) wireless and fourth generation (4G) of wide-area network are being deployed. LTE (&ldquo;Long-Term Evolution&rdquo;) has its root in 3G and can potentially achieve rates in excess of 10 Mbps.</p><h3 id=122-physical-media>1.2.2 Physical Media<a hidden class=anchor aria-hidden=true href=#122-physical-media>#</a></h3><p>The book talks about it in detail but we haven&rsquo;t talked about it in class</p><p>A bit, when traveling from source to destination, passes through a series of transmitter-receiver pairs, for each pair, the bit is sent by propagating electromagnetic waves or optical pulses across a <strong>physical medium</strong>. This can take many shapes and forms and doesn&rsquo;t have to be of the same type for each transmitter-receiver pair along the path.
Physical media fall into two categories:</p><ul><li><strong>guided media</strong>: the waves are guided along a solid medium (fiber-optic cable, twisted-pair copper wire, coaxial cable)</li><li><strong>unguided media</strong>: the waves propagate in the atmosphere and in outer space (wireless LAN, digital satellite channel)</li></ul><h2 id=13-the-network-core>1.3 The Network Core<a hidden class=anchor aria-hidden=true href=#13-the-network-core>#</a></h2><h3 id=131-packet-switching>1.3.1 Packet Switching<a hidden class=anchor aria-hidden=true href=#131-packet-switching>#</a></h3><p>In a network application, end systems exchange <strong>messages</strong> with each other. To send a message from a source end system to a destination end system, the source breaks long messages into smaller chunks of data known as <strong>packets</strong>.
Between source and destination, each packet travels through communication links and <strong>packet switches</strong> (for which there are two predominant types, <strong>routers</strong> and <strong>link-layer switches</strong>).
Packets are transmitted over each communication link at a rate equal to the <em>full</em> transmission rate of the link. So, if a source end system or a packet switch is send a packet of L bits over a link with transmission rate R bits/sec, then the time to transmit the packet is L/R seconds.</p><h4 id=store-and-forward-transmission>Store-and-forward Transmission<a hidden class=anchor aria-hidden=true href=#store-and-forward-transmission>#</a></h4><p>Most packet switches use <strong>store-and-forward transmission</strong> at the inputs to the links. Store-and-forward transmission means that the packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. The link must <strong>buffer</strong> (&ldquo;store&rdquo;) the packet&rsquo;s bits and only after the router has received all of the packet&rsquo;s bits can it begin to transmit (&ldquo;forward&rdquo;) the packet onto the outbound link.</p><h4 id=queuing-delays-and-packet-loss>Queuing Delays and Packet Loss<a hidden class=anchor aria-hidden=true href=#queuing-delays-and-packet-loss>#</a></h4><p>Each packet switch has multiple links attached to it. For each attached link, the packet switch has an <strong>output buffer</strong> (or <strong>output queue</strong>) which stores packets that the router is about to send into that link.
If an arriving packet needs to be transmitted onto a link but finds the link busy with the transmission of another packet, the arriving packet must wait in the output buffer. Thus, packets suffer output buffer <strong>queuing delays</strong> which are variable and depend on the level of congestion in the network. Since the amount of buffer space is finite, an arriving packet may find the buffer completely full. In this case, <strong>packet loss</strong> will occur, either the arriving packet or one of the already queued packets will be dropped.</p><h4 id=forwarding-tables-and-routing-protocols>Forwarding tables and routing protocols<a hidden class=anchor aria-hidden=true href=#forwarding-tables-and-routing-protocols>#</a></h4><p>In the Internet, every end system has an address called an IP address. When a source end system wants to send a packet to a destination end system, the source includes the destination&rsquo;s IP address in the packet&rsquo;s header.
Each router has a <strong>forwarding table</strong> that maps destination addresses (or portions of the destination addresses) to that router&rsquo;s outbound links. When a packet arrives at the router, the router examines the address and searches its forwarding table, using this destination address, to find the appropriate outbound link.
A number of special <strong>routing protocols</strong> are used to automatically set the forwarding tables.</p><h3 id=132-circuit-switching>1.3.2 Circuit Switching<a hidden class=anchor aria-hidden=true href=#132-circuit-switching>#</a></h3><p>In circuit-switched networks, the resources needed along a path(buffers, link transmission rate) to provide for communication between the end systems are <strong>reserved</strong> for the duration of the communication sessions.
When two hosts want to communicate, the network establishes a <strong>dedicated end-to-end connection</strong> between them.</p><h4 id=multiplexing-in-circuit-switched-networks>Multiplexing in Circuit-Switched Networks<a hidden class=anchor aria-hidden=true href=#multiplexing-in-circuit-switched-networks>#</a></h4><p>A circuit in a link is implemented with either <strong>frequency-division multiplexing (FDM)</strong> or <strong>time-division multiplexing (TDM)</strong>.
With FDM, the frequency spectrum of a link is divided up among the connections established across the link. The width of the band is called the <strong>bandwidth</strong>.
For a TDM link, time is divided into frames of fixed duration, and each frame is divided into a fixed number of time slots.</p><h4 id=packet-switching-versus-circuit-switching>Packet Switching Versus Circuit Switching<a hidden class=anchor aria-hidden=true href=#packet-switching-versus-circuit-switching>#</a></h4><p>Packet switching is more flexible, uses resources efficiently and is simpler to implement (even if it requires congestion control).
Circuit switching offers performance guarantees but uses resources inefficiently</p><h3 id=133-a-network-of-networks>1.3.3 A Network of Networks<a hidden class=anchor aria-hidden=true href=#133-a-network-of-networks>#</a></h3><p>To create the Internet, ISPs must be interconnected, thus creating a <em>network of networks</em>.
Much of the evolution of the structure of the Internet is driven by economics and national policy, rather than by performance consideration.</p><p>Today&rsquo;s Internet is complex, consisting of a dozen or so tier-1 ISPs and hundreds of thousands of lower-tier ISPs. The ISPs are diverse in their coverage, with some spanning multiple continents and oceans, and others limited to narrow geographic regions. The lower-tier ISPs connect to the higher-tier ISPs and the higher-tier ISPs interconnect with one another. Users and content providers are customers of lower-tier ISPs and lower-tier ISPs are customers of higher-tier ISPs. Recently, major content providers (Google) have also created their own networks and connect directly into lower-tier ISPs where possible.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-network_of_networks.png alt=network_of_networks></p><h2 id=14-delay-loss-and-throughput-in-packet-switched-networks>1.4 Delay, Loss and Throughput in Packet-Switched Networks<a hidden class=anchor aria-hidden=true href=#14-delay-loss-and-throughput-in-packet-switched-networks>#</a></h2><p>Computer networks necessarily constrain <strong>throughput</strong> (the amount of data per second that can be transferred) between end system, introduce delays between end systems and can actually lose packets.</p><h3 id=141-overview-of-delay-in-packet-switched-networks>1.4.1 Overview of Delay in Packet-Switched networks<a hidden class=anchor aria-hidden=true href=#141-overview-of-delay-in-packet-switched-networks>#</a></h3><p>As a packet travels from one node (host or router) to the subsequent host along his path, it suffers from several types of delays at <em>each</em> node along the path.</p><h4 id=types-of-delay>Types of Delay<a hidden class=anchor aria-hidden=true href=#types-of-delay>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-type_of_delays.png alt=type_of_delays></p><h5 id=processing-delay>Processing Delay<a hidden class=anchor aria-hidden=true href=#processing-delay>#</a></h5><p>The <strong>processing delay</strong> consists of the time required to examine the packet&rsquo;s header and determine where to direct the packet. It may also include other factors, such as the time needed to check for bit-level errors occurred during transmission.
They typically are of the order of microseconds or less.
After processing the packet is sent to the queue preceding the link to the next router</p><h5 id=queuing-delay>Queuing Delay<a hidden class=anchor aria-hidden=true href=#queuing-delay>#</a></h5><p>At the queue, the packet experiences a <strong>queuing delay</strong> as it waits to be transmitted onto the link. It depends on the number of earlier-arriving packets, therefore if the queue is empty, then the packet&rsquo;s queuing delay will be 0.
Typically of the order of microseconds or milliseconds.</p><h5 id=transmission-delays>Transmission delays<a hidden class=anchor aria-hidden=true href=#transmission-delays>#</a></h5><p>If the length of the packet is <em>L</em> bits, and the <strong>transmission rate</strong> of the link is <em>R</em> bits/sec, then the <strong>transmission delay</strong> is <em>L/R</em>.
This is the amount of time required to push (transmit) all of the packet&rsquo;s bits into the link.
Typically on the order of microseconds to milliseconds.</p><h5 id=propagation-delay>Propagation Delay<a hidden class=anchor aria-hidden=true href=#propagation-delay>#</a></h5><p>The time required to propagate a bit from the beginning of the link to the next router is the <strong>propagation delay</strong>. The bit propagates at the propagation speed of the link, which depends on the physical medium of the link.
The propagation delay is the distance between two routers divided by the propagation speed of the link.</p><h5 id=total-nodal-delay>Total nodal delay<a hidden class=anchor aria-hidden=true href=#total-nodal-delay>#</a></h5><p>it is the summation of the previous delays</p><h3 id=142-queuing-delay-and-packet-loss>1.4.2 Queuing Delay and Packet Loss<a hidden class=anchor aria-hidden=true href=#142-queuing-delay-and-packet-loss>#</a></h3><p>The queuing delay depends can vary from packet to packet, therefore when characterizing queuing delay, one typically uses statistical measures, such as <em>average queuing delay, variance of queuing delay, and the probability that the queuing delay exceeds some specified value</em>.</p><h4 id=packet-loss>Packet Loss<a hidden class=anchor aria-hidden=true href=#packet-loss>#</a></h4><p>A queue preceding a link has finite capacity. If a packet finds a full queue, then the router will <strong>drop</strong> it, the packet will be lost.
The fraction of lost packets increases as the traffic intensity increases.</p><h3 id=143-end-to-end-delay>1.4.3 End-to-End Delay<a hidden class=anchor aria-hidden=true href=#143-end-to-end-delay>#</a></h3><p>Let&rsquo;s now consider the <strong>total delay, from source to destination</strong> (not only the nodal delay). Let&rsquo;s suppose there are <em>N-1</em> routers between the source host and the destination host, then the nodal delays accumulate and give an <strong>end-to-end delay</strong>:</p><pre tabindex=0><code>d(end_end) = N * [d(proc) + d(queue) + d(trans) + d(prop)]
</code></pre><h3 id=144-throughput-in-computer-networks>1.4.4 Throughput in Computer Networks<a hidden class=anchor aria-hidden=true href=#144-throughput-in-computer-networks>#</a></h3><p>Another critical performance measure in computer networks is <em>end-to-end throughput</em>.
The <strong>instantaneous throughput</strong> at any instant of time is the rate (in bits/sec) at which host B is receiving a file.
If the file consists of <em>F</em> bits and the transfers takes <em>T</em> seconds to transfer the whole file, then the <strong>average throughput</strong> of the file is <em>F/T bits/sec</em>.
For a simple two-link network, the throughput is the min of all the throughputs, that is the transmission rate of the <strong>bottleneck link</strong>.
Therefore, the constraining factor for throughput in today&rsquo;s Internet is typically the <em>access network</em>.</p><h2 id=15-protocol-layers-and-their-service-models>1.5 Protocol Layers and Their Service Models<a hidden class=anchor aria-hidden=true href=#15-protocol-layers-and-their-service-models>#</a></h2><h3 id=151-layered-architecture>1.5.1 Layered Architecture<a hidden class=anchor aria-hidden=true href=#151-layered-architecture>#</a></h3><p>A layered architecture allows us to discuss a well-defined, specific part of a large and complex system. This simplification itself is of considerable value by providing <em>modularity</em>, making it much easier to change the implementation of the service provided by the layer: as long as the layer provides the same service to the layer above it, and uses the same services from the layer below it, the remainder of the system remains unchanged when a layer&rsquo;s implementation is changed.</p><h4 id=protocol-layering>Protocol Layering<a hidden class=anchor aria-hidden=true href=#protocol-layering>#</a></h4><p>To provide structure to the design of network protocols, the network designers organize protocols in <strong>layers</strong>. <strong>Each protocol belongs to one of the layers</strong>. We are interested in the <strong>services</strong> that a layer offers to the layer above, <strong>service model</strong> of a layer.
When taken together, the protocols of the various layers are called the <strong>protocol stack</strong>. The Internet protocol stack consists of five layers:</p><ul><li>Application</li><li>Transport</li><li>Network</li><li>Link</li><li>Physical</li></ul><h5 id=application-layer>Application Layer<a hidden class=anchor aria-hidden=true href=#application-layer>#</a></h5><p>Where network applications and their applications-layer protocols reside.
The Internet&rsquo;s application layer includes many protocols: HTTP, SMTP, FTP, DNS.
An application-layer protocol is distributed over multiple end systems, with the application in one end system using the protocol to exchange packets of information with the application in another end system. This packet of information at the application layer is called <strong>message</strong>.</p><h5 id=transport-layer>Transport Layer<a hidden class=anchor aria-hidden=true href=#transport-layer>#</a></h5><p>It transports application-layer messages between application endpoints.
In the Internet there are two transport protocols: TCP and UDP.
TCP provides a connection-oriented service to its application: the service includes guaranteed delivery of application-layer messages to the destination and flow control unit. TCP also breaks long messages into shorter segments and provides a <strong>congestion-control mechanism</strong>, so that a source throttles its transmission rate when the network is congested.
HTTP and SMTP use TCP</p><p>UDP provides a connectionless service to its applications: it&rsquo;s a no-frills service that provides no guarantees, no reliability, no flow control and no congestion control.
A transport-layer packet is called <strong>segment</strong>
Skype uses UDP (speed required)</p><h5 id=network-layer>Network Layer<a hidden class=anchor aria-hidden=true href=#network-layer>#</a></h5><p>It is responsible for moving network-layer packets known as <strong>datagrams</strong> from one host to another.
The Internet&rsquo;s network layer includes the IP Protocol. There is only one IP Protocol and all the Internet components that have a network layer must run it.
The Internet&rsquo;s network layer also contains routing protocols that determine the routes that datagrams take between sources and destinations.
The Internet has many routing protocols.
Often it is simply referred to as the IP protocols, forgetting that it includes routing too.</p><h5 id=link-layer>Link Layer<a hidden class=anchor aria-hidden=true href=#link-layer>#</a></h5><p>To move a packet from one node to the next, the network layer relies on the services of the link layer.
The services provided by the link layer depend on the specific link-layer protocol that is employed over the link.
Examples are Ethernet, WiFi.
We will refer to the link-layer packets as <strong>frames</strong></p><h5 id=physical-layer>Physical Layer<a hidden class=anchor aria-hidden=true href=#physical-layer>#</a></h5><p>The job of the physical layer is to move the individual bits within the frame from one node to the next.
The protocols are link dependent and further depend of the actual transmission medium of the link.</p><h3 id=152-encapsulation>1.5.2 Encapsulation<a hidden class=anchor aria-hidden=true href=#152-encapsulation>#</a></h3><p>Routers and link-layer switches are both packet switches but routers and link-layer switches do not implement all of the layers in the protocol stack: link-layer switches implement Physical and Link while router add the Network Layer too.</p><p>From the Application Layer, the message passes to the transport layer, which appends additional information to it (the <strong>Header</strong>) that will be used by the receiver-side transport layer. The transport layer then adds its own header and passes the datagram to the link layer which adds it own link-layer header information.
Thus, we see that at each layer, a packet has two types of fields: <strong>header fields</strong> and a <strong>payload field</strong>, the payload typically being the packet from the layer above.</p><p>The process of encapsulation can be more complex: for example a large message may be divided into multiple transport-layer segments, which will be divided into multiple datagrams&mldr;.</p><h2 id=16-networks-under-attack>1.6 Networks Under Attack<a hidden class=anchor aria-hidden=true href=#16-networks-under-attack>#</a></h2><h3 id=malware>Malware<a hidden class=anchor aria-hidden=true href=#malware>#</a></h3><p>Along with all the good files we exchange on the Internet, come malicious software, collectively known as <strong>malware</strong> that can also enter and infect our devices.
Once a device infected, the malware can do all kinds of evil things: deleting files, install spyware&mldr;
A compromised host may also be enrolled in a network of thousands of similarly compromised devices, known as <strong>botnet</strong> which can be used for spam or distributed denial-of-service.
Much of the malware is <strong>self-replicating</strong>: it seeks entry into other hosts from the infected machines. Malware can spread in the from of a virus or a worm.</p><ul><li><strong>Viruses</strong> are malware that requires some form of user interaction to infect the user&rsquo;s device.</li><li><strong>Worms</strong> are malware that can enter a device without any explicit user interaction.</li></ul><h3 id=dos>DoS<a hidden class=anchor aria-hidden=true href=#dos>#</a></h3><p>Denial-of-Service attacks render a network, host, or other piece of infrastructure unusable by legittimate users. Most of them fall into one of the three categories:</p><ul><li><em>Vulnerability Attack</em>: a few well-crafted messages are sent to a vulnerable application or operating system running on the targeted host. The service might stop or the host might crash.</li><li><em>Bandwidth flooding</em>: a deluge of packets is sent to the targeted host, so many packets that the target&rsquo;s access link becomes clogged preventing legitimate packets from reaching the server</li><li><em>Connection flooding</em>: a large number of half-open or fully open TCP connections are established at the targeted host, which can become so bogged down that it stops accepting legitimate connections.</li></ul><p>In a <strong>distributed DoS</strong> (<strong>DDoS</strong>) attack the attacker controls multiple sources and has each source blast traffic at the target.</p><h3 id=sniffing>Sniffing<a hidden class=anchor aria-hidden=true href=#sniffing>#</a></h3><p>A passive receiver can record a copy of every packet that passes through the network. It is then called a <strong>packet sniffer</strong>.
Because packet sniffers are <em>passive</em> (they do not inject packets into the channel), they are difficult to detect. Some of the best defenses against packet sniffing involve cryptography.</p><h3 id=spoofing>Spoofing<a hidden class=anchor aria-hidden=true href=#spoofing>#</a></h3><p>The ability to inject packets into the Internet with a false source address is known as <strong>IP Spoofing</strong> and is but one of many ways in which one user can masquerade as another user.
To solve this problem we will need <em>end-point authentication</em>.</p><h3 id=the-history-of-the-internet-shaped-is-structure>The history of the Internet shaped is structure<a hidden class=anchor aria-hidden=true href=#the-history-of-the-internet-shaped-is-structure>#</a></h3><p>The Internet was originally designed to be based on the model of a <em>group of mutually trusting users attached to a transparent network</em>, a model in which there is no need for security. Many aspects of the original Internet architecture deeply reflect this notion of mutual trust, such as the ability for one to send a packet to any other user is the default rather than a requested/granted capability.
However today&rsquo;s Internet certainly does not involve &ldquo;mutually trusted users&rdquo;: communication among mutually trusted users is the exception rather the rule.</p><h2 id=history-of-computer-networking-and-the-internet>History of Computer Networking and the Internet<a hidden class=anchor aria-hidden=true href=#history-of-computer-networking-and-the-internet>#</a></h2><h1 id=chapter-2-application-layer>Chapter 2: Application Layer<a hidden class=anchor aria-hidden=true href=#chapter-2-application-layer>#</a></h1><p>Network applications are the <em>raison d&rsquo;être</em> of a computer network. They include text email, remote access to computers, file transfers, the WorldWideWeb (mid 90s), web searching, e-commerce, Twitter/Facebook, Amazon, Netflix, Youtube, WoW&mldr;</p><h2 id=21-principles-of-network-applications>2.1 Principles of Network Applications<a hidden class=anchor aria-hidden=true href=#21-principles-of-network-applications>#</a></h2><p>At the core of network application development is writing programs that run on different <strong>end systems</strong> and communicate with each over the network. The programs running on end systems might be different (server-client architecture) or identical (Peer-to-Peer architecture).
Importantly we write programs that run on end systems/hosts, not on network-core devices (routers/link-layer switches).</p><h3 id=211-network-application-architectures>2.1.1 Network Application Architectures<a hidden class=anchor aria-hidden=true href=#211-network-application-architectures>#</a></h3><p>From the application developer&rsquo;s perspective, the network architecture is fixed and provides a specific set of services to applications.
The <strong>application architecture</strong>, on the other hand, is chosen by him. In choosing the application architecture, a developer will likely draw one of the two predominant architectural paradigms used in modern network applications:</p><ul><li><strong>Client-server architecture</strong>: there is an always on host, called the <em>server</em> which serves requests from many other hosts, called <em>clients</em>: [Web Browser and Web Server]. Clients do not communicate directly with each other. The server has a fixed, well-known address, called an IP address that clients use to connect to him. Often, a single server host is incapable of keeping up with all the requests from clients, for this reason, a <strong>data center</strong>, housing a large number of hosts, is often used to create a powerful virtual server (via <em>proxyin</em>).</li><li><strong>P2P architecture</strong>: there is minimal or no reliance on dedicated servers in data centers, the application exploits direct communication between pairs of intermittently connected bots, called <em>peers</em>. They are end systems owned and controlled by users. [Bittorrent, Skype]. P2P applications provide <strong>self-scalability</strong> (the network load is distributed) They are also <strong>cost-effective</strong> since they don&rsquo;t require significant infrastructure and server bandwidth. P2P face challenges:<ol><li>ISP Friendly (asymmetric nature of residential ISPs)</li><li>Security</li><li>Incentives (convincing users to participate)</li></ol></li></ul><p>Some applications have hybrid architectures, such as for many instant messaging applications: a server keeps track of the IP addresses of users, but user-to-user messages are sent directly between users.</p><h3 id=212-processes-communicating>2.1.2 Processes Communicating<a hidden class=anchor aria-hidden=true href=#212-processes-communicating>#</a></h3><p>In the jargon of operating systems, it&rsquo;s not programs but <strong>processes</strong> that communicate. A process can be thought of as a program that is running within an end system.
Processes on two different end systems communicate with each other by exchanging <strong>messages</strong> across the computer network: a sending process creates and sends messages into the network, a receiving process receives these messages and possibly responds by sending messages back.</p><h4 id=client-and-server-processes>Client and Server Processes<a hidden class=anchor aria-hidden=true href=#client-and-server-processes>#</a></h4><p>A network application consists of pairs of processes that send messages to each other over a network. For each pair of communicating processes we label:</p><ul><li>the process that initiates the communication as the <strong>client</strong> [web browser]</li><li>the process that waits to be contacted to begin the session as the <strong>server</strong> [web server]</li></ul><p>This labels stand even for P2P applications in the <em>context of a communication session</em>.</p><h4 id=the-interface-between-the-process-and-the-computer-network>The Interface Between the Process and the Computer Network<a hidden class=anchor aria-hidden=true href=#the-interface-between-the-process-and-the-computer-network>#</a></h4><p>A process sends messages into, and receives messages from, the network through a software interface called a <strong>socket</strong>.
<strong>A socket is the interface between the application layer and the transport layer within a host</strong>, it is also referred to as the <strong>Application Programming Interface</strong> (<strong>API</strong>) between the application and the network.
The application developer has control of everything on the application-layer of the socket but has little control of the transport-layer side of the socket. The only control that he has over the transport-layer is:</p><ol><li>The choice of the transport protocol</li><li>Perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum segment sizes</li></ol><h4 id=addressing-processes>Addressing Processes<a hidden class=anchor aria-hidden=true href=#addressing-processes>#</a></h4><p>In order for a process running on one host to send packets to a process running on another host, the receiving process needs to have an address. To identify the receiving processes, two pieces of information need to be specified:</p><ol><li>The address of the host. In the Internet, the host is identified by its <strong>IP Address</strong>, a 32-bit (or 64) quantity that identifies the host uniquely.</li><li>An identifier that specifies the receiving process in the destination host: the destination <strong>port number</strong>. Popular applications have been assigned specific port numbers (web server -> 80)</li></ol><h3 id=213-transport-services-available-to-applications>2.1.3 Transport Services Available to Applications<a hidden class=anchor aria-hidden=true href=#213-transport-services-available-to-applications>#</a></h3><p>What are the services that a transport-layer protocol can offer to applications invoking it?</p><h4 id=reliable-data-transfer>Reliable Data Transfer<a hidden class=anchor aria-hidden=true href=#reliable-data-transfer>#</a></h4><p>For many applications, such as email, file transfer, web document transfers and financial applications, packet&rsquo;s drops and data loss can have devastating consequences. If a protocol provides guarantees that the data sent is delivered completely and correctly, it is said to provide <strong>reliable data transfer</strong>. The sending process can just pass its data into the socket and know with complete confidence that the data will arrive without errors at the receiving process.</p><h4 id=throughput>Throughput<a hidden class=anchor aria-hidden=true href=#throughput>#</a></h4><p>A transport-layer protocol could provide guaranteed available throughput at some specific rate. Applications that have throughput requirements are said to be <strong>bandwidth-sensitive applications</strong>.</p><h4 id=timing>Timing<a hidden class=anchor aria-hidden=true href=#timing>#</a></h4><p>A transport-layer protocol can also provide timing guarantees. Example: guarantees that every bit the sender pumps into the socket arrives at the receiver&rsquo;s socket no more than 100 msec later, interesting for real-time applications such as telephony, virtual environments&mldr;</p><h4 id=security>Security<a hidden class=anchor aria-hidden=true href=#security>#</a></h4><p>A transport-layer protocol can provide an application with one or more security services. It could encrypt all data transmitted by sending process and in the receiving host decrypt it.</p><h3 id=214-transport-services-provided-by-the-internet>2.1.4 Transport Services Provided by the Internet<a hidden class=anchor aria-hidden=true href=#214-transport-services-provided-by-the-internet>#</a></h3><p>The Internet makes two transport protocols available to applications: TCP and UDP.</p><h4 id=tcp-services>TCP Services<a hidden class=anchor aria-hidden=true href=#tcp-services>#</a></h4><p>TCP includes a connection-oriented service and a reliable data transfer service:</p><ul><li><strong>Connection-oriented service</strong>: client and server exchange transport-layer control information <em>before</em> the application-level messages begin to flow. This so-called <em>handshaking</em> procedure alerts the client and server, allowing them to prepare for an onslaught of packets. Then a <strong>TCP connection</strong> is said to exist between the sockets of the two processes. When the application finishes sending messages, it must tear down the connection</li></ul><h5 id=securing-tcp>SECURING TCP<a hidden class=anchor aria-hidden=true href=#securing-tcp>#</a></h5><p>Nether TCP nor UDP provide encryption. Therefore the Internet community has developed an enhancement for TCP called <strong>Secure Sockets Layer (SSL)</strong>, which not only does everything that traditional TCP does but also provides critical process-to-process security services including <em>encryption</em>, <em>data integrity</em> and <em>end-point authentication</em>. It is not a third protocol, but an enhancement of TCP, <strong>the enhancement being implemented in the application layer</strong> in both the client and the server side of the application (highly optimized libraries exist). SSL has its own socket API, similar to the traditional one. Sending processes passes cleartext data to the SSL socket which encrypts it.</p><ul><li><strong>Reliable data transfer service</strong> The communicating processes can rely on TCP to deliver all data sent without error and in the proper order.</li></ul><p>TCP also includes a <strong>congestion-control mechanism</strong>, a service for the general welfare of the Internet rather than for the direct benefit of the communicating processes. It throttles a sending process when the network is congested between sender and receiver.</p><h4 id=udp-services>UDP Services<a hidden class=anchor aria-hidden=true href=#udp-services>#</a></h4><p>UDP is a no-frills, lightweight transport protocol, providing minimal services. It is connectionless, there&rsquo;s no handshaking. The data transfer is unreliable: there are no guarantees that the message sent will ever reach the receiving process. Furthermore messages may arrive out of order. UDP does not provide a congestion-control mechanism neither.</p><h4 id=services-not-provided-by-internet-transport-protocols>Services Not Provided by Internet Transport Protocols<a hidden class=anchor aria-hidden=true href=#services-not-provided-by-internet-transport-protocols>#</a></h4><p>These two protocols do not provide timing or throughput guarantees, services not provided by today&rsquo;s Internet transport protocols. We therefore design applications to cope, to the greatest extent possible, with this lack of guarantees.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-app_tras.png alt="app tras"></p><h3 id=215-application-layer-protocols>2.1.5 Application-Layer Protocols<a hidden class=anchor aria-hidden=true href=#215-application-layer-protocols>#</a></h3><p>An <strong>application-layer protocol</strong> defines how an application&rsquo;s processes, running on different end systems, pass messages to each other. It defines:</p><ul><li>The type of the messages exchanged (request/response)</li><li>The syntax of the various message types</li><li>The semantics of the fields (meaning of the information in fields)</li><li>The rules for determining whem and how a process sends messages and responds to messages</li></ul><h2 id=22-the-web-and-http>2.2 The Web and HTTP<a hidden class=anchor aria-hidden=true href=#22-the-web-and-http>#</a></h2><p>In the early 1990s, a major new application arrived on the scene: the World Wide Web (Berners-Lee 1994), the first application that caught the general public&rsquo;s eye.
The Web operates <em>on demand</em>: users receives what they want, when they want it.
It is enormously easy for an individual to make information available over the web, hyperlinks and search engines help us navigate through the ocean of web sites&mldr;</p><h3 id=221-overview-of-http>2.2.1 Overview of HTTP<a hidden class=anchor aria-hidden=true href=#221-overview-of-http>#</a></h3><p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web&rsquo;s application-layer protocol is a the heart of the Web. It is implemented in two programs: a client program and a server program.
The two programs talk to each other by exchanging HTTP messages.
A <strong>Web page</strong> (or document) consists of objects. An <strong>object</strong> is simply a file (HTML file, jpeg image&mldr;) that is <em>addressable by a single URL</em>.
Most Web pages consist of a <strong>base HTML file</strong> and several referenced objects. The HTML file references the other objects in the page with the objects&rsquo; URLs.
Each URL has two components: the hostname of the server that houses the object and the object&rsquo;s path name.
<strong>Web Browsers</strong> implement the client side of HTTP.
<strong>HTTP</strong> uses TCP as its underlying transport protocol.
The server sends requested files to clients without storing any state information about the client: it is a <strong>stateless protocol</strong></p><h3 id=222-non-persistent-and-persistent-connections>2.2.2 Non-Persistent and Persistent Connections<a hidden class=anchor aria-hidden=true href=#222-non-persistent-and-persistent-connections>#</a></h3><p>In many Internet applications, the client and server communicate for an extended period of time, depending on the application and on how the application is being used, the series of requests may be back-to-back, periodically at regular intervals or intermittently. When this is happening over TCP, the developer must take an important decision: should each request/response pair be sent over a <em>separate</em> TCP connection or should all of the requests and their corresponding responses be sent over the <em>same</em> TCP connection?
In the former approach, the application is said to use <strong>non-persistent connections</strong> and in the latter it is said to use <strong>persistent connections</strong>
By default HTTP uses non-persistent connections but can be configured to be use persistent connections.
To estimate the amount of time that elapses when a client requests the base HTML file until the entire file is received by the client we define the <strong>round-trip time</strong> (<strong>RTT</strong>) which is the time it takes for a small packet to travel from client to server and then back to the client.</p><h4 id=http-with-non-persistent-connections>HTTP with Non-Persistent Connections<a hidden class=anchor aria-hidden=true href=#http-with-non-persistent-connections>#</a></h4><p>For the page and each object it contains, a TCP connection must be opened (handshake request, handshake answer), we therefore observe an addition RTT, and for each object we will have a request followed by the reply
This model can be expensive on the server side: a new connection needs to be established for each requested object, for each connection a TCP buffer must be allocated along some memory to store TCP variables.</p><h4 id=http-with-persistent-connections>HTTP with Persistent Connections<a hidden class=anchor aria-hidden=true href=#http-with-persistent-connections>#</a></h4><p>The server leaves the TCP connection open after sending a response, subsequent requests and responses between the same client and server will be sent over the same connection. In particular an entire web page (text + objects) ca be sent over a single persistent TCP connection, multiple web pages residing on the same server can be sent from the server to the same client over a single persistent TCP connection.
<strong>These requests can be make back-to-back</strong> without waiting for replies to pending requests (<strong>pipelining</strong>).
When the server receives back-to-back requests, it sends the objects back-to-back.
If connection isn&rsquo;t used for a pre-decided amount of time, it will be closed.</p><h3 id=223-http-message-format>2.2.3 HTTP Message Format<a hidden class=anchor aria-hidden=true href=#223-http-message-format>#</a></h3><p>Two types of HTTP messages:</p><h4 id=http-request-message>HTTP Request Message<a hidden class=anchor aria-hidden=true href=#http-request-message>#</a></h4><pre tabindex=0><code>GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
</code></pre><ul><li>Ordinary ASCII text</li><li>First line: <strong>request line</strong></li><li>Other lines: <strong>header lines</strong></li><li>the first lines has 3 fields: method field, URL field, HTTP version field:<ul><li>method field possible values: <code>GET, POST, HEAD, PUT, DELETE</code></li></ul></li></ul><p>The majority of HTTP requests use the GET method, used to request an object.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-http_request.png alt="http requests"></p><p>The entity body (empty with <code>GET</code>) is used by the <code>POST</code> method, for example for filling out forms. The user is still requesting a Web page but the specific contents of the page depend on what the user entered into the form fields. When <code>POST</code> is used, the entity body contains what the user entered into the form fields.
Requests can also be made with <code>GET</code> including the inputted data in the requested URL.
The <code>HEAD</code> method is similar to <code>GET</code>, when a server receives it, it responds with an HTTP message but it leaves out the requested object. It is often used for debugging.
<code>PUT</code> is often used in conjunction with web publishing tools, to allow users to upload an object to a specific path on the web servers.
Finally, <code>DELETE</code> allows a user or application to delete an object on a web server.</p><h4 id=http-response-message>HTTP Response Message<a hidden class=anchor aria-hidden=true href=#http-response-message>#</a></h4><p>A typical HTTP response message:</p><pre tabindex=0><code>HTTP/1.1 200 OK
Connection: close
Date: ...
Server: ...
Last-Modified: ...
Content-Length: ...
Content-Type: text/html

(data data data data data ...)
</code></pre><ul><li>Status line: protocol version, status code, corresponding status message</li><li>six header lines:<ul><li>the connection will be closed after sending the message</li><li>date and time when the response was created (when the server retrieves the object from the file system, insert object in the message, sends the response message)</li><li>Type of the server / software</li><li>Last modified: useful for object caching</li><li>Content-Length: number of bytes in the object</li><li>Content-Type</li></ul></li><li>entity body: contains the requested object itself (data)</li></ul><p>Some common status codes:</p><ul><li><code>200 OK</code>: request succeeded, information returned</li><li><code>301 Moved Permanently</code>: the object has moved, the new location is specified in the header of the response</li><li><code>400 Bad Request</code>: generic error code, request not understood</li><li><code>404 Not Found</code>: The requested document doesn&rsquo;t exist on the server</li><li><code>505 HTTP Version Not Supported</code>: The requested HTTP protocol version is not supported by the server</li></ul><h3 id=224-user-server-interaction-cookies>2.2.4 User-Server Interaction: Cookies<a hidden class=anchor aria-hidden=true href=#224-user-server-interaction-cookies>#</a></h3><p>An HTTP server is <em>stateless</em> in order to simplify server design and improves performances. A website can identify users using <strong>cookies</strong>.
Cookie technology has 4 components:</p><ol><li>Cookie header in HTTP response message</li><li>Cookie header in HTTP request message</li><li>Cookie file on the user&rsquo;s end-system managed by the browser</li><li>Back-end database at the Website</li></ol><p>User connects to website using cookies:</p><ul><li>Server creates a unique identification number and creates an entry in its back-end database indexed by the identification number
-server responds to user&rsquo;s browser including in the header: <code>Set-cookie: identification number</code></li><li>The browser will append to the cookie file the hostname of the server and the identification number header</li><li>Each time the browser will request a page, it will consult the cookie file, extract the identification number for the site and put a cookie header line including the identification number</li></ul><p>The server can track the user&rsquo;s activity: it knows exactly what pages, in which order and at what times that identification number has visited. This is also why cookies are controversial: a website can learn a lot about a user and sell this information to a third party.</p><p>Therefore <strong>cookies can be used to create a user session layer on top of stateless HTTP</strong>.</p><h3 id=225-web-caching>2.2.5 Web Caching<a hidden class=anchor aria-hidden=true href=#225-web-caching>#</a></h3><p>A <strong>Web cache</strong>, also called <strong>proxy server</strong> is a network entity that satisfies HTTP requests on behalf of an origin Web server. It has its own disk storage and keeps copies of recently requested objects in this storage.</p><ol><li>The browser establishes a TCP connection to the web cache, sending an HTTP request for the object to the Web cache.</li><li>The web cache checks to see if it has a copy of the object stored locally. If yes, it will return it within an HTTP response message to the browser.</li><li>If not, the Web cache opens a TCP connection to the origin server, which responds with the requested object.</li><li>The Web caches receives the object, stores a copy in its storage and sends a copy, within an HTTP response message, to the browser over the existing TCP connection.</li></ol><p>Therefore a <strong>cache is both a server and a client at the same time</strong>.
Usually caches are purchased and installed by ISPs.
They can substantially reduce the response time for a client request and substantially reduce traffic on an institution&rsquo;s access link to the Internet.</p><p>Through the use of <strong>Content Distribution Networks (CDNs)</strong> web caches are increasingly playing an important role in the Internet. A CDN installs many geographically distributed caches throughout the Internet, localizing much of the traffic.</p><h3 id=226-the-conditional-get>2.2.6 The Conditional <code>GET</code><a hidden class=anchor aria-hidden=true href=#226-the-conditional-get>#</a></h3><p>Caches introduce a new problem: what if the copy of an object residing in the cache is stale?
The <strong>conditional GET</strong> is used to verify that an object is up to date.
An HTTP request message is a conditional get if</p><ol><li>the request message uses the <code>GET</code> method</li><li>the request message includes an <code>If-modified-since:</code> header line.</li></ol><p>A conditional get message is sent from the cache to server which responds only if the object has been modified.</p><h2 id=25-dns---the-internets-directory-service>2.5 DNS - The Internet&rsquo;s Directory Service<a hidden class=anchor aria-hidden=true href=#25-dns---the-internets-directory-service>#</a></h2><p>One identifier for a host is its <strong>hostname</strong> [<code>cnn.com</code>, <code>www.yahoo.com</code>]. Hostnames are mnemonic and therefore used by humans. Hosts are also identified by <strong>IP addresses</strong>.</p><h3 id=251-services-provided-by-dns>2.5.1 Services provided by DNS<a hidden class=anchor aria-hidden=true href=#251-services-provided-by-dns>#</a></h3><p>Routers and use IP addresses. The Internet&rsquo;s <strong>domain name system (DNS)</strong> translates hostnames to IP addresses. The DNS is:</p><ol><li>A distributed database implemented in a hierarchy of <strong>DNS Servers</strong></li><li>An application-layer protocol that allows hosts to query the distributed database.</li></ol><p>DNS servers are often UNIX machines running the <strong>B</strong>erkeley <strong>I</strong>nternet <strong>N</strong>ame <strong>D</strong>omaine (BIND) software.</p><p><strong>DNS runs over UDP and uses port 53</strong>
It is often employed by other application-layer protocols (HTTP, FTP&mldr;) to translate user-supplied hostnames to IP addresses.</p><p>How it works:</p><ul><li>The user machine runs the client side of the DNS application</li><li>The browser extracts <code>www. xxxxx . xxx</code> from the URL and passes the hostname to the client side of the DNS application</li><li>The DNS sends a query containing the hostname to a DNS server</li><li>The DNS client eventually receives a reply including the IP address for the hostname</li><li>The browser can initiate a TCP connection.</li></ul><p><strong>DNS adds an additional delay</strong></p><p>DNS provides other services in addition to translating hostnames to IP addresses:</p><ul><li><strong>host aliasing</strong>: a host with a complicated hostname can have more alias names. The original one is said to be a <strong>canonical hostname</strong>.</li><li><strong>mail server aliasing</strong>: to make email servers&rsquo; hostnames more mnemonic. This also allows for an e-mail server and an Web server to have the same hostname.</li><li><strong>load distribution</strong>: replicated servers can have the same hostname. In this case, a set of IP addresses is associated with one canonical hostname. When a client make a DNS query for a name mapped to a set of addresses, the server responds with the entire set, but rotates the ordering within each reply.</li></ul><h3 id=252-overview-of-how-dns-works>2.5.2 Overview of How DNS Works<a hidden class=anchor aria-hidden=true href=#252-overview-of-how-dns-works>#</a></h3><p>From the perspective of the invoking application in the user&rsquo;s host, DNS is a black box providing a simple, straightforward translation service.
Having one single global DNS server would be simple, but it&rsquo;s not realistic because it would a <strong>single point of failure</strong>, it would have an impossible <strong>traffic volume</strong>, it would be <strong>geographically too distant</strong> from some querying clients, its <strong>maintenance</strong> would be impossible.</p><h4 id=a-distributed-hierarchical-database>A Distributed, Hierarchical Database<a hidden class=anchor aria-hidden=true href=#a-distributed-hierarchical-database>#</a></h4><p>The DNS uses a large number of servers, organized in a hierarchical fashion and distributed around the world.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-dns-servers.png alt="dns servers"></p><p>The three classes of DNS servers:</p><ul><li><strong>Root DNS servers</strong>: In the Internet there are 13 root DNS servers, most hosted in North America, each of these is in reality a network of replicated servers, for both security and reliability purposes (total: 247)</li><li><strong>Top-level domain (TLD) servers</strong>: responsible for top-level domains such as com org net edu and govand all of the country top-level domains uk fr jp</li><li><strong>Authoritative DNS servers</strong>: every organization with publicly accessible hosts must provide publicly accessible DNS records that map the names of those hosts to IP addresses. An organization can choose to implement its own authoritative DNS server or to pay to have the records stored in an authoritative DNS of some service provider.</li></ul><p>Finally there are <strong>local DNS servers</strong> which is central to the DNS architecture. They are hosted by ISPs. When a hosts connects to one of these, the local DNS server provides the host with the IP addresses of one or more of its local DNS servers. Requests can ho up to the root DNS servers and back down.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-distributedDNS.png alt="distriuted dns"></p><p>We can have both <strong>recursive</strong> and <strong>iterative queries</strong>.
In <strong>recursive queries</strong> the user sends the request its nearest DNS which will ask to a higher-tier server, which will ask to lower order&mldr; the chain goes on until it reaches a DNS that can reply, the reply will follow the inverse path that the request had.
In <strong>iterative queries</strong> the same machine sends requests and receives replies.
Any DNS can be iterative or recursive or both.</p><h4 id=dns-caching>DNS Caching<a hidden class=anchor aria-hidden=true href=#dns-caching>#</a></h4><p>DNS extensively exploits DNS caching in order to improve the delay performance and to reduce the number of DNS messages ricocheting around the Internet.
In a query chain, when a DNS receives a DNS reply it can cache the mapping in its local memory.</p><h3 id=253-dns-records-and-messages>2.5.3 DNS Records and Messages<a hidden class=anchor aria-hidden=true href=#253-dns-records-and-messages>#</a></h3><p>The DNS servers that implement the DNS distributed database store <strong>resource records (RRs)</strong> including RRs that provide hostname-to-IP address mappings.
Each DNS reply messages carries one or more resource records.</p><p>A resource record is a four-tuple that contains the fields: <code>(Name, Value, Type, TTL)</code>
<code>TTL</code> is the time to live of the resource record (when a resource should be removed from a cache). The meaning of <code>Name</code> and <code>Value</code> depend on <code>Type</code>:</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>A</td><td>a hostname</td><td>IP address</td></tr><tr><td>NS</td><td>a domain (foo.com)</td><td>hostname of an authoritative DNS server which knows how to obtain the IP addresses for hosts in the domain. Used to route queries further along in the query chain</td></tr><tr><td>CNAME</td><td>a alias name</td><td>canonical hostname for the name in Name</td></tr><tr><td>MX</td><td>alias hostname</td><td>canonical hostname of a mail server that has an alias hostname Name</td></tr></tbody></table><h4 id=dns-messages>DNS Messages<a hidden class=anchor aria-hidden=true href=#dns-messages>#</a></h4><p>The only types of DNS messages are DNS queries and reply messages. They have the same format:</p><ul><li>first 12 bytes in the <em>header section</em>: 16-bit number identifying the query, which will be copied into the reply query so that the client can match received replies with sent queries. 1 bit query/reply flag (0 query, 1 reply). 1 bit flag authoritative flag set in reply messages when DNS server is an authoritative for a queried name. 1 bit recursion flag if the client desires that the server performs recursion when it doesn&rsquo;t have a record, 1 bit recursion-available field is set in the reply if the DNS server supports recursion</li><li><em>question section</em>: information about the query: name field containing the name being queried, type field</li><li><em>answer section</em>: resource records for the name originally queried: Type, Value, TTL. Multiple RRs can be returned if the server has multiple IP addresses</li><li><em>authority section</em>: records for other authoritative servers.</li><li><em>additional section</em>: other helpful records: canonical hostnames&mldr;</li></ul><h4 id=inserting-records-into-the-dns-database>Inserting Records into the DNS Database<a hidden class=anchor aria-hidden=true href=#inserting-records-into-the-dns-database>#</a></h4><p>We created a new company. Next we register th domain name <code>newcompany.com</code> at a registrar. A <strong>registrar is a commercial entity that verifies the uniqueness of the domain name, enters it into the DNS database and collects a small fee for these services</strong>. When we register the address, <strong>we need the provide the registrar with the IP address of our primary and secondary authoritative DNS servers</strong>, that will make sure that a Type NS and a Type A records are entered into the TLD com servers for our two DNS servers.</p><h5 id=focus-on-security-dns-vulnerabilities>Focus on security: DNS vulnerabilities<a hidden class=anchor aria-hidden=true href=#focus-on-security-dns-vulnerabilities>#</a></h5><ul><li>DDoS bandwidth-flooding attack</li><li>MITM: the mitm answers queries with false replies tricking the user into connecting to another server.</li><li>The DNS infrastructure can be used to launch a DDoS attack against a targeted host</li></ul><p>To date, there hasn&rsquo;t been an attack that that has successfully impeded the DNS service, DNS has demonstrated itself to be surprisingly robust against attacks. However there have been successful reflector attacks, these can be addressed by appropriate configuration of DNS servers.</p><h2 id=26-peer-to-peer-applications>2.6 Peer-to-Peer Applications<a hidden class=anchor aria-hidden=true href=#26-peer-to-peer-applications>#</a></h2><h3 id=261-file-distribution>2.6.1 File Distribution<a hidden class=anchor aria-hidden=true href=#261-file-distribution>#</a></h3><p>In P2P file distribution, each peer can redistribute any portion of the file it has received to any peers, thereby assisting the server in the distribution process. As of 2012 the most popular P2P file distribution protocol is BitTorrent, developed by Bram Cohen.</p><h4 id=scalability-of-p2p-architectures>Scalability of P2P architectures<a hidden class=anchor aria-hidden=true href=#scalability-of-p2p-architectures>#</a></h4><p>Denote the upload rate of the server&rsquo;s access link by $u_s$, the upload rate of the <em>i</em>th peer&rsquo;s access link by $u_i$ and the download rate of the <em>i</em>th access link by $d_i$, tthe size of the to be distributed in bits ()
Comparison client-server and P2P.</p><h4 id=client-server>Client-Server<a hidden class=anchor aria-hidden=true href=#client-server>#</a></h4><p>The server must transmit one copy of the file to <em>N</em> peers, thus it transmits *NF *bits. The time to distribute the file is at least <strong>NF/u_s</strong>.
Denote $d_min = min{ d_i }$ the link with the slowest download rate cannot obtain all <em>F</em> bits in less than $F/d_min$ seconds
Therefore:
$$ D_{cs} \geq \max \left{ \frac{NF}{u_s} , \frac{F}{d_min} \right} $$</p><h4 id=p2p>P2P<a hidden class=anchor aria-hidden=true href=#p2p>#</a></h4><p>When a peer receives some file data, it can use its own upload capacity to redistribute the data to other peers.</p><ul><li>At the beginning of the distribution only the server has the file. It must send all the bits at least once. $D \geq F/u_s$</li><li>The peer with the lowest download rate cannot obtain all <em>F</em> bits of the file in less than $F/d_min $ seconds.</li><li>The total upload capacity of the system is equal to the summation of the upload rates of the server and of all the peers. The system must upload <em>F</em> bits to <em>N</em> peers, thus delivering a total of <em>NF</em> bits which can&rsquo;t be done faster that $u_total$.</li></ul><p>We obtain:
$$ D_{P2P} = \max \left{ \frac{F}{u_s} , \frac{F}{d_{min}} , \frac{NF}{u_s + \sum_{i=1}^N u_j} \right} $$</p><h4 id=bittorrent>BitTorrent<a hidden class=anchor aria-hidden=true href=#bittorrent>#</a></h4><p>In BitTorrent the collection of all peers participating in the distribution of a particular file is called a <em>torrent</em>. Peers in a torrent download equal-size <em>chunks</em> of the file from one another with a typical chunk size of 256 KBytes.
At the beginning a peer has no chunks, it accumulates more and more chunks over time. While it downloads chunks it also uploads chunks to other peers. Once a peer has acquired the entire file it may leave the torrent or remain in it and continue to upload chunks to other peers (becoming a <em>seeder</em>). Any peer can leave the torrent at any time and later rejoin it at anytime as well.</p><p>Each torrent has an infrastructure node called a <em>tracker</em>: when a peer joins a torrent, it registers itself with the tracker and periodically informs it that it is still in the torrent. The tracker keeps track of the peers participating in the torrent. A torrent can have up to thousands of peers participating at any instant of time.</p><p>User joins the torrent, the tracker randomly selects a subset of peers from the set of participating peers. User establishes concurrent TCP connections with all of these peers, called <em>neighboring peers</em>. The neighboring peers can change over time.
The user will ask each of his neighboring peers for the list of chunks they have (one list per neighbor).
The user starts downloading the chunks that have the fewest repeated copies among the neighbors (<strong>rares first</strong> technique). In this manner the rarest chunks get more quickly redistributed, roughly equalizing the numbers of copies of each chunk in the torrent.</p><p>Every 10 seconds the user measures the rate at which she receives bits and determines the four peers that are sending to her at the highest rate. It then reciprocates by sending chunks to these same four peers. The four peers are called <strong>unchocked</strong>. Every 30 seconds it also choses one additional neighbor and sends it chunks. These peers are called <strong>optmistically unchocked</strong>.</p><h3 id=262-distributed-hash-tables-dhts>2.6.2 Distributed Hash Tables (DHTs)<a hidden class=anchor aria-hidden=true href=#262-distributed-hash-tables-dhts>#</a></h3><p>How to implement a simple database in a P2P network?
In the P2P system each peer will only hold a small subset of the totality of the (key, value) pairs. Any peer can query the distributed database with a particular key, the database will locate the peers that have the corresponding pair and return the pair to querying peer. Any peer can also insert a new pair in the databse. Such a distributed database is referred to as a <strong>distributed hash table (DHT)</strong>.
In a P2P file sharing application a DHT can be used to store the chunks associated to the IP of the peer in possession of them.</p><h6 id=an-approach>An approach:<a hidden class=anchor aria-hidden=true href=#an-approach>#</a></h6><p>Let&rsquo;s assign an identifier to each peer, where the identifier is an integer in the range <strong><code>[0, 2^n -1]</code></strong> for some fixed <strong><code>n</code></strong>. Such an identifier can be expressed by a <strong><code>n-bit</code></strong> representation. A hash function is used to transform non-integer values into integer values. We suppose that this function is available to all peers.
<strong>How to assign keys to peers?</strong> We assign each <code>(key,value)</code> pair to the peer <em><strong>whose identifier is the closest to key</strong></em>, which is the identifier defined as <em><strong>the closest successor of the key</strong></em>.
To avoid having each peer keeping track of all other peers (scalability issue) we use</p><h4 id=circular-dht>Circular DHT<a hidden class=anchor aria-hidden=true href=#circular-dht>#</a></h4><p>If we organize peers into a circle, each peer only keeps track of its immediate successor and predecessor <strong>(modulo <code>2^n</code>)</strong>. This circular arrangement of peers is a special case of an <strong>overlay network</strong>: the peers form an abstract logical network which resides above the &ldquo;underlay&rdquo; computer network, the overlay links are not physical but virtual liaisons between pairs of peers. A single overlay link typically uses many physical links and physical routers in the underlying network.</p><p>In the circle a peer asks &ldquo;who is responsible for key <em>k</em>?&rdquo; and it sends the message clockwise around the circle. Whenever a peer receives such message, it knows the identifier of its predecessor and predecessor, it can determine whether it is responsible (closest to) for the key in question. If not, it passes the message to its successor. When the message reaches the peer responsible for the key, it can send a message back to the querying peer indicating that it is responsible for that key.
Using this system <strong><code>N/2*</code></strong> messages are sent on average <strong>(N = number of peers)</strong>. In designing a DHT there is always a tradeoff between the number of neighbors for each peer and the number of DHT messages needed to resolve a single query. (1 message if each peer keeps track of all other peers; <strong><code>N/2</code></strong> messages if each knows only 2 neighbors).
To improve our circular DHT we could add shortcuts so that each peer not only keeps track of its immediate successor and predecessor but also of relatively small number of shortcut peers scattered around the circle.
<strong>How many shortcut neighbors?</strong> Studies show that DHT can be designed so that the number of neighbors per peer as well as the number of messages per query is <strong><code>O(log *N*)</code> (<code>N</code> the number of peers)</strong>.</p><h4 id=peer-churn>Peer Churn<a hidden class=anchor aria-hidden=true href=#peer-churn>#</a></h4><p>In a P2P system, a peer can come or go without warning. To keep the DHT overlay in place in presence of a such peer churn we require each peer to keep track (know to IP address) of its predecessor and successor, and to periodically verify that its two successors are alive.
If a peer abruptly leaves, its successor and predecessor need to update their information. The predecessor replaces its first successor with its second successor and ask it for the identifier and IP address of its immediate successor.</p><p>What if a peer joins? If it only knows one peer, it will ask him what will be his predecessor and successor. The message will reach the predecessor which will send the new arrived its predecessor and successor information. The new arrived can join the DHT making its predecessor successor its own successor and by notifying its predecessor to change its successor information.</p><h2 id=27-socket-programming-creating-network-applications>2.7 Socket Programming: Creating Network Applications<a hidden class=anchor aria-hidden=true href=#27-socket-programming-creating-network-applications>#</a></h2><p>Only code explication &mdash;-> skipping</p><h1 id=chapter-3-transport-layer>Chapter 3: Transport Layer<a hidden class=anchor aria-hidden=true href=#chapter-3-transport-layer>#</a></h1><h2 id=31-introduction-and-transport-layer-services>3.1 Introduction and Transport-Layer Services<a hidden class=anchor aria-hidden=true href=#31-introduction-and-transport-layer-services>#</a></h2><p>A transport-layer protocol provides for <strong>logical communication</strong> (as if the hosts running the processes were directly connected) between application processes running on different hosts. Application processes use the logical communication provided by the transport layer to send messages to each other, free from the worry of the details of the physical infrastructure used.
<strong>Transport-layer protocols are implemented in the end systems but not in network routers</strong>.
On the sending side, the transport layer converts the application messages into transport-layer packets, known as transport-layer <strong>segments</strong>. This is done by breaking them into smaller chunks and adding a transport-layer header to each chunk. The transport-layer then passes the segment to the network-layer packet at the sending end-system.
On the receiving side, the network layer extracts the transport-layer segment from the datagram and passes the segment up to the transport-layer which then processes the received segment, making the data in the segment available to the received application.</p><h3 id=311-relationship-between-transport-and-network-layers>3.1.1 Relationship Between Transport and Network Layers<a hidden class=anchor aria-hidden=true href=#311-relationship-between-transport-and-network-layers>#</a></h3><p>A transport-layer protocol provides logical communication between <strong><em>processes</em></strong> running on different hosts. Whereas a network-layer protocol provides logical communication between <strong><em>hosts</em></strong>.</p><h3 id=312-overview-of-the-transport-layer-in-the-internet>3.1.2 Overview of the Transport Layer in the Internet<a hidden class=anchor aria-hidden=true href=#312-overview-of-the-transport-layer-in-the-internet>#</a></h3><p>A TCP/IP network (such as the Internet) makes two distinct transport-layer protocols available to the application layer:</p><ul><li><strong>UDP</strong> [ <strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol], which provides an unreliable, connectionless service to the invoking application</li><li><strong>TCP</strong> [<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol] which provides a reliable, connection-oriented service to the invoking application.</li></ul><p>We need to spend a few words on the network-layer protocol: the Internet network-layer protocol is the IP (Internet Protocol). It provides a logical communication between hosts. The IP service model is a <strong>best-effort delivery service</strong>: it makes the best effort to deliver segments between hosts, <em>but it <strong>doesnt</strong> provide guarantees</em>:</p><ul><li>it doesn&rsquo;t guarantee segment <strong>delivery</strong></li><li>it doesn&rsquo;t guarantee <strong>orderly</strong> delivery of segments</li><li>it doesn&rsquo;t guarantee the <strong>integrity</strong> of the data in the segments</li></ul><p>Thus IP is said to be an <strong>unreliable service</strong>.
Every host has <strong>at least one network-layer address</strong> a so-called IP address.</p><p>UDP and TCP extend IP&rsquo;s delivery service between 2 end systems to a delivery service between two processes running on the end systems.
Extend host-to-host delivery to process-to-process delivery is called <strong>transport-layer multiplexing and demultiplexing</strong>.
UDP provides process-to-process delivery and error checking services. Therefore it is an <strong>unreliable service</strong>.
TCP provides <strong>reliable data transfer</strong> using flow control, sequence numbers, acknowledgements and timers. <strong>TCP thus converts IP&rsquo;s unreliable service between end systems into a reliable data transport service between processes</strong>.
TCP also provides <strong>congestion control</strong>, a service not really provided to the invoking application as it is to the Internet as a whole: <strong>it prevents any TCP connection from swamping the links and routers between communication hosts with an excessive amount of traffic giving each connection traversing a congested link an equal share of the bandwidth.</strong></p><h2 id=32-multiplexing-and-demultiplexing>3.2 Multiplexing and Demultiplexing<a hidden class=anchor aria-hidden=true href=#32-multiplexing-and-demultiplexing>#</a></h2><p>Here we&rsquo;ll cover multiplexing & demultiplexing in the context of the Internet but <strong>a multiplexing/demultiplexing service is needed for all computer networks</strong>.</p><ul><li>The job of delivering the data in a transport-layer segment to the correct socket is called <strong>demultiplexing</strong>.</li><li>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (which will be used in demultiplexing) to create segments and passing the segments to the networks layer is called <strong>multiplexing</strong>.</li></ul><p>Therefore sockets need to have unique identifiers and each segment needs to have special fields that indicate the socket to which the segment is delivered. These fields are the <strong>source port number field</strong> and the <strong>destination port number field</strong>. Each port number is a <strong>16-bit number</strong> ranging from 0 to 65535.
Port numbers ranging from 0 to 1023 are called <strong>well-known port numbers</strong> and are restricted, reserved for us by well-known application protocols such as HTTP (80) and FTP (21). Designing an application, we should assign it a port number.</p><h4 id=connectionless-multiplexing-and-demultiplexing>Connectionless Multiplexing and Demultiplexing<a hidden class=anchor aria-hidden=true href=#connectionless-multiplexing-and-demultiplexing>#</a></h4><p>A UDP socket is fully identified by the <strong>two-tuple</strong>:
<code>(destination IP address , destination port number)</code>
therefore if two UDP segments have different source IP address and/or source port numbers but have the same destination IP address and destination port number, than the two segments will be directed to the same destination process via the same destination socket.
The source port number serves as part of the <strong><code>return address</code></strong>.</p><h4 id=connection-oriented-multiplexing-and-demultiplexing>Connection-oriented Multiplexing and Demultiplexing<a hidden class=anchor aria-hidden=true href=#connection-oriented-multiplexing-and-demultiplexing>#</a></h4><p>A TCP socket is identified by the <strong>four-tuple</strong>:
<code>(source IP address, source port number, destination IP address, destination port number)</code>
When a TCP segment arrives from the network to a host, the <strong>host uses all four values to demultiplex the segment to the appropriate socket</strong>.
Two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP carrying the original connection establishment request) be directed to two different sockets.</p><p>Routine:</p><ul><li>The TCP server application always has a <strong>welcoming socket</strong> that waits for connection establishment requests from TCP clients on port number <code>X</code></li><li>The TCP client creates a socket and sends a connection <strong>establishment request</strong> (a TCP segment including destination port, source port number and <em>a special connection-establishment bit set in the TCP header</em>)</li><li>The server OS receives the incoming connection-request segment on port <code>X</code>, it locates the server process that is waiting to accept a connection on port number <code>X</code>, then creates <strong>a new socket</strong> which will be identified by
<code>(source port number in the segment (cleint), IP address of source host (client), the destination port number in the segment (its own), its own IP address)</code></li><li>With the TCP connection in place, client and server can now send data to each other</li></ul><p>The server may support many simultaneous TCP connection sockets, with each socket attached to a process and each socket identified by its own four-tuple.
When a TCP segment arrives at the host, all the fours fields are used to demultiplex the segment to the appropriate socket.</p><h5 id=port-scanning>Port Scanning<a hidden class=anchor aria-hidden=true href=#port-scanning>#</a></h5><p>Can be used both by attackers and system administrator to find vulnerabilities in the target or to know network applications are running in the network.
The most used port scanner is <strong>nmap</strong> free and open source.
For TCP it scans port looking for port accepting connections, for UDP looking for UDP ports that respond to transmitted UDP segments.
It then returns a list of open, closed or unreachable ports.
A host running nmap can attempt to scan any target <em>anywhere</em> in the Internet</p><h4 id=web-servers-and-tcp>Web Servers and TCP<a hidden class=anchor aria-hidden=true href=#web-servers-and-tcp>#</a></h4><p>In a web server, all segments have destination port 80 and both the initial connection-establishment segments and the segments carrying HTTP request messages will have destination port 80, the server will distinguish clients using the source IP addresses and port numbers.
Moreover in today&rsquo;s high-performing Web, servers often use only one process and <em>create a new thread with a new connection soket for each new client connection</em>.</p><p>If using persistent HTTP, client and server will exchange messages via the same server socket. If using non-persistent HTTP, a new TCP connection is created and closed for every request/response and hence a new socket is created and closed for every request/response.</p><h2 id=33-connectionless-transport-udp>3.3 Connectionless Transport: UDP<a hidden class=anchor aria-hidden=true href=#33-connectionless-transport-udp>#</a></h2><p>UDP does multiplexing/demultiplexing, light error checking, nothing more. If the developer chooses UDP, the application is almost directly talking with IP.
Note that with UDP there is no handshaking between sending and receiving transport-layer entities before sending a segment. For this reason UDP is said to be <strong>connectionless</strong>.
DNS is an example of an application layer protocol that typically uses UDP: there is no handshaking and when a client doesn&rsquo;t receive a reply either it tries sending the query to another name server or it informs the invoking application that it can&rsquo;t get a reply. Why should a developer choose UDP?</p><ul><li><em>Finer application-level controll over what data is sent and when</em>: as soon as the application passes data to UDP, UDP will package the data inside a segment and immediately pass it to the network layer. TCP&rsquo;s congestion control can delay the sending of the segment and will try sending the packet until this is received. In real time applications the sending rate is important, so we can trade off some data loss for some sending rate.</li><li><em>No connection establishement</em> UDP justs send data without any formal preliminaries without introducing any delay, probably the reason why DNS runs over UDP.</li><li><em>No connection state</em>: because a UDP application doesn&rsquo;t need to keep track of the users or to keep connections alive, it can typically support many more active clients than a TCP application</li><li><em>Small packet header overhead</em> TCP has 20 bytes of header overhead in every segment versus the 8 of UDP</li></ul><p>It is possible for an application developer to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself (eg adding acknowledgement and retransmission mechanisms) but it is a nontrivial task and may keep the developer busy for a long time.</p><h3 id=331-udp-segment-structure>3.3.1 UDP Segment Structure<a hidden class=anchor aria-hidden=true href=#331-udp-segment-structure>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-udp_segment.png alt="udp segment"></p><p>The UDP header has only four fields, each consisting of two bytes:</p><ul><li><code>source port number</code></li><li><code>destination port number</code></li><li><code>checksum</code> (used for error detection.)</li><li><code>length</code> (which specifies the number of bytes in the UDP segment, header + data)</li></ul><p>This <code>length</code> field is needed since the size of the data field may differ from one UDP segment to the next.</p><h3 id=332-udp-checksum>3.3.2 UDP Checksum<a hidden class=anchor aria-hidden=true href=#332-udp-checksum>#</a></h3><p>Provides for error detection, to determine whether the bits in the segment have been altered as it moves from source to destination.</p><p>At the send side, UDP performs the 1s complement of the sum of all the 16-bit (max 64) words in the segment, with any overflow encountered during the sum being wrapped around. This result is put in the checksum field of the UDP segment header.</p><p>UDP implements error detection according to the <strong>end-end principle</strong>: certain functionality (error detection in this case) must be implemented on an end-end basis: &ldquo;functions placed at the lower levels may be redundant or of little value when compared to the cost of providing them at the higher level&rdquo;.</p><h2 id=34-principles-of-reliable-data-transfer>3.4 Principles of Reliable Data Transfer<a hidden class=anchor aria-hidden=true href=#34-principles-of-reliable-data-transfer>#</a></h2><p>It is the responsibility of a <strong>realiable data transfer protocol</strong> to implement reliable data service: no transferred data bits are corrupted or lost and all are delivered in the order in which they were sent.
We will consider the following actions:</p><ul><li>The sending side of the data transfer protocol will be invoked from above by a call to <code>rdt_send()</code></li><li>On the receiving side <code>rdt_rcv()</code> will be called when a packet arrives while <code>deliver_data()</code> will be called when the <code>rdt</code> protocol wants to deliver data to the upper layer.</li></ul><p>We use the term packet rather than segment because the concepts explained here applies to computer networks in general.
We will only consider the case of <strong>unidirectional data transfer</strong> that is data transfer from the sending to the receiving side. The case of reliable <strong>bidirectional</strong> (full-duplex) <strong>data transfer</strong> is not more difficult but more tedious to explain. Nonetheless sending and receiving side will need to transmit packets in <em>both directions</em>.</p><h3 id=341-building-a-reliable-data-transfer-protocol>3.4.1 Building a Reliable Data Transfer Protocol<a hidden class=anchor aria-hidden=true href=#341-building-a-reliable-data-transfer-protocol>#</a></h3><p><strong>Finite-state machine</strong>s (FSM) are boring! And unlikely to be asked at the exam, therefore I decided not to cover them here.</p><h3 id=342-pipelined-reliable-data-transfer-protocols>3.4.2 Pipelined Reliable Data Transfer Protocols<a hidden class=anchor aria-hidden=true href=#342-pipelined-reliable-data-transfer-protocols>#</a></h3><p>In today&rsquo;s high-speed networks stop-and-wait protocols are simply not tolerable: we cannot send one packet and wait for the ACK and then send the second one, it is inefficient as we can see computing the <strong>utilization of the channel</strong>:</p><p>$$ U = \frac{L/R}{RTT+ L/R} $$</p><p>The solution is simple: rather than operate in a stop-and-wait manner, the sender is allowed to send multiple packets without waiting for acknowledgements. Since the many in-transit send-to-receiver packets can be visualized as filling a pipeline, this technique is known as <strong>pipelining</strong>.</p><p>Some consequences:</p><ul><li>The range of sequence numbers must be increased: <strong>each in-transit packet must have a unique sequence number</strong></li><li>Sender and receiver may have to buffer more than one packet.</li></ul><p>Two basic approaches toward pipelined error recovery can be identified: <strong>Go-Back-N</strong> and <strong>Selective Repeat</strong></p><h3 id=343-go-back-n-gbn>3.4.3 Go-Back-N (GBN)<a hidden class=anchor aria-hidden=true href=#343-go-back-n-gbn>#</a></h3><p>The sender is allowed to send N packets (<strong>sender window size = N</strong>), the receiver has a window of size <strong>1</strong>.
If a segment from sender to receiver is lost, the receiver discards all the segments with sequence number greater than the sequence number of the dropped packet, answering with ACK with this sequence number. (no packet re-ordering)
The sender will wait for ACK in order to move the window and send new packets. The wait is not infinite, after a certain time a timeout will occur and the sender will retransmit all the packets in the sending window.
In a Go-Back-N protocol, acknowledgements are <strong>cumulative</strong>: if sender receives ACK3 he will know that all the packets from 0 to 3 have been received, even if hasn&rsquo;t received ACK2.</p><h3 id=344-selective-repeat>3.4.4 Selective Repeat<a hidden class=anchor aria-hidden=true href=#344-selective-repeat>#</a></h3><p>When the window-size and bandwidth-delay product are both large, many packets can be in the pipeline and a single packet error can thus cause GBN to retransmit a large number of packets, many unnecessarily.
<strong>Selective Repeat</strong> avoid unnecessary retransmissions by having the sender retransmit only those that packets it suspects were received in error at the receiver:
<strong>individual acknowledgements</strong> (opposed to cumulative).
<strong>sender window size = N</strong> and <strong>receiver window site = N</strong>.
The sender has a timer for each packet in its window. When a timeout occurs, only the missing packet is resent.
The receiver buffers out of order packets.</p><h2 id=35-conncetion-oriented-transport-tcp>3.5 Conncetion-Oriented Transport: TCP<a hidden class=anchor aria-hidden=true href=#35-conncetion-oriented-transport-tcp>#</a></h2><h3 id=351-the-tcp-connection>3.5.1 The TCP Connection<a hidden class=anchor aria-hidden=true href=#351-the-tcp-connection>#</a></h3><p>TCP is said to be <strong>connection-oriented</strong> because before one application process can begin to send data to another, the two processes must first &ldquo;handshake&rdquo; with each other. During the connection establishment, both sides of the connection will initialize many TCP state variables.
TCP connection is not an end-to-end TDM or FDM circuit nor is it a virtual circuit as <strong>the connection state resides entirely in the two end systems</strong> and not in the intermediate network elements.
A TCP connection provides a <strong>full-duplex service</strong>: when a connection between process A and process B, application layer data can flow from A to B and, at the same time, from B to A.
TCP is also <strong>point-to-point</strong>: a connection is always between a <em>single sender</em> and a <em>single receiver</em>, no multicast possible.</p><p>Establishment of the connection: the client first sends a special TCP segment, the server responds with a second special TCP segment and the client answer again with a third special TCP segment. The first two cannot contain a payload while the third can. Three segments: <strong>three-way handshake</strong>.
Both the sender and the receiver have buffers that are set up during the handshake.
The maximum amount if data that can be grabbed and placed in a segment is limited by the <strong>maximum segment size (MSS)</strong>.
TCP therefore splits data into smaller chunks and pairs each chunk of client data with a TCP header thereby forming <strong>TCP segments</strong> which are passed down to the network layer. When TCP receives a segment at the other end, the segment&rsquo;s data is placed in the TCP connection&rsquo;s receive buffer. <strong>Each side of the connection has its own send buffer and its own receive buffer</strong></p><h3 id=352-tcp-segment-structure>3.5.2 TCP Segment Structure<a hidden class=anchor aria-hidden=true href=#352-tcp-segment-structure>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-tcp-segment.png alt="tcp segment"></p><ul><li>32 bit sequence number and acknowledgement number necessary for reliable data transmission</li><li>16 bit <strong>receive window</strong> used for flow control, indicates the number of bytes that a receiver is willing to accept</li><li>4 bit <strong>header length field</strong>. The TCP header can be of a variable length due to the TCP options field (usually empty therefore usual length is 20 bytes)</li><li><strong>options field</strong> used to negotiate MSS or as a window scaling factor for use in high speed networks.</li><li><strong>flag field</strong>: 6 bits:<ol><li>ACK used to indicate that the value carried in the acknowledgement field is valid, that is the segment contains an acknowledgement for a segment that has been successfully received.</li><li>, 3. and 4. <strong>RST, SYN, FIN</strong> for connection setup and teardown</li><li><strong>PSH</strong> indicates that the receiver should pass the data to upper layer immediately</li><li>URG indicates that there is data in the segment that the sending side upper layer has marked as urgent.</li></ol></li></ul><h4 id=sequence-numbers-and-acknowledgment-numbers>Sequence Numbers and Acknowledgment Numbers<a hidden class=anchor aria-hidden=true href=#sequence-numbers-and-acknowledgment-numbers>#</a></h4><p>TCP views data as <em>an unstructured, but ordered, stream of bytes</em> and TCP&rsquo;s use of sequence numbers reflects this view: sequence numbers are over the stream of bytes and not over the series of transmitted segments.
The <strong>sequence number for a segment</strong> is the byte-stream number of the first byte in the segment.
EX 500,000 bytes, MSS = 1,000 bytes => 500 segments are created. First is numbered 0, second 1000, third 2000&mldr;..</p><p><strong>The acknowledgement number</strong> <em>that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B</em>.
TCP is said to provide <strong>cumulative acknowledgements</strong>: if sender receives ACK 536 he will know that all the bytes from 0 to 535 have been well received.
What does a host do when it receives out-of-order segments? The receiver buffers the out-of-order bytes and waits for the missing bytes to fill in the gaps.
Usually both sides of a TCP connection randomly choose an initial sequence number <strong>randomly</strong> both for security and for minimizing the possibility that a segment that is still present in the network from an earlier, already terminated connection between two hosts is mistaken for a valid segment in a later connection between these same two hosts.</p><h3 id=353-round-trip-time-estimation-and-timeout>3.5.3 Round-Trip Time Estimation and Timeout<a hidden class=anchor aria-hidden=true href=#353-round-trip-time-estimation-and-timeout>#</a></h3><p>TCP uses a timeout/retransmit mechanism to recover from lost segments. The question rises: How long should the timeout intervals be?
Clearly the timeout should be larger than the connection&rsquo;s round-trip time? How much larger? How can the RTT be evaluated?</p><h4 id=estimating-the-round-trip-time>Estimating the Round-Trip Time<a hidden class=anchor aria-hidden=true href=#estimating-the-round-trip-time>#</a></h4><p>The sample RTT, <code>SampleRTT</code>, for a segment is the amount of time between when the segment is sent (passed to network layer) and when an acknowledgement for the segment is received.
Most TCP implementations take one <code>SampleRTT</code> at a time: at any point in time, the <code>SampleRTT</code> is being estimated for only one of the transmitted but currently unacknowledged segments, leading to a <em>new value of <code>SampleRTT</code> for approximatively every RTT</em>.
TCP <strong>never computes a <code>SampleRTT</code> for a segment that has been retransmitted</strong>, only for segments transmitted once.
In order to estimate a typical RTT, TCP keeps an average called <code>EstimatedRTT</code> of the <code>SampleRTT</code> values. Upon obtaining a new <code>SampleRTT</code> TCP updates this estimation according to the formula:</p><p><code>EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT</code></p><p>where usually a = 1/8 = 0.125</p><p>We note that this weighted average puts more weight on recent samples than on old samples. In statistics such an average is called an <strong>exponential weighted moving average (EWMA)</strong>.
It is also useful to having an estimate of the <em>variability of the RTT</em>. We can measure how much <code>SampleRTT</code> typically deviates from <code>EstimatedRTT</code>:</p><p><code>DevRTT = (1 - b) * DevRTT + b* | SampleRTT - EstimatedRTT |</code></p><p>We note that this is an EWMA of the difference of estimated and last measured RTT. The recommended value for b is b = 0.25</p><h4 id=setting-and-managing-the-retransmission-timeout-interval>Setting and Managing the Retransmission Timeout Interval<a hidden class=anchor aria-hidden=true href=#setting-and-managing-the-retransmission-timeout-interval>#</a></h4><p><code>TimeoutInterval = EstimatedRTT + 4 * DevRTT</code></p><p>An initial <code>TimeoutInterval</code> value of 1 second is recommended.
Also <strong>when a timeout occurs, the value of <code>TimeoutInterval</code> is doubled</strong> in order to avoid a premature timeout occurring for a subsequent segment that will soon be acknowledged. As soon as a segment is received and <code>EstimatedRTT</code> is updated, the <code>TimeoutInterval</code> is again computed using the formula above.</p><h3 id=354-reliable-data-transfer>3.5.4 Reliable Data Transfer<a hidden class=anchor aria-hidden=true href=#354-reliable-data-transfer>#</a></h3><p>TCP creates a <strong>reliable data transfer service</strong> on top of IP&rsquo;s unreliable best-effort service. It ensures that the data stream that a process reads out of its TCP receive buffer is <em>uncorrupted, without gaps, without duplication and in sequence</em>.
We supposed until now that an individual timer was associated with each transmitted segment. However timer management can require considerable overhead. Thus the recommended TCP timer management procedures (defined by RFC standards) use only a <em><strong>single</strong></em> retransmission timer (it is helpful to think of the timer as being <em>associated with the oldest unacknowledged segment</em>).</p><ol><li>Upon receiving data from the application layer, TCP encapsulates it in a segment and passes to the segment to IP. If the timer is not running for some other segment, TCP starts it when the segment is passed to IP, the timer expiration interval being <code>TimeoutInterval</code></li><li>If the timeout occurs, TCP responds by <strong>retransmitting the segment that caused the timeout</strong> and by restarting the timer</li><li>An valid acknowledgement segment is received: TCP compares the ACK <code>y</code> value with its <code>sendBase</code> (the sequence number of the oldest unacknowledged byte). If <code>y > sendBase</code> then ACK is acknowledging one or more previously unacknowledged segments (cumulative acknowledgement). The <code>sendBase</code> variable is updated and the timer is restarted if there are not-yet-acknowledged segments.</li></ol><h4 id=doubling-the-timeout-interval>Doubling the Timeout Interval<a hidden class=anchor aria-hidden=true href=#doubling-the-timeout-interval>#</a></h4><p>Each time TCP retransmits, it sets the next timeout interval to twice the prevous value. However when the timer is restarted after receiving data from the application layer or after receiving an ACK, the <code>TimeoutInterval</code> is recomputed as described previously</p><h4 id=fast-retransmit>Fast Retransmit<a hidden class=anchor aria-hidden=true href=#fast-retransmit>#</a></h4><p>The problem with timeout-triggered retransmission is that the timeout period can be relatively long.
The sender can however often detect packet loss before the timeout event occurs by noting <em>duplicate ACKs</em>. A <strong>duplicate ACK</strong> is an ACK that reacknowledges a segment for which the sender has already received an earlier acknowledgement.
When the TCP sender receives <strong>three duplicate ACK for the same data</strong> it takes this as an indication that the segment following the segment that has been ACKed three times has been lost. In the case that three duplicate ACKs are received, the TCP sender performs a <strong>fast restransmit</strong>: it retransmits the missing segment <em>before</em> that segment&rsquo;s timer expires.</p><h4 id=go-back-n-or-selective-repeat>Go-Back-N or Selective Repeat?<a hidden class=anchor aria-hidden=true href=#go-back-n-or-selective-repeat>#</a></h4><p>Acknowledgments are cumulative (GBN) but many TCP implementations will buffer correctly received but out-of-order segments.
Also consider fast retransmit where only the missing packet is resent (SR) instead of all the window (GBN).
We can see that TCP&rsquo;s error recovery mechanism is categorized as a <strong>hybdrid of GB and SR protocols</strong>.</p><h3 id=355-flow-control>3.5.5 Flow Control<a hidden class=anchor aria-hidden=true href=#355-flow-control>#</a></h3><p>The host on each side of a TCP connection set aside a receive buffer for the connection. When TCP receives bytes that are correct and in sequence, it places the data in the receive buffer. The associated application process will read data from this buffer, but necessarily at the instant the data arrives (busy, not interested&mldr;). Thus the <em>the sender can easily overflow the connection&rsquo;s receive bufffer by sending too much data too quickly</em>. To avoid this event, TCP provides a <strong>flow-control service</strong>.
Flow control is a <em>speed-matching service</em>: matching the rate at which the sender is sending against the rate at which the receiving application is reading.</p><p><strong>Flow control and congestion control are not the same!</strong>: the former preventing overflow at the receiver side and being actuated only by the two end points, the latter preventing congestion of the network.</p><p>TCP provides flow control by having the <em>sender</em> maintain a variable called the <strong>receive window</strong>, used to give the sender an idea of how much free buffer space is available at the receiver.</p><p>Host A sends a large file to Host B over TCP.</p><h5 id=b-side>B side<a hidden class=anchor aria-hidden=true href=#b-side>#</a></h5><ul><li>B allocates a receive buffer to its connection, its size being <code>RcvBuffer</code></li><li>B also keeps the variables: <code>LastByteRead</code> (number of last byte in the data stream read by the application process) and <code>LastByteRcvd</code> (the number of the last byte arrived from the network and placed in the receive buffer)</li></ul><p>We have: <code>LastByteRcvd - LastByteRead &lt;= RcvBuffer</code> (we don&rsquo;t want overflow!)</p><p>Receive window aka the <em>amount of spare room in the buffer</em> <code>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</code>
<code>rwnd</code> is dynamic</p><h5 id=a-side>A side<a hidden class=anchor aria-hidden=true href=#a-side>#</a></h5><p>A keeps track of two variables:</p><pre><code>1. `LastByteSent`
2. `LastByteAcked`
</code></pre><p>Through the connection&rsquo;s life A must make sure that <code>LastByteSent - LastByteSent &lt;= rwnd</code></p><p>If B&rsquo;s buffer becomes full, he sends <code>rwnd = 0</code>. If <em>B has nothing to send to A</em>, when the application process empties B&rsquo;s buffer, TCP does not send a new segment with the new value of <code>rwnd</code> to A (TCP sends to A only if it needs to send data or if it needs to send an ACK).
Therefore A is never informed that B&rsquo;s buffer has some free space and <strong>he is blocked and can trasmit no more data</strong>.
To solve this problem, TCP requires A to <strong>continue to send segments with one data byte when B&rsquo;s receive window is 0</strong>, these segments will be acknowledged by B. Eventually the buffer will begin to empty and the acknowledgements will contain à non-zero <code>rwnd</code> value.</p><p>We remember that <strong>UDP has no flow control service</strong></p><h3 id=356-tcp-connection-management>3.5.6 TCP Connection Management<a hidden class=anchor aria-hidden=true href=#356-tcp-connection-management>#</a></h3><h4 id=how-is-the-connection-established-three-way-handshake>How is the connection established? <strong>Three-way handshake</strong><a hidden class=anchor aria-hidden=true href=#how-is-the-connection-established-three-way-handshake>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-three-way.png alt="three way"></p><ol><li>The client-side TCP sends a special TCP segment to server-side TCP. This segment <strong>doesn&rsquo;t contain any application-layer data</strong> but the <strong>flag bit SYN is set to 1</strong>. The segment is referred to as a <em>SYN segment</em>. The client also <strong>randomly chooses an initial sequence number</strong> (<code>client_isn</code>) and <strong>puts this number in the sequence number field of the initial TCP SYN segment</strong>. (randomizing <code>client_isn</code> is interesting to avoid security attacks).</li><li>The TCP SYN segment arrives at the server-side, it is extracted from the datagram. The server allocates the TCP buffers and variables to the connection and <strong>sends a connection-granted segment to the client</strong>. This segment also contains no application-layer data. The <strong>SYN flag is set to 1</strong>, the <strong>ACK field in the header is set to <code>client_isn+1</code></strong>. <strong>The server chooses its own initial sequence number <code>server_isn</code></strong> and <strong>puts this value in the sequence number field of the TCP segment header</strong>. This segment is referred to as <em>SYNACK segment</em>.</li><li>Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client then <strong>sends the server yet another segment which acknowledges the SYNACK</strong> (<code>server_isn+1</code> is set the acknowledgement field of the TCP segment header)</li></ol><p>After this setup, all the segments will have the SYN bit set to 0 in their headers.</p><h4 id=tearing-down-a-tcp-connection>Tearing down a TCP connection<a hidden class=anchor aria-hidden=true href=#tearing-down-a-tcp-connection>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-tcp-end.png alt="tcp end"></p><p>The client decides to end the connection:</p><ol><li>The client sends a special TCP segment to the server, this special segment having the <strong>FIN bit flag set to 1</strong> in the header.</li><li>The server receives the segment and sends an acknowledgement to the client.</li><li>The server then sends its own shutdown segment which also <strong>has the FIN bit set to 1</strong></li><li>The client acknowledges the server&rsquo;s shutdown segment.</li><li>The &ldquo;resources&rdquo; (buffers and variables) in the host<strong>s</strong> are deallocated.</li></ol><h4 id=what-if-the-two-ends-are-not-ready-for-communication>What if the two ends are not ready for communication?<a hidden class=anchor aria-hidden=true href=#what-if-the-two-ends-are-not-ready-for-communication>#</a></h4><p>A host receives a TCP segment whose port number or source IP address do not match with any of the ongoing sockets in the host -> the host sends a special reset segment to the source (RST flag bit set to 1) and drops the packet (UDP does responds with a special ICMP datagram)</p><h2 id=36-principles-of-congestion-control>3.6 Principles of Congestion Control<a hidden class=anchor aria-hidden=true href=#36-principles-of-congestion-control>#</a></h2><h3 id=361-the-causes-and-the-costs-of-congestion>3.6.1 The Causes and the Costs of Congestion<a hidden class=anchor aria-hidden=true href=#361-the-causes-and-the-costs-of-congestion>#</a></h3><h4 id=scenario-1-two-senders-a-router-with-infinite-buffers>Scenario 1: Two Senders, A Router with Infinite Buffers<a hidden class=anchor aria-hidden=true href=#scenario-1-two-senders-a-router-with-infinite-buffers>#</a></h4><p>A -> D, B -> C, A and B connect to the Internet through the same router, B and C connect to the Internet through the same router
(pas envie)</p><h2 id=37-tcp-congestion-control>3.7 TCP Congestion Control<a hidden class=anchor aria-hidden=true href=#37-tcp-congestion-control>#</a></h2><p>TCP limits the rate at which it sends traffic into its connection as a function of perceived network congestion.
The TCP congestion-control mechanism operating at the sender keeps track of an additional variable: the <strong>congestion window</strong>, noted <code>cwnd</code> which imposes a constraint on the rate at which a TCP sender can send traffic into the network. Specifically: <code>LastByteSent - LastByteAcked &lt;= min{cwnd, rwnd}</code>.
Limiting the amount of unacknowledged data at the sender we can limit the sender&rsquo;s send rate.
At the beginning of each RTT the sender sends <code>cwnd</code> bytes of data and at the end of the RTT he acknowledges. Thus <strong>the sender&rsquo;s send rate is roughly <code>cwnd/RTT</code> bytes/sec. Adjusting the value of <code>cwnd</code> the sender can adjust the rate at which it sends data into the connection</strong>.
Let now consider a <em>loss event</em> (timeout OR three duplicate ACKs). When there is excessive congestion some router buffers along the path overflows, causing a loss event at the sender <em>which is taken by the sender to be an indication of congestion on the sender-to-receiver path</em>.
If there is no congestion then all the acknowledgements will be received at the sender, which will take these arrivals as an indication that segments have been received and that he can increase the congestion window size and hence its transmission rate. If acknowledgements arrive at a slow rate then the congestion window will be increased at a relatively slow rate and, viceversa, it will be increased more quickly if ACKs arrive at a high rate.
Because TCP uses acknowledgements to trigger (or clock) its increase in congestion window size, TCP is said to be <strong>self-clocking</strong>. TCP uses the principles:</p><ol><li><em>A lost segment implies congestion therefore the sender rate should be decreased.</em></li><li><em>An acknowledged segment means the network&rsquo;s working, therefore the sender&rsquo;s rate can be increased</em> (if ACK of unacknowledged segment)</li><li><em>Bandwidth probing</em>: the transmission rates increases with ACKs and decreases with loss events: TCP is continuously checking (probing) the congestion state of the network</li></ol><h3 id=tcp-congestion-control-algorithm>TCP Congestion-Control Algorithm<a hidden class=anchor aria-hidden=true href=#tcp-congestion-control-algorithm>#</a></h3><p>Three components :</p><h4 id=1---slow-start>1 - Slow Start<a hidden class=anchor aria-hidden=true href=#1---slow-start>#</a></h4><p>When a TCP connection begins, <code>cwnd</code> is usually initialized to a small value of 1 MSS and only one segment is sent. <strong>Each acknowledged packet</strong> will cause the <code>cwnd</code> to be increased by 1 MSS and the sender will send now two segments (because the window is increased by one for each ack).
Therefore the number of segments doubles at each RTT, therefore the sending rate also doubles every RTT. Thus TCP send rate <strong>starts slow but grows exponentially during the slow start phase</strong>.
When does the growth end?</p><ul><li>Timeout: <code>cwnd</code> is set to 1 MSS and the slow start is started anew. Also the variable slow start threshold is initialized:
<code>ssthresh = cwnd / 2 - (half of value of cwnd when congestion is detected)</code></li><li>When <code>cwnd >= ssthresh</code> slow starts is stopped -> congestion avoidance state</li><li>Three duplicate ACKs: fast retransmit and fast recovery state</li></ul><h4 id=2---congestion-avoidance>2 - Congestion Avoidance<a hidden class=anchor aria-hidden=true href=#2---congestion-avoidance>#</a></h4><p>TCP suppose congestion is present, how to adapt?
Instead of doubling <code>cwnd</code> every RTT, <code>cwnd</code> is increased <strong>by just a single MSS every RTT</strong>.
When should this linear increase stop?</p><ul><li>Timeout: <code>cwnd</code> is set to 1 MSS, and <code>ssthresh = cwnd (when loss happened) / 2</code></li><li>Three duplicate ACKs: <code>cwnd = (cwnd / 2) + 3 MSS</code> and <code>ssthresh = cwnd (when 3 ACKs received) / 2</code> -> fast recovery state</li></ul><h4 id=3---fast-recovery>3 - Fast Recovery<a hidden class=anchor aria-hidden=true href=#3---fast-recovery>#</a></h4><p><code>cwnd</code> is increased by 1 MSS for every duplicate ACK received for the missing state that caused TCP to enter this state. When the ACK arrives for the missing segment, TCP goes into Congestion Avoidance after reducing <code>cwnd</code>.
If a timeout occurs <code>cwnd</code> is set to 1 MSS and <code>ssthresh</code> is set to half the value of <code>cwnd</code> when the loss event occurred.
Fast recovery is recommended but not required in TCP, in fact only the newer version of TCP, <strong>TCP Reno</strong> incorporated fast recovery.</p><h4 id=macroscopic-description-of-tcp-throughput>Macroscopic Description of TCP Throughput<a hidden class=anchor aria-hidden=true href=#macroscopic-description-of-tcp-throughput>#</a></h4><p>What is the average throughput (average rate) of a long-lived TCP connection?
Ignoring the slow start phase (usually very short as the rate grows exponentially). When the window size is <em>w</em> the transmission rate is roughly <em>w</em>/RTT. <em>w</em> is increased by 1 MSS each RTT until a loss event.
Denote by <em>W</em> the value of <em>w</em> when a loss event occurs. Then we have</p><p>average throughput of a connection = (0.75 * W)/RTT</p><h4 id=tcp-over-high-bandwidth-paths>TCP Over High-Bandwidth Paths<a hidden class=anchor aria-hidden=true href=#tcp-over-high-bandwidth-paths>#</a></h4><p>Today&rsquo;s high speed links allow to have huge windows. What happens if one of the segments in the window gets lost? What fraction of the transmitted segments could be lost that would allow the TCP congestion control to achieve the desired rate?</p><p>average throughput of a connection = (1.22 * MSS)/(RTT * sqrt(L))</p><p>Where L is the loss rate</p><h1 id=chapter-4-the-network-layer>Chapter 4: The Network Layer<a hidden class=anchor aria-hidden=true href=#chapter-4-the-network-layer>#</a></h1><p>In the chapter, there is an important distinction between the <strong>routing</strong> and <strong>forwarding</strong> functions of the network layer. Forwarding involves the transfer of a packet from an incoming link to an outgoing link <em>within a single router</em> while routing involves <em>all of a network&rsquo;s routers</em> whose collective interactions via routing protocols determine the paths that packets take on their trips from source to destination.</p><h2 id=41-introduction>4.1 Introduction<a hidden class=anchor aria-hidden=true href=#41-introduction>#</a></h2><p>The primary role of routers is to forward datagrams from input links to output links. Routers do not run nor the application-layer or the transport-layer, they go only up until the network layer.</p><h3 id=411-forwarding-and-routing>4.1.1 Forwarding and Routing<a hidden class=anchor aria-hidden=true href=#411-forwarding-and-routing>#</a></h3><p>The role of the network layer is deceptively simple: <strong>to move packets from a sending hosts to a receiving host</strong>. To do so it performs two important functions:</p><ul><li><em><strong>Forwarding</strong></em>: When a packet arrives to a router&rsquo;s input link, the router must move the packet to the appropriate output link. It is an action <strong>local</strong> to the router</li><li><em><strong>Routing</strong></em>: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as <strong>routing algorithsm</strong>. It is a <strong>network-wide</strong> action</li></ul><p>Every router has a <strong>forwarding table</strong>. When a router receives a packet, it extracts a value from a specific field in the header and searches for that value in in the forwarding table.
The procedure used to set up and update the table depends on the protocol used. However a router receives and sends <em>routing protocol messages</em> to configure its forwarding table.</p><p>We also need to mark the distinction between routers and <em>packet switches</em>.</p><ul><li>Packet-switches: performs forwarding according to the value in a field in the header of the packet. Some packet switches called <strong>link-layer switches</strong> base their forwarding decisions on values in the fields of the <em>link-layer frame</em> (link-layer devices)</li><li>Routers: base forwarding decisions on the value in the network-layer field. (network-layer devices) but also must implement link layer (no 3 without 2)</li></ul><h4 id=connection-setup>Connection Setup<a hidden class=anchor aria-hidden=true href=#connection-setup>#</a></h4><p>in some computer networks there is a third really important networks-layer function: <strong>connection setup</strong>: a <strong>path-wide</strong> process that sets up connection state in routers.</p><h3 id=412-network-service-models>4.1.2 Network Service Models<a hidden class=anchor aria-hidden=true href=#412-network-service-models>#</a></h3><p>The <strong>network service model</strong> defines the characteristics of end-to-end transport of packets between sending and receiving end systems. Some possible service for a network layer:</p><ol><li>Sending side:<ul><li><em>Guaranteed delivery</em></li><li><em>Guaranteed delivery with bounded delay</em></li></ul></li><li>Flow and receiving side:<ul><li><em>In-order packet delivery</em></li><li><em>Guaranteed minimal bandwidth</em></li><li><em>Guaranteed maximum jitter</em> (amount of time between transmission of two successive packets at the sender side is equal to the amount of time between their receipt at the destination, or that this spacing changes by no more than some specified value)</li><li><em>Security services</em>: encryption for confidentiality, data integrity and source authentication</li></ul></li></ol><p><strong>The Internet&rsquo;s network layer doesn&rsquo;t provide any of these</strong>: it provides a <strong>best-effort service</strong> there are no timing or bandwidth guarantees, no loss or order guarantees and congestion control indications.</p><h2 id=42-virtual--circuit-and-datagrams-networks>4.2 Virtual Circuit and Datagrams Networks<a hidden class=anchor aria-hidden=true href=#42-virtual--circuit-and-datagrams-networks>#</a></h2><p>As in transport layer, the network layer can use connection or connection-less protocols. There however some differences with the transport layer:</p><ul><li>In the network layer these services are <strong>host-to-host</strong> services (not the case for the TL, just look at TCP)</li><li>The network layer provides either a host-to-host connectionless service or a host-to-host connection service <strong>but no both</strong>. Connection service -> <strong>Virtual-Circuit (VC) networks</strong>, Connectionless service -> <strong>datagram networks</strong></li></ul><h3 id=421-virtual-circuit-networks>4.2.1 Virtual-Circuit Networks<a hidden class=anchor aria-hidden=true href=#421-virtual-circuit-networks>#</a></h3><p>The Internet is a datagram network but many alternative network architectures (ATM) are virtual-circuit networks. The connections in VC are called *<em>virtual circuits (VCs)3</em>.
A VC consists of</p><ol><li>A source-to-destination <em>path</em></li><li>VC numbers, one for each link along the path</li><li>Entries in the forwarding table in each router along the path</li></ol><p>A packet belonging to a virtual circuit will carry a VC number in its header. Because a VC may have different VC numbers on each link, each router must replace the VC number of traversing packets with a new VC number, which is obtained from the forwarding table. How is this determined?
Whenever a VC is established across a router, an entry is added to the forwarding table, and one (corresponding to the terminating VC) is removed whenever a VC ends.
The routers must maintain <strong>connection state information</strong> for the ongoing connections (using the tablea). There are 3 phases in a VC:</p><ul><li><em>VC Setup</em>: sending side contacts networks layer specifying the IP address of the destination. The network sets up the VC. The path is determined as well as the VC number for each link along the path. The forwarding tables are updated and resources reserved.</li><li><em>Data transfer</em>: the packets flow</li><li><em>VC teardown</em>: The call termination propagates along the path, the forwarding tables are updated</li></ul><p>During network-layer setup <em>all the routers along the path between source and destination are involved in VC setup, and each router is fully aware of all VCs passing through it</em> (not in TCP: setup and connection only between source and destination).
The messages used by end ssystems to initiate or terminate a VC are called <strong>signaling messages</strong> and the protocols used to exchange them are called <strong>signaling protocols</strong>.</p><h3 id=422-datagram-networks>4.2.2 Datagram Networks<a hidden class=anchor aria-hidden=true href=#422-datagram-networks>#</a></h3><p>Each time an end system wants to send a packet, it sampts the packet with the address of the destination end system and pops the packet into the network. The routers along the path will use this address to forward it.
The router has a forward table that <em>maps destination addresses to link interfaces</em>. When a packet arrives, it reads the destination address, uses the table to determine what link to use, and forwards the packet to that output link interface.</p><p>If we consider IPv4, addresses are 32 bits long. To avoid having tables with 2^32 entries, routers use <strong>prefixes</strong>. When there are multiple mathces to one address, the router uses the <strong>longest prefix matching rule</strong>.</p><p>Although routers in datagram networks maintain no connection state information, they nevertheless maintain forwarding state information in their forwarding tables.</p><h3 id=423-origins-of-vc-and-datagram-networks>4.2.3 Origins of VC and Datagram Networks<a hidden class=anchor aria-hidden=true href=#423-origins-of-vc-and-datagram-networks>#</a></h3><p>VC has its roots in the telephony world, which uses circuits switching too.
The datagram model instead comes from the need to simplify as much as possible the network to bring computers together.</p><h2 id=43-whats-inside-a-router>4.3 What&rsquo;s Inside a Router?<a hidden class=anchor aria-hidden=true href=#43-whats-inside-a-router>#</a></h2><ul><li><em>Input ports</em>: performs the physical layer functions of incoming link at the router. It is also here that the forwarding table is consulted to determine the output port to which the arriving packet will be forwarded via the switching fabric. Control packets (protocol info) are forwarded to the routing processor.</li><li><em>Switching fabric</em>: connects input prots to output ports.</li><li><em>Output ports</em>: stores packets received from the switching fabric and performs the necessary link layer and physical layer functions.</li><li><em>Routing processor</em>: executes the routing protocols (algorithms), maintains routing tables and attached link state information and computes the forwarding table for the router.</li></ul><p>Input ports, switching fabric and output ports implement the forwarding function and are almost always implemented in hardware (<em>routing forwarding plane hardware</em>) while the routing processor implements the routing function and is usually implemented in software running on traditional CPU (<em>router control plane</em>)</p><h3 id=431-input-processing>4.3.1 Input Processing<a hidden class=anchor aria-hidden=true href=#431-input-processing>#</a></h3><p>The packet arrives and the link and phyisical layer unpacking functions are performed. The forwarding table is computed and updated by the routing processor with a shadow copy typically stored at each input port so that forwarding decision can be made locallly without invoking the centralized routing processor on a per packet basis and thus avoiding a centralized processing bottleneck. The table is transferred to ports through separated bus. The lookup is then just a search (implemented in hardware and using high performance algorithms), speed also depends on the memory technology (DRAM, SRAM&mldr;). Lookup is important but input processing also consists of</p><ul><li>physical and link layer processing</li><li>chekcing the packet&rsquo;s version number, checksum, time to live&mldr;.</li><li>updating counters for network management.</li></ul><p>Input ports than moves the packet to the switching fabric (eventually queuing them if this is busy)</p><h3 id=432-switching>4.3.2 Switching<a hidden class=anchor aria-hidden=true href=#432-switching>#</a></h3><p>Can be performed in different ways:</p><h4 id=switching-via-memory>Switching via memory<a hidden class=anchor aria-hidden=true href=#switching-via-memory>#</a></h4><p>Switching under the control of the CPU and input and output ports functioned as traditional I/O devices in a traditional operating system. The packet arrives, is copied into the processor memory, the processor determines the output port and copies the packet to the output port&rsquo;s buffer.
No parallel forwarding (only 1 memory read/write bus)</p><h4 id=switching-via-a-bus>Switching via a bus<a hidden class=anchor aria-hidden=true href=#switching-via-a-bus>#</a></h4><p>An input port transfers a packet directly to the output port over a shared bus without intervention by the routing processor. The input port pre-pends an internal header to the packet. All the output ports receive the packet but only the one that matches the label in the internal header will keep the packet. The output port will remove this internal header. The switching speed is limited to the bus speed as one packet at a time can cross the bus (multiple arriving packets will have to wait). Sufficient only for small area and enterprise networks</p><h4 id=switching-via-an-interconnected-network>Switching via an interconnected network<a hidden class=anchor aria-hidden=true href=#switching-via-an-interconnected-network>#</a></h4><p>To overcome the bandwidth limitation of a single shared bus a more sophisticated interconnection network can be used.
A <em>crossbar switch</em> is an interconnection network consisting of 2N buses that connect N input ports to N output ports. Each vertical bus intersects each horizontal bus at a crosspoint which can be opened or closed at any time by the switch fabric controller. If a packet has to go from input X to output Y, only the crosspoint between the horizontal bus from X and the vertical bus to Y will be closed.
Thus packets directed to different output ports can be forwarded simultaneously, but not multiple packets directed to the same output port.</p><h3 id=433-output-processing>4.3.3 Output Processing<a hidden class=anchor aria-hidden=true href=#433-output-processing>#</a></h3><p>takes packets stored in the output&rsquo;s port&rsquo;s memory and transmits them over the output link, thus selecting de dequeuing packets for transmission and performing the necessary link and physical layer transmission functions.</p><h3 id=434-where-does-queuing-occur>4.3.4 Where Does Queuing Occur?<a hidden class=anchor aria-hidden=true href=#434-where-does-queuing-occur>#</a></h3><p>Queues may form at both the input ports and the output ports. The location and the extent of queuing will depend on traffic load, speed of the switching fabric, and line speed. As the queues grow large, the router&rsquo;s memory can eventually be exhausted and <strong>packet loss</strong> will occur. IS THIS USEFUL ? NOT COVERED BY TEACHER</p><h2 id=44-the-internet-protocol-ip-forwarding-and-addressing-in-the-internet>4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet<a hidden class=anchor aria-hidden=true href=#44-the-internet-protocol-ip-forwarding-and-addressing-in-the-internet>#</a></h2><p>We know move to study of the network layer in the Internet. There are two versions of the IP (Internet Protocol) in use today: IPv4 and IPv6.
There 3 main components in the Internet: the IP Protocol (addressing, datagram format and packet handling conventions), the routing protocol (path selection), the Internet Control Message Protocol (ICMP) (error reporting and network information).</p><h3 id=441-datagram-format>4.4.1 Datagram Format<a hidden class=anchor aria-hidden=true href=#441-datagram-format>#</a></h3><p>A network layer packet is referred to as a <strong>datagram</strong>.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-ipv4datagram.png alt="ipv4 datagram"></p><p>Some fields:</p><ul><li><em>Version number</em>: 4 bits specifying the IP protocol version of the datagram (IPv4 or IPv6 )</li><li><em>Header length</em>: the length of the packet is variable therefore this field tells where the header ends and the data begins. Usually datagrams contain no option so that the typical IP datagram has <strong>20-byte header</strong></li><li><em>Type of service</em> (TOS): allows different types of datagrams to be distinguished from each other. (eg real time vs non real time)</li><li><em>Datagram length</em>: 16 bits specifying the total length, that is header + data measured in bytes. 16 bits -> max header length = 65535 bytes, but usually datagrams are rarely larger than 1500 bytes.</li><li><em>Identifier, flags, fragmentation offset</em>: used for IP fragmentation. (NB: IPv6 doesn&rsquo;t allow fragmentation at routers)</li><li><em>Time-to-live</em> (TTL): used to avoid that datagrams circulate forever. It is decreased by one each time the datagram is processed by a router. When TTL = 0, the datagram is dropped</li><li><em>Protocol</em>: only used when datagram reaches its final destination, it specifies what <em>transport protocol</em> to which the data of the datagram should be passed. EX: 6 -> TCP, 17 -> UDP</li><li><em>Header checksum</em>: helps the router to detect bit errors in a received IP datagram. Computation: each two bytes in the <strong>header</strong> are considered as numbers, summed up using the 1s complement arithmetic. The 1s complement of this sum is then put in the checksum field. A router computes the checksum for each datagram. If the computed one doesn&rsquo;t equal the one in the field then the router has detected an error. Usually the datagram is discarded. As it is recomputed at each router, it may change.</li><li><em>Source and destination IP addresses</em></li><li><em>Options</em>: rarely used, dropped by IPv6</li><li><em>Data (payload)</em>: usually contains the transport layer segment but can also contain ICMP messages</li></ul><h4 id=ip-datagram-fragmentation>IP Datagram Fragmentation<a hidden class=anchor aria-hidden=true href=#ip-datagram-fragmentation>#</a></h4><p>The maximum amount of data that a link layer can carry is called the <strong>Maximum Transmission Unit (MTU)</strong>. As each datagram is encapsulated in a link layer frame, the MTU imposes a hard limit on the length of the datagram. Each of the links along the route can use different link-layer protocols and therefore can have different MTU.
We therefore have to break the IP datagram into smaller datagrams, each of which will go in different link layer frames. Each of these smaller datagrams is referred to as a <strong>fragment</strong>.
A fragment must be reassembled before it can be passed to the transport layer. To reduce the workload on routers, the designers of IPv4 decided that reassembling should only be done at the destination end system.</p><p>In IPv4, to comply with fragmentation, the header contains the fields:</p><ul><li><em>Identifiers</em>: identifies the <strong>unfragmented datagram</strong> (same for all fragments)</li><li><em>flags</em>: in particular there is one flag set to 0 if the fragment is the last or to 1 if there are more to come</li><li><em>fragmentation offset</em>: an integer x, the data in the fragment should be inserted beginning at byte x * 8</li></ul><p>If one fragment contains error or is lost, all the others are dropped and TCP will have the sender retransmit all the data.
Fragmentation complicates the network and end systems and can be used in lethal DoS attacks such as the Jolt2 attack</p><h3 id=442-ipv4-addressing>4.4.2 IPv4 Addressing<a hidden class=anchor aria-hidden=true href=#442-ipv4-addressing>#</a></h3><p>The boundary between the host and the physical link is called an <strong>interface</strong>. A router has multiple links connected to it, therefore multiple interfaces and therefore a router has multiple IP addresses and <em>an IP address is technically associated with an interface rather than with a host or router</em>.
IPv4 addresses are 32 bits long (4 bytes) -> max 2^32 possible addresses. They are typically writen in <strong>dotted decimal notation</strong> where each byte of the address is written in deciaml from and separated by a period from the others.
EX 193.32.216.9 === 11000001 00100000 11011000 00001001
Each interface on every host (except host behind NATs) must have a unique IP address. How are these computed?
A portion is determined by the subnet to which the host is connected.
A subnet is the portion of the network interconnected end systems and one one router. (also called <em>IP network</em> or <em>network</em>). IP assigns an address to a subnet x.x.x.x/y where /y notation, sometimes known as a <strong>subnet mask</strong> indicates <em>that the leftmost y bits of the 32 bit quantity define the subnet address</em>. If y is 24, then any host attached to the a.a.a.0/24 subnet would be <em>required</em> to have an address of the form a.a.a.xxx.</p><p>FIGURE 4.17 WTF</p><p>The Internet&rsquo;s address assignment strategy is known as <strong>Classless Interdomain Routing (CIDR)</strong>. It generalizes the notion of subnet addressing. Consider a.b.c.d/x : the x most significant bits constitute the network portion of the IP address and are often referred to as the <strong>prefix</strong> (or <em>network prefix</em>). EX an organization is assigned a block of contiguous addresses, that is, a range of addresses with a common prefix.
When someone outside the organization want to send a datagram to someone inside, he will only need this x bits. The remaining 32-x bits can be thought of as distinguishing among the devices within the organization. These bits may have an additional subnetting structure.
There is yet another type of IP address, the <em>IP broadcast address 255.255.255.255</em>. When a datagram is sent to this address, the datagram is delivered to all hosts on the same subnet.</p><h4 id=obtaining-a-block-of-addresses>Obtaining a Block of Addresses<a hidden class=anchor aria-hidden=true href=#obtaining-a-block-of-addresses>#</a></h4><p>A network administrator contacts an ISP which would provide a partition of the addresses that had already been allocated to him.
EX ISP has 200.23.16.0/20, it splits in 8 equal sized blocks: 200.23.16.0/23, 200.23.18.0/23, 200.23.20.0/23, &mldr;, 200.23.30.0/23
Who assigns set of addresses to ISPs? The <em><strong>Internet Corporation for Assigned Names and Numbers (ICANN)</strong></em> which allocates IP addresses, manages DNS root servers, assigns domain names and solves domain name disputes.</p><h4 id=obtaining-a-host-address-the-dynamic-host-configuration-protocol>Obtaining a Host Address: The Dynamic Host Configuration Protocol<a hidden class=anchor aria-hidden=true href=#obtaining-a-host-address-the-dynamic-host-configuration-protocol>#</a></h4><p>Once an organization has obtained a block of addresses, it can assign individual IP addresses to the hosts and router interfaces which are part of it. This can be done either <strong>manually</strong> (by the network administrator) or automatically by the <strong>Dynamic Host Configuration Protocol (DHCP)</strong>.
It can be configured so that a host receives the same IP each time it connects to the network or a temporary IP addresses that will change upon each connection. DHCP also transmits to hosts additional information (subnet mask, address of first-hop = default gateway, address of local DNS server).
As it automates the connection of a host into the network, DHCP is often referred to as a <strong>plug-and-play protocol</strong>. It is also popular in *wireless LANs where hosts join and leave frequently and in <em>residential ISP access networks</em>.
DHCP is a <em>client-server protocol</em>, the client being a newly arriving host needing network configuration information and the server being a router or a <em>DHCP relay agent</em> that know the address of a DHCP server for that network.
For a new client there is a 4 step process i nthe DHCP protcol:</p><ol><li><em>DHCP server discovery</em> c (client) looks for a server sending <strong>DHCP discover message</strong> a UDP packet directed to port 67. This segment is encapsulated in datagram sent to 255.255.255.255 (broadcast address) from address 0.0.0.0</li><li><em>DHCP server offer(s)</em> s (server) replies with a <strong>DHCP offer message</strong> broadcast to all nodes on the subnet using (sent to 255.255.255.0). c may receiver many of these (more servers) containing the transaction ID, proposed IP address and an address lease time (amout of time for which the address will be valid)</li><li><em>DHCP request</em>: c chooses one offer and responds to s with a <strong>DHCP request message</strong> echoing back the configuration parameters</li><li><em>DHCP ACK</em> s responds with <strong>DHCP ACK message</strong> confirming</li></ol><p>DHCP also provides a mechanism for renewing the lease on an address.</p><h4 id=network-address-translation-nat>Network Address Translation (NAT)<a hidden class=anchor aria-hidden=true href=#network-address-translation-nat>#</a></h4><p>Every IP-capable device needs an IP address. The number of connected devices grows fast, how to deal with IPv4 address space exhaustion?
<strong>Network Address Translation (NAT)</strong>
The NAT-enabled router defines a <strong>realm</strong> (or private network) (a network whose addresses only have meaning to devices within that network) and it can use the whole 32 bit address space for devices connected to it, it will also have a public address used to communicate with the exterior. The picture is explicative.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-nat.png alt=nat></p><p>From the outside the router looks like a single device with a single IP address. It hides the details of the internal network from the outside world. Internal addresses can be assigned using DHCP.</p><p>Problems with NAT:</p><ul><li>Port number should be used for addressingi processes not hosts</li><li>Routers shouldn&rsquo;t have access to the transport layer (ports)</li><li>NAT violates end-to-end argument (any host should be able to contact any other host)</li><li>NAT interferes with P2P applications (peers hidden by NAT), therefore the need of <strong>connection reversal</strong> for <strong>NAT traversal</strong></li></ul><h4 id=upnp>UPnP<a hidden class=anchor aria-hidden=true href=#upnp>#</a></h4><p>NAT traversal is increasingly provided by Universal Plug and Play. It requires both the host and the NAT to be compatible. Host requests a NAT mapping_
<em>(private IP address, private port number) -> (public IP address, public port number)</em>
If the NAT accepts and creates the mapping, then outsiders can create connections to (public IP address, public port number).</p><h3 id=443-internet-control-message-protocol>4.4.3 Internet Control Message Protocol<a hidden class=anchor aria-hidden=true href=#443-internet-control-message-protocol>#</a></h3><p>ICMP is used to communicate network-layer information between hosts and routers, usually for error reporting (ex Destination network unreachable).
ICMP is considered part of IP but architecturally lies just above IP as ICMP messages are carried inside IP datagrams as payloads.
ICMP have a type and a code field and carry the header and the first 8 bytes of the datagram that caused the message to be generated in the first place.
Ping and traceroute are implemented using ICMP messages</p><h4 id=inspecting-datagrams-firewalls-and-intrusion-detection-systems>Inspecting datagrams: firewalls and intrusion detection systems<a hidden class=anchor aria-hidden=true href=#inspecting-datagrams-firewalls-and-intrusion-detection-systems>#</a></h4><p>Firewalls inspect the datagram and segment header fields denying suspicious datagrams entry into the internal network. Firewalls can block ICMP packages or packets based on port numbers, addresses.
Additional protection can be provided by IDS, placed at the boundary of the network, performs <em>deep packet inspection</em> examining not only headers but also payloads (including application layer data). IDS have databases of packet signatures that are know to be dangerous. As packets flow through the IDS, it tries to match them to signatures in its database, if a match is found, an alert is created. IPS (intrusion prevention system) in addition to detecting, also blocks packets raising alerts.</p><h3 id=444-ipv6>4.4.4 IPv6<a hidden class=anchor aria-hidden=true href=#444-ipv6>#</a></h3><p>Developed because of IPv4 address space exhaustion</p><h4 id=datagram-format>Datagram format<a hidden class=anchor aria-hidden=true href=#datagram-format>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-ipv6datagram.png alt="ipv6 datagram"></p><ul><li>the size of the source and destination addresses is increased <strong>from 32 to 128 bits</strong>: every grain of sand on the planet can be addressable.
Unicast and multicast addresses are joind by the <strong>anycast address</strong> which allow a datagram to be delivered to any one of a group of hosts.</li><li>A number of IPv4 fields have been dropped or made optional resulting in a <strong>40-byte fixed-length header</strong> which allows faster datagram processing.</li><li><em>Flow label</em> not clear definition. 20-bit</li><li><em>Version</em>: 4-bit for IPv6 or 4. If ipv6 -> 0110</li><li><em>Traffic class</em>: 8 bit similar to TOS</li><li><em>Payload length</em>: 16 bit unsigned integer indicating number of bytes following the 40-byte datagram header</li><li><em>Next header</em>: transport layer protocol</li><li><em>Hop limit</em>: decremented by one by each router forwarding the datagram, when 0, the datagram is discarded</li></ul><p>Fragmentation and reassembly cannot be done by intermediate routers, only by source and destination. If a router cannot trasmit a datagram because too big, it drops it and sends back an ICMP error message &ldquo;Packet too big&rdquo;. This reduces a lot the workload on the network.</p><p>As the transport layer and the link layer already perform check-summing, this functionality has been removed from the network layer for faster datagram processing.</p><p>An option field is no longer part of the header, instead it is one of the possible next headers pointed to from the header.
A <strong>new version of ICMP has been defined for IPv6</strong> which includes messages adapted to IPv6 (&ldquo;packet too big&rdquo;) and replaces IGMP (Internet Group Management Protocol), used to manage a host&rsquo;s joining and leaving of multicast groups.</p><h4 id=transitioning-from-ipv4-to-ipv6>Transitioning from IPv4 to IPv6<a hidden class=anchor aria-hidden=true href=#transitioning-from-ipv4-to-ipv6>#</a></h4><p>IPv6 is back compatible with IPv4 but not viceversa.</p><p>It&rsquo;s not humanable possible to decide a date on which all machines would change their protocol.
The most straightfoward way is a <strong>dual stack</strong> approach where IPv6 nodes also have a complete IPv4 implementation. To determine whether anotehr node is IPv6 or IPv4-only DNS can be used, just checking whether the node has a IPv6 address or an IPv4 one. However this will bring about the loss of data in specific IPv6 header fields.
Another approach would be <strong>tunneling</strong> : when two IPv6 nodes are connected by intervening IPv4 routers, we call the IPv4 nodes <strong>tunnel</strong>, the entire IPv6 datagram is put in the payload field of a IPv4 datagram which will be propagated by the tunnel unaware of the details and received by the destination IPv6 node which is able to extract the IPv6 datagram and to route it.
This migration shows the difficulty in changing network-layer protocols.</p><h1 id=45-routing-algorithms>4.5 Routing Algorithms<a hidden class=anchor aria-hidden=true href=#45-routing-algorithms>#</a></h1><p>A host is attached directly to one router, the <strong>default router</strong> for the host (also called <strong>first hop router</strong>). Whenever a host sends a packet, the packet is transferred to its default router, which we&rsquo;ll call <strong>source router</strong>, we&rsquo;ll call the default router for the destination host as the <strong>destination router</strong>. Routing a packet from source to destination boils down to routing the packet from source router to destination router.</p><p>The purpose of a routing algorithm is simple: given a set of routers connected by links, it finds a &ldquo;good&rdquo; path from source to destination router. <em>A good path is the least expensive one</em>.</p><p>Graphs (see Algorithms course) are used to formulate routing problems, the node representing routers and the edges the links connecting them. Each edge also has a <strong>value representing its cost</strong>. For any nodes x and y in the G(raph) we denote c(x,y) the cost of the edge between them. If (x,y) doesn&rsquo;t belong to G, we set c(x,y) = infinity. We only consider undirected graphs.
We just have to find the least costly paths between sources and destinations.
We can classify routing algorithms in two groups:</p><ul><li><strong>Global routing algorithms</strong>: compute the least-cost path between a source and a destination using complete, global knowledge about the network.
They are often referred to as <strong>link-state (LS) algorithms</strong> since the algorithm must be aware of the cost of each link in the network</li><li><strong>Decentralized routing algorthms</strong>: compute the least-cost path in an iterative, distributed manner: no node has complete information about the cost of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links.</li></ul><p>We could also make another classification separating <strong>static routing algorithms</strong> (routes change very slowly, eg after human intervention) and <strong>dynamic routing algorithms</strong>( routing change as the load or topology change). Finally another distinction could be made between <strong>load-sensitive</strong> or <strong>load-insensitive</strong> algorithms according to whether link costs vary reflecting the level of congestion.</p><h3 id=451-the-link-state-ls-routing-algorithm>4.5.1 The Link-State (LS) Routing Algorithm<a hidden class=anchor aria-hidden=true href=#451-the-link-state-ls-routing-algorithm>#</a></h3><p>All link costs are known. In practice this is accomplished by having each node broadcast link-state packets to all other nodes in the network, each packet containing the identities and costs of its attached links resulting in <strong>all nodes having an identical and complete view of the network</strong> (each node could run the algorithm).
A link-state algorithm can be <em><strong>Dijkstra&rsquo;s algorithm</strong></em> or <em><strong>Prim&rsquo;s algorithm</strong></em>.
Code and example page 394</p><h3 id=452-the-distance-vector-dv-routing-algorithm>4.5.2 The Distance-Vector (DV) Routing Algorithm<a hidden class=anchor aria-hidden=true href=#452-the-distance-vector-dv-routing-algorithm>#</a></h3><p>The <strong>distance-vector</strong> algorithm is <strong>iterative</strong>, <strong>asynchronous</strong> and <strong>distributed</strong>.</p><ul><li><em>Distributed</em> because each node receives some information from one or more of its directly attached neighbors, performs a calculation and then distributes the results back to its neighbors.</li><li><em>iterative</em>: the process continues on until no more information is exchanged between neighbors (self terminating)</li><li><em>asynchronous</em>: the nodes are not required to operate in lockstep with each other</li></ul><p>The least cost between x and y d(x,y) can be determined using the <em><strong>Bellman-Ford</strong></em> equation :</p><p>d(x,y) = min_v {c(x,y) + d(v,y)}</p><p>&mldr; to be continued</p><h3 id=453-hierarchical-routing>4.5.3 Hierarchical Routing<a hidden class=anchor aria-hidden=true href=#453-hierarchical-routing>#</a></h3><p>In practice it is not possible to have a network of interconnected routers running the same routing algorithm because of two reasons:</p><ul><li><em>Scale</em> if the number of routers is large, running LS or DV algorithms for the whole network becomes prohibitive for memory, processing, storing and timing costs.</li><li><em>Administrative autonomoy</em> an organization should be able to organize its network as it wishes, while still being able to connect its network to the outside world.</li></ul><p>Therefore routers are organized into <strong>autonomous systems (ASs)</strong>, each of which being under the same administrative control. Routers in the same AS run the same routing algorithm and have information about each other. The routing algorithm running <em>within</em> an AS is called an <strong>intra-autonomous system routing protocol</strong>. In an AS, one or more routers will have the task of being responsible for forwarding packets outside the AS, these routers are called <strong>gateway routers</strong>.
To obtain reachability information from neighboring ASs and propagating the reachability information to all routers interal to its AS, gateway routers use <strong>inter-AS routing protocols</strong>. Two communicating ASs must run the same inter-AS routing protocol.</p><p>When a router needs to forward a packet outside its AS and there are multiple gateway routers, the router has to make a choice. One often employed practice is to use <strong>hot-potato routing</strong>: the AS gets rid of the packet as quickly as possible (as inexpensively as possible), the router sends the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination.
An AS can decide what (internal) destinations to advertise to neighboring ASs: this a <em>policy</em> decision.</p><h2 id=46-routing-in-the-internet>4.6 Routing in the Internet<a hidden class=anchor aria-hidden=true href=#46-routing-in-the-internet>#</a></h2><h3 id=461-intra-as-routing-in-the-internet-rip>4.6.1 Intra-AS Routing in the Internet: RIP<a hidden class=anchor aria-hidden=true href=#461-intra-as-routing-in-the-internet-rip>#</a></h3><p>Intra-AS routing protocols are also known as <strong>interior gateway protocols</strong>. Historically two of these have been used extensively in the Internet: <strong>Routing Information Protocol (RIP)</strong> and <strong>Open Shortest Path First (OSPF)</strong>.</p><p>RIP was started for the Xerox Network Systems (XNS) architecture and was was widely deployed after being included in BSD. It is a <strong>distance-vector</strong> protocol working very similarly to what studied before. RIP uses <em>hop count</em> as a cost metric (each link has cost 1). Costs are from source router a destination subnet (not router-to-router as previously seen).
<strong>hop</strong> = number of subnets traversed along the shortest path from source to destination subnet, including the destination subnet.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-riphop.png alt=riphop></p><p>Routing updates [messages] are exchanged between neighbors approximately every 30 seconds using a <strong>RIP response message</strong>, which contains a list of up to 25 destination subnets within the AS as well as the sender&rsquo;s distance to each of those subnets. Response messages are also known as <strong>RIP advertisements</strong>.
Each router maintains a RIP table known as a <strong>routing table</strong> which includes both the router&rsquo;s distance vector and the router&rsquo;s forwarding table. There are three columns in it: the destination subnet, the identity of next router along shortest path to reach destination and the number of hops to get to the destination along the shortest path.</p><p>If a router doesn&rsquo;t hear from its neighbor for at least once every 180 seconds, that neighbor is considered to be no longer reachable (died or link down).
Routers can also request information about its neighbor&rsquo;s cost to a given destination using RIP&rsquo;s request messages, which are transmitted over UDP using port 520.
RIP is implemented in software but has access to the routing tables through the UNIX kernel.</p><h3 id=462-intra-as-routing-in-the-internet-ospf>4.6.2 Intra-AS Routing in the Internet: OSPF<a hidden class=anchor aria-hidden=true href=#462-intra-as-routing-in-the-internet-ospf>#</a></h3><p>OSPF and the related IS-IS are typically deployed in upper-tier ISPs whereas RIP is deployed in lower-tier ISPs and enterprise networks. Open indicates that the routing protocol speficication is publicly available.
It was conceived as the successor to RIP. It is however a <strong>link state protocol</strong> that uses <strong>flooding of link-state information</strong> and a <strong>Dijkstra least-cost path algorithm</strong>: routers construct a complete topological map (graph) of the AS, then run Dijkstra&rsquo;s algorithm to determine a shortest-path tree to <em>all subnets</em> with itself as the root node. Link costs are individually configured by the networks administrator who might choose to set all the link costs to 1, thus achieving minimum hop routuing or might choose to set the link weights to be <em>inversely proportional to link capacity</em> in order to discourage traffic from using low-bandwidth links.
A router broadcasts routing information to <em><strong>all other routers</strong></em> in the AS, not just the neighbors. The broadcast happens whenever there is a change in a link&rsquo;s state or every 30 minutes if the link&rsquo;s state doesn&rsquo;t change. OSPF advertisements are contained in <strong>OSPF messages</strong> that are carried by IP with an upper-lyerprotocol of 89 for OSPF, therefore OSPF must implement reliable message transfer and link-state broadcast; OSP also checks that links are operational using HELLO messages to attached neighbors. OSPF offers some services:</p><ul><li><em>security</em>: OSPF messages can be authenticated (not active by default).</li><li><em>multiple same-cost paths</em>: two paths having same cost can be used at the same time.</li><li><em>integrated support for unicast and multicast routing</em></li><li><em>support for hierarchy within a single routing domain</em>: ability to structure an autonomous system hierarchically. A OSPF AS can be configured hierarchically into areas, each running its own OSPF algorithm, with each router broadcasting its link state to all other routers in that area. <strong>Area border routers</strong> are responsible for routing packets outside the area and one area is configured to be the <strong>backbone area</strong>, which routes traffic between other areas in the AS, it contains area border routers but also normal routers.</li></ul><h3 id=463-inter-as-routing-bgp>4.6.3 Inter-AS Routing: BGP<a hidden class=anchor aria-hidden=true href=#463-inter-as-routing-bgp>#</a></h3><p>The <strong>Border Gateway Protocol (BGP)</strong> is the de facto standard inter-AS routing protocol in today&rsquo;s Internet. It provides each AS means to:</p><ul><li>obtain reachability information from neighboring ASs</li><li>propagate reachability information to all internal routers</li><li>determine good routes to subnets using reachability information and AS policy.</li><li>it allows <strong>each subnet to advertise its existence to the rest of the Internet</strong></li></ul><h4 id=basics>Basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h4><p>It is a very complex algorithm. Routers exchange information over semipermanent TCP connections using port 179. There is typically one such BGP TCP connection for each link directly connecting two routers in two different ASs but there are also semipermanent TCP connections between routers in the same AS. For each connection, the two routers at the end of it are called <strong>BGP peers</strong> and the connection is called a <strong>BGP session</strong>. A session spanning two ASs is an <strong>external BGP (eBGP) session</strong> and BGP sessions between routers within an AS is called an <strong>internal BGP (iBGP) session</strong>. Destinations are not hosts, but CIDRized <strong>prefixes</strong>, each representing a subnet or collection of subnets.</p><h4 id=path-attributes-and-bgp-routes>Path Attributes and BGP Routes<a hidden class=anchor aria-hidden=true href=#path-attributes-and-bgp-routes>#</a></h4><p>In BGP an AS is identified by its <strong>globally unique AS number (ASN)</strong> which is assigned by ICANN regional registries. When a router advertises a prefix across a BGP session, it includes with the prefix a number of <strong>BGP attributes</strong>, a prefix with its attributes is called a <strong>route</strong>. Two other important attributes are:</p><ul><li><em>AS-PATH</em>: contains the ASs through which the advertisement for the prefix has passed. When a prefix is passed into an AS, the AS adds its ASN to the AS-PATH.
This attribute is used to detect and prevent looping advertisements (if router sees that its AS is already in AS-PATH, it rejects the ad) and to choose among multiple paths to the same prefix.
-<em>NEXT-HOP</em>: <strong>the router interface that begins the AS-PATH</strong>.</li></ul><p>BGP also includes attributes allowing routers to assign preferences metrics to the routes and indicating how to prefix was inserted into BGP at the origins.
When a router receives a route advertisement, it uses its <strong>import policy</strong> to decide whether to accept or filter the route and whether to set certain attributes such as the router preference metrics.</p><h4 id=bgp-route-selection>BGP Route Selection<a hidden class=anchor aria-hidden=true href=#bgp-route-selection>#</a></h4><p>The input of the selection is the set of all routes that have been learned and accepted by the router. If two or more routes exist for the same prefix, elimination rules are applied until only one remains.</p><h1 id=chapter-8-security-in-computer-networks>Chapter 8: Security in Computer Networks<a hidden class=anchor aria-hidden=true href=#chapter-8-security-in-computer-networks>#</a></h1><h2 id=81-what-is-network-security>8.1 What is Network Security?<a hidden class=anchor aria-hidden=true href=#81-what-is-network-security>#</a></h2><p>Desirable properties of <strong>secure communication</strong>:</p><ul><li><em>Confindentiality</em>: only sender and receiver should be able to understand the contents of the transmitted message -> encryption</li><li><em>Message integrity</em>: make sure the content of the communication is not altered -> checksum</li><li><em>End-point authentication</em>: sender and receiver should be able to confirm the identity of the other party involved in the communication.</li><li><em>Operation security</em>: ability to counter attacks to internal networks -> firewalls, IPS, IDS</li></ul><p>Possible attacks:</p><ul><li><em>eavesdropping</em>: sniffing and recording messages flowing in a channel</li><li><em>modification, inserion, deletion</em> of messages or message content</li></ul><p>These two allow to mount many other types of attacks</p><h2 id=82-principle-of-cryptography>8.2 Principle of Cryptography<a hidden class=anchor aria-hidden=true href=#82-principle-of-cryptography>#</a></h2><p>See Information Science, BA2
ADDITION:</p><h4 id=block-ciphers>Block Ciphers<a hidden class=anchor aria-hidden=true href=#block-ciphers>#</a></h4><p>Today there are two broad classes of symmetric encryption techniques: <strong>stream ciphers</strong> and <strong>block ciphers</strong>(used for PGP, SSL, IPssec)
In a block cipher, the message to be encrypted is processed into blocks of <em>k</em> bis and each block is encrypted independently. To encode a bloc, the cipher uses a <em>on-to-one</em> mapping to map the <em>k</em>-bit block of cleartext to a <em>k</em>-bit block of ciphertext. To avoid bruteforce attacks, cipher blocks usually employ large blocks (<em>k</em>=64) but longer blocks implies longer tables to store the mappings.
Block ciphers typically use functions that simulate randomly permuted tables. EX
64 bit input split into 8 8-bit chunks, each of which is processed by a 8-bit to 8-bit table, each chunk having its table. The encrypted chunks are reassembled into a 64 bits message which is fed again to the input. After <em>n</em> such cycles, the function provides a 64-bit block of ciphertext. The key for this block would be the eight permutation tables, assuming that the scramble function is publicly known. Popular block ciphers: DES (Data Encryption Standard), 3DES, AES (Advanced Encryption Standard). These use functions instead of predetermined tables. Each of them uses a string of bits for a key (64-bit blocks with 56-bit key in DES, 128-bits blocks and 128/192/256 bits-long keys)</p><h5 id=cipher-block-chaining>Cipher-Block Chaining<a hidden class=anchor aria-hidden=true href=#cipher-block-chaining>#</a></h5><p>We need to avoid long messages avoiding that two or more identical ciphertexts (produced for identical cleartexts by a symmetric encryption).
(I DON&rsquo;T FINISH THIS PART, IT GOES TOO DEEP INTO ENCRYPTION TECHNIQUES WHICH IS NOT WHAT WE ARE INTERESTED IN)</p><h2 id=83-message-integrity-and-digital-signatures>8.3 Message Integrity and Digital Signatures<a hidden class=anchor aria-hidden=true href=#83-message-integrity-and-digital-signatures>#</a></h2><p>We want to provide <strong>message integrity</strong> (aka message authentication). Message integrity is verified when:</p><ul><li>The message received indeed originated from the sender</li><li>The message was not tampered with on its way to the receiver</li></ul><h3 id=831-cryptographic-hash-functions>8.3.1 Cryptographic Hash Functions<a hidden class=anchor aria-hidden=true href=#831-cryptographic-hash-functions>#</a></h3><p>A <strong>hash function</strong> takes an input <em>m</em> and computes a fixed length size string <em>H(m)</em> known as a hash. A <strong>cryptographic hash function</strong> is required to have an additional property:</p><p><strong>it is computationally infeasible to find any two different messages <em>x</em> and <em>y</em> such that H(x) = H(y)</strong>
Some used cryptographic hashing functions are md5, SHA&mldr;</p><h3 id=832-message-authentication-code>8.3.2 Message Authentication Code<a hidden class=anchor aria-hidden=true href=#832-message-authentication-code>#</a></h3><p>To perform message integrity we also need a shared secret <em>s</em>, called the <strong>authentication key</strong>. The procedure is then:</p><ol><li>Alice creates message <em>m</em>, concatenates <em>m+s</em> and computes the hash <em>H(m+s)</em> to create the <strong>message authentication code (MAC)</strong></li><li>Alice <strong>appends the MAC to the message</strong> <em>m</em> creating <em>(m+H(m+s))</em></li><li>Bob receives the message and knowing the hash function and the secret, computes the hash. He creates <em>H(m+s)</em> and compares it with what he received.</li></ol><p>MAC is nice because <em>it doesn&rsquo;t require any encryption algorithm</em>
The most popular standard of mac today is <strong>HMAC</strong> which can be used with either MD5 or SHA-1. The problem then is: how to distribute the secret?
Physically?</p><h3 id=833-digital-signatures>8.3.3 Digital Signatures<a hidden class=anchor aria-hidden=true href=#833-digital-signatures>#</a></h3><p>A <strong>digital signature</strong> is a cryptographic technique to indicate the owner or creator of a document or to signify one&rsquo;s agreement with a document&rsquo;s content.
Just as with handwritten signatures, digital signatures should be created in a way that they are <strong>verifiable</strong> (prove that the the author of a signature is indeed the author) and nonforgeable** (prove that only that individual could have signed the document).
We can use the public and private keys we already created for asymmetric confidentiality.
To sign a message <em>m</em> Bob can encrypt the message with the <strong>private key</strong> (only the matching public key will be able to decrypt).
However encryption and decryption and computationally expensive therefore:</p><ol><li>Bob computes the hash of the message</li><li>Bob uses his private key to encrypt the hash</li><li>Bob contants the encrypted hash and the message</li><li>Alice can decrypt, find the hash, compute a hash herself check for identity</li></ol><p>We saw that both digital signatures and MACs involve using a hash function but digital signatures, requiring encryption, need heavier operations and also need a <em>Public Key infrastructure</em> (PKI) with certification authorities.</p><h4 id=public-key-certification>Public Key Certification<a hidden class=anchor aria-hidden=true href=#public-key-certification>#</a></h4><p>An important application of digital signatures is <strong>public key certification</strong>, that is, <strong>certifying that a public key belongs to a specific entity</strong>. It is used in IPsec and SSL.
A <strong>Certification Authority</strong> binds a public key to a particular entity. It has the follow roles:</p><ol><li>A CA verifies that an entity (person, router, &mldr;) is who it says it is. The method depends on the authority</li><li>The CA creates a <strong>cerificate</strong> that binds the public key of the entity to the identity. The certificate contains the public key and globally unique identifying information about the owner of the public key. The <strong>certificate is digitally signed by the CA</strong></li></ol><h2 id=84-end-point-authentication>8.4 End-Point Authentication<a hidden class=anchor aria-hidden=true href=#84-end-point-authentication>#</a></h2><p><strong>End-point authentication</strong> is the process of one entity proving its identity to another entity over a computer network.
Authentication must be done solely on the basis of messages and data exchanged as part of an <strong>authentication protocol</strong>. Typically this would run before the two communicating parties run some other protocol.</p><p>We can analyze authentication developing a simple algorithm step by step:</p><h4 id=version-10>Version 1.0<a hidden class=anchor aria-hidden=true href=#version-10>#</a></h4><p>Alice simply sends a message to Bob saying &ldquo;I&rsquo;m Alice&rdquo;</p><h4 id=version-20>Version 2.0<a hidden class=anchor aria-hidden=true href=#version-20>#</a></h4><p>Alice and Bob always communicate using the same addresses. Bob can simply check that the message has the source IP of Alice. However is fairly easy to spoof an IP address: crafting a special datagram is feasible using a custom kernel e.g Linux.</p><h4 id=version-30>Version 3.0<a hidden class=anchor aria-hidden=true href=#version-30>#</a></h4><p>Alice and Bob could share a secret password, a secrete between the authenticator and the person being authenticated.
Alice: I&rsquo;m Alice, Password.
However password can be eavesdropped, sniffed (read and stored).</p><h4 id=version-31>Version 3.1<a hidden class=anchor aria-hidden=true href=#version-31>#</a></h4><p>We could encrypt the password using a shared symmetric cryptographic key.
However this protocol is subject to <strong>playback attacks</strong> an eavesdropper could sniff the encrypted secret and, without having to decrypt, could send it to impersonate Alice.</p><h4 id=version-40>Version 4.0<a hidden class=anchor aria-hidden=true href=#version-40>#</a></h4><p>To avoid playback attacks we could use the same principle behind TCP&rsquo;s three way handshake. A <strong>nonce</strong> is a number that a protocol will use only once in a lifetime.
The procedure is then:</p><ol><li>Alice sends: <code>I am Alice</code></li><li>bob chooses a nonce and sends it to Alice</li><li>Alice encrypts it using Alice and Bob&rsquo;s symmetric secret key and sends the encrypted nonce.</li><li>Bob decrypts the received nonce and checks for equality with the one he generated.</li></ol><h2 id=85-securing-e-mail>8.5 Securing e-mail<a hidden class=anchor aria-hidden=true href=#85-securing-e-mail>#</a></h2><p>Security functionalities are provided by many layers of the network stack. Why? There is a need for security at higher layers as well as blanket coverage at lower layers and it easier to provide security at higher layers.</p><h3 id=851-secure-e-mail>8.5.1 Secure E-Mail<a hidden class=anchor aria-hidden=true href=#851-secure-e-mail>#</a></h3><p>What features do we want? <em>Confindentiality, Sender authentication, Receiver authentication</em>.</p><ul><li>Confidentiality: to overcome the problem of sharing a symmetric secret, Alice and Bob use asymmetric cryptography. Bob makes his public key publicly available (key server or web page) and Alice encrypts her message with Bob&rsquo;s public key. Bob can decrypt using his private key. However asymmetric crypto is quite inefficient. A <em>session key</em> can be used: Alice selects a <strong>random symmetric key</strong>. She uses it to encrypt the message. She the encrypts this key using Bob&rsquo;s public key and concatenates the symmetricly encrypted message and the asymmetricly encrypted key.</li><li>Sender authentication and message integrity: we suppose that Alice and Bob don&rsquo;t care for confidentiality. They will use <strong>digital signatures</strong> and <strong>message digests</strong>.
Alice applies a hash function <em>H</em> to her message <em>m</em>, obtain a message digest, signs the digest with her private key to create a digital signature, concatenates the original message with the signature to create a package and sends the package to Bob&rsquo;s e-mail address.
Bob uses Alice&rsquo;s public key to the digest and compares the result fo this operation with his own hash <em>H</em> of the message.</li><li>Confidentiality, sender authentication and message integrity: the two procedures above can be combined, message and digest are concatenated and the treated as a new message which is encrypted using the first technique.</li></ul><p>These techniques suppose however that Alice and Bob are able to exchange their public keys. An intruder could in fact send a public key to Bob pretending to be Alice. <em>Certification is needed</em>.</p><h4 id=phil-zimmermann-and-pgp>Phil Zimmermann and PGP<a hidden class=anchor aria-hidden=true href=#phil-zimmermann-and-pgp>#</a></h4><p>PZ was the creator of PGP. For that he was legally attacked by the US Government, he distributed PGP while it should have stayed a secret weapon in the heads of the defense. The US dropped the case and PGP became the most widely used e-mail encryption software in the world despite the lack of funding, paid staff.</p><h3 id=852-pgp>8.5.2 PGP<a hidden class=anchor aria-hidden=true href=#852-pgp>#</a></h3><p>Pretty Good Privacy (PGP) is an e-mail encryption scheme that has become the De Facto standard.
It uses the same design shown above, giving the option of signing, encrypting or both.
When PGP is installed, it creates a public key pair for the user, the public key can be posted online while the private key is protected by a password which has to be entered every time the user accesses the private key.
A PGP message appears after the <strong>MIME</strong> header.
PGP also provides a mechanism for public key certification. PGP public keys are certified by <em><strong>Web of Trust</strong></em>: Alice can certify any key/username pair when she believes the pair really belong together and, in addition, PGP permits Alice to say that she trusts another user to vouch for the authenticity of more keys. Some PGP users sign each other&rsquo;s key by holding <em>key-signing parties</em>.</p><h2 id=86-securing-tcp-connections-ssl>8.6 Securing TCP Connections: SSL<a hidden class=anchor aria-hidden=true href=#86-securing-tcp-connections-ssl>#</a></h2><p>We now move to the transport layer. The enhanced version of TCP is called <strong>Secure Socket Layer (SSL)</strong>, a slightly modified version of SSL v3 called <strong>Transport Layer Security (TLS)</strong> has been standardized by the IETF.
Originally developed by Netscape, SSL has enjoyed broad deployment since its origins, providing secure communication between all recent browsers and online services. <strong>SSL provides TCP with confidentiality, data integrity, server authentication and client authentication</strong>.
SSL is often used over HTTP, however, as it secures TCP, it can be employed by any application that runs over TCP. SSL provides a simple <em>Application Programming Interface</em> with sockets, similar to TCP&rsquo;s API.
When an application wants to use SSL, it must include SSL classes/libraries. <strong>Technically SSL resides in the application layer</strong> but from the developer&rsquo;s perspective it is a transport layer protocol that provides TCP&rsquo;s services enhanced with security services.</p><h3 id=861-the-big-picture-primitive-almost-ssl>8.6.1 The Big Picture (primitive almost-SSL)<a hidden class=anchor aria-hidden=true href=#861-the-big-picture-primitive-almost-ssl>#</a></h3><p>Three phases:</p><ol><li><strong>Handshake</strong>: Bob initiates a TCP connection is established (TCP SYN, SYNACK, ACK). Bob sends <em>SSL Hello</em>, Alice responds with her certificate containing her public key (the certificate being certified by a CA, Bob is sure that the key belongs to Alice). Bob generates a <em><strong>master secrect (MS)</strong></em>, encrypts it with Alice&rsquo;s public key to create the <em><strong>Encrypted Master Secret (EMS)</strong></em> and sends it to Alice who will decrypt it with her private key to get the MS which can be used for confidentiality and integrity as seen before.</li><li><strong>Key Derivation</strong> instead of using the MS for integrity and confidentiality, it is safer to use different keys for different functions. Therefore <em>both</em> Alice and Bob <strong>use the MS to generate</strong>:<ul><li>Eb = session encryption key for data Bob -> Alice</li><li>Mb = session MAC key for data Bob -> Alice</li><li>Ea = session encryption key for data Alice -> Bob</li><li>Ma = session MAC key for data Alice -> Bob
The MS could simply be split in four chunks, but real SSL does it differently.</li></ul></li><li><strong>Data Transfer</strong> TCP is a byte-stream protocol, so where would we put the MAC for the integrity check? SSL breaks the data stream into <strong>records</strong>, appends a MAC to each record and then encrypts record+MAC. However, in a MITM attack, the order of packets could be reversed as TCP sequence numbers are not encrypted. SSL therefore uses sequence numbers. Bob keeps a sequence number counter which begins at zero and is incremented at each record transmission. He includesthe sequence number in the MAC calculation: MAC = hash(data+Mb+SeqNum). Alice tracks Bob&rsquo;s sequence numbers so that she can verify the MAC.</li></ol><h4 id=ssl-record>SSL Record<a hidden class=anchor aria-hidden=true href=#ssl-record>#</a></h4><p>The real SSL record:</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-sslrecord.png alt="ssl record"></p><ul><li>Type: handshake message, data message, connection teardown message</li><li>Length: used to extract the records out of the TCP byte stream</li></ul><h3 id=862-a-more-complete-picture>8.6.2 A More Complete Picture<a hidden class=anchor aria-hidden=true href=#862-a-more-complete-picture>#</a></h3><p>SSL allows Alice and Bob to agree on the cryptographic algorithms at the beginning of the SSL session, during handshake. Steps:</p><ol><li>The client sends a list of cryptographic algorithms it supports, along with a client nonce</li><li>The server chooses a symmetric algorithm (ex: AES), a public key algorithm (ex RSA) and a MAC algorithm. It sends back to the client its choices as well as a certificate and a server nonce.</li><li>The client verifies the certificate, extracts the server&rsquo;s public key, generates a <em>Pre-Master Secret</em> (PMS), encrypts it with the server&rsquo;s public key and sends the encrypted PMS to server.</li><li>Using the same key derivation function (specified by SSL standard), <em>client and server independently compute the Master Secret (MS) from the PMS and the nonces</em>. The MS is sliced up to create the two encryption and the two MAC keys. Furthemore when the symmetric cipher employs CBC (ex 3DES or AES) the two Initialization Vectors (IVs), one for each side of the connection, are also obtained from hte MS. Henceforth <strong>all messages sent between client and server are encrypted and authenticated (using MAC)</strong></li><li>The client sends a MAC of all the handshake messages</li><li>The server sends a MAC of the handshake messages.</li></ol><p>5 and 6 protect the handshake from tampering: if in the end MAC are not coherent with the previously sent messages, the connection is stopped. (prevents an attacker from impersonating the server and imposing weak algorithms).
Nonces are used to avoid <em>connection replay attacks</em> (resending packets sniffed during a previous connection again, using nonces allows to have different MACs and therefore messages at each connection, even if the content of the communication is the same).</p><h4 id=connection-closure>Connection Closure<a hidden class=anchor aria-hidden=true href=#connection-closure>#</a></h4><p>TCP FIN segments can be crafted by an attacker (<em>truncation attack</em>), therefore they cannot be used.
The type field of SSL records is used for these purpose, even if it sent in the clear, it is authenticated at the receivers using record&rsquo;s MAC.</p><h2 id=87-network-layer-security-ipsec-and-virtual-private-networks>8.7 Network-Layer Security: IPsec and Virtual Private Networks<a hidden class=anchor aria-hidden=true href=#87-network-layer-security-ipsec-and-virtual-private-networks>#</a></h2><p>The IP security protocol is called <strong>IPsec</strong>, it secures IP datagrams between any two network-layer entities (host, routers)</p><h3 id=871-ipsec-and-virtual-private-networks-vpns>8.7.1 IPsec and Virtual Private Networks (VPNs)<a hidden class=anchor aria-hidden=true href=#871-ipsec-and-virtual-private-networks-vpns>#</a></h3><p>An institution extending overt multiple geographical regions might want its own IP network so that the machines in it can communicate securely. Such a disjoint network is a <strong>private network</strong>. A physical private network can be expensive. VPN can be used to deploy and maintain a private network over the existing public Internet. The traffic is sent over the Internet but encrypted before entering the public net.
Not all traffic sent into the Internet by the gateway routers or laptops will be IPsec secured (only the portion accessing internal resources)</p><h3 id=872-the-ah-and-esp-protocols>8.7.2 The AH and ESP Protocols<a hidden class=anchor aria-hidden=true href=#872-the-ah-and-esp-protocols>#</a></h3><p>In the IPsec protocol suite, there are two principal protocols: the <strong>Authentication Header (AH)</strong> protocol and the <strong>Encapsulation Security Payload (ESP)</strong> protocol.
When a source IPsec entity (router or host) sends secure datagrams to a destination entity it does so with either ESP or AH. AH provides <em>source authentication</em> and <em>data integrity</em> while ESP provides <em>source authentication, data integrity and confidentiality</em>. Because the latter is often critical for VPNs, ESP is much more widely used AH. We will only study ESP.</p><h3 id=873-security-associations>8.7.3 Security Associations<a hidden class=anchor aria-hidden=true href=#873-security-associations>#</a></h3><p>Before sending IPsec datagrams from source entity to destination entity, source and destination create a network-layer logical connection called <strong>security association (SA)</strong>. SA is a simplex (unidirectional from source to destination) logical connection. If both entities want to send datagrams to each other, then two SAs need to be established, one in each direction.
The VPN server (headquarters gateway router) will maintain state information about the SA, which will include:</p><ul><li>32-bit identifier for the SA, called <em>Security Parameter Index (SPI)</em></li><li>The origin interface (client outside) of the SA and its destination (its out facing interface) [IP addresses]</li><li>Type of the encryption used</li><li>Encryption key</li><li>Type of the integrity check</li><li>Authentication key</li></ul><p>An IPsec entity often maintains state information for many SAs (all outside clients) using its <em>Security Association Database</em> (SAD) which is a data structure in the entity&rsquo;s OS kernel.</p><h3 id=874-the-ipsec-datagram>8.7.4 The IPsec Datagram<a hidden class=anchor aria-hidden=true href=#874-the-ipsec-datagram>#</a></h3><p>IPsec has two different packet forms, one for <strong>tunnel mode</strong> and one for <strong>transport mode</strong>, the first one, being more appropriate for VPNs, is more widely deployed than the transport mode, we will therefore only focus on it.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-ipsecdatagram.png alt="ipsec datagram"></p><p>The headquarters&rsquo;s gateway receives an IPv4 datagram from inside the network directed to a VPN client outside. Here is what happens:</p><ol><li>It appends to the back of the original datagram (which includes the original header fields) in the <em>ESP trailer</em> field</li><li>It encrypts the result using the algorithm and key specified in the SA</li><li>Appends to the front of the result a <em>ESP Header</em> creating the &ldquo;enchilada&rdquo;</li><li>Creates an authentication MAC over the whole enchilada using algorithm and key specified in the SA</li><li>Appends the MAC to the back of the enchilada forming the <em>payload</em></li><li>Creates a brand new IP header with all the classic IPv4 header fields which it appends before the payload.</li></ol><p>The protocol number field is set to 50, designating IPsec. The routers along the path will treat the datagram as a normal one, oblivious that it is an IPsec datagram.
To decide whether outgoing packets should be treated as above or simply let through, the gateway maintains a <em>Security Policy Database</em> (SPD) which indicates what types of datagrams (as a function of the source and destination IPs and of the protocol) are to be IPsec processed and, for those that are, which SA should be used.
<strong>IPsec provides confidentiality, source authentication, data integrity, replay-attack prevention.</strong></p><h3 id=875-ike-key-management-in-ipsec>8.7.5 IKE: Key Management in IPsec<a hidden class=anchor aria-hidden=true href=#875-ike-key-management-in-ipsec>#</a></h3><p>Who/What should populate the SAD? For small VPNs this can be done manually. For larger ones there is the <em><strong>Internet Key Exchange (IKE) protocol</strong></em>.
IKE is similar to the handshake in SSL. Here are the steps:</p><ul><li>During the first exchange of messages, the two sides use Diffie-Hellman to create a Bi-Directional IKE SA between the routers, which is entirely different form the IPsec SA discussed above. This IKESA provides an authenticated and encrypted channel between the two routers. Keys are established for encryption and authentication for IKESA. Also established is a master secret.</li><li>During the second exchange of messages, both sides reveal their identity to each other by signing their messages. However the identities are not revealed to an eventual sniffer, since the messages are sent over the IKE sa channel. The two sides also negotiate the IPsec encryption and authentication algorithms to be employed by the IPsec SA. Finally the two sides create an SA n each direction.</li></ul><p>We have two phases to reduce computational costs: we don&rsquo;t need asymmetric cryptography during second phase, allowing IKE to generate many SAs with relatively little computational cost.</p><h2 id=89-operational-security-firewalls-and-intrusion-detection-systems>8.9 Operational Security: Firewalls and Intrusion Detection Systems<a hidden class=anchor aria-hidden=true href=#89-operational-security-firewalls-and-intrusion-detection-systems>#</a></h2><h3 id=891-firewalls>8.9.1 Firewalls<a hidden class=anchor aria-hidden=true href=#891-firewalls>#</a></h3><p>A firewall is a combination of hardware and software that isolates an organization&rsquo;s internal network from the Internet at large, allowing some packets to pass and blocking others. It has three goals</p><ol><li><em>All traffic from outside to inside, and vice versa, passes through the firewall</em></li><li><em>Only authorized traffic, as defined by the local security by the local policy, will be allowed to pass</em>.</li><li><em>The firewall itself is immune to penetration</em></li></ol><p>Firewalls can be classified in three categories:</p><h4 id=1-traditional-packet-filters>1: Traditional Packet Filters<a hidden class=anchor aria-hidden=true href=#1-traditional-packet-filters>#</a></h4><p>Packet filters examine each datagram in isolation determining whether the datagram should be allowed to pass or should be dropped based on administrator-specific rules.
Filtering decisions can be based on IP source/destination, protocol type, TCP/UDP, TCP flags/ ICMP message type, rules for leaving/entering, rules for different router interfaces.
The parameters are based on the policy of the organization taking account of user productivity and bandwidth usage as well as security concerns.</p><h4 id=2-stateful-packet-filters>2: Stateful Packet Filters<a hidden class=anchor aria-hidden=true href=#2-stateful-packet-filters>#</a></h4><p>Decisions are made on each packet in isolation. Stateful filters track TCP connecions and use this knowledge to make filtering decisions.</p><h4 id=3-application-gateways>3: Application Gateways<a hidden class=anchor aria-hidden=true href=#3-application-gateways>#</a></h4><p>Application Gateways look beyond the IP/TCP/UDP headers and make policy decisions based on application data. An <strong>Application Gateway</strong> is an application-specific server through which all application data must pass. Multiple AG can run on the same host, but each gateway is a separate server with its own processes.</p><h3 id=892-intrusion-detection-systems>8.9.2 Intrusion Detection Systems<a hidden class=anchor aria-hidden=true href=#892-intrusion-detection-systems>#</a></h3><p>An <strong>intrusion detection system (IDS)</strong> is a device that alerts when it observes potentially malicious traffic. An <strong>intrusion prevention system (IPS)</strong> is a device that filters out suspicious traffic. Both types of device perform <strong>deep packet inspection</strong>: they look beyond the header fields and into the actual application data that the packets carry.</p><p>An IDS can detect a wide range of attacks, including network mapping, port scans, TCP stack scans, DoS, worms, viruses, OS vulnerability attacks and application vulnerability attacks.
An organization can deploy one more IDS sensors in its network. When many are used, they work together, usually coordinated by a central server. More than one is often a good solution as each one compare each passing packet with tens of thousands of signatures. They are usually classified as either <strong>signature-based systems</strong> or <strong>anomaly-based systems</strong>.
A signature based IDS maintains an extensive database of attack signature, each of which being a set of rules pertaining to an intrusion activity. A signature can be a list of packet characteristics or may relate to a series of packets. They are created by network security engineers researching attacks. The ids sniffs every packet passing by it, comparing it with signatures.
Signature based IDS, although widely deployed, have a number of limitations: they require a previous knowledge of the attack to generate an accurate signature, false alarms may be generated, they can be slow and fail to detect attacks if overwhelmed.
Anomaly-based packets study normal traffic and looks for statistically unusual events. They don&rsquo;t rely on previous knowledge of attacks.</p><h1 id=chapter-5-the-link-layer-links-access-networks-and-lans>Chapter 5: The Link Layer: Links, Access Networks and LANs<a hidden class=anchor aria-hidden=true href=#chapter-5-the-link-layer-links-access-networks-and-lans>#</a></h1><h2 id=51-introduction-to-the-link-layer>5.1 Introduction to the Link Layer<a hidden class=anchor aria-hidden=true href=#51-introduction-to-the-link-layer>#</a></h2><p>Some terminology:</p><ul><li><strong>node</strong> = any device running a link-layer protocol (hosts, routers, switches&mldr;)</li><li><strong>link</strong> = communication channels connecting adjacent nodes along the path.</li><li>Over a given link, a transmitting node encapsulates the datagram in a <strong>link-layer frame</strong> and transmits the frame into the link.</li></ul><h3 id=511-the-services-provided-by-the-link-layer>5.1.1 The Services Provided by The Link Layer<a hidden class=anchor aria-hidden=true href=#511-the-services-provided-by-the-link-layer>#</a></h3><p>Possible services offered by a link-layer protocol include:</p><ul><li><em>Framing</em>: all link layer protocols encapsulate each network layer datagram within a link-layer frame before transmission. A frame consists of a data field, containing the datagram, and a number of header fields, whose structure is determined by the protocol.</li><li><em>Link access</em>: A <strong>Medium Access Control</strong> (MAC) protocol specifies the rules by which a frame is transmitted onto the link.</li><li><em>Reliable delivery</em>: the protocol guarantees to move each datagram across the link without loss or errors. A reliable delivery protocol is often used for links highly prone to errors (WiFi) so that the error can be corrected locally, where it happens, rather than forcing an end-to-end retransmission. However it can represent a significant overhead for low bit-error links (cable) and therefore many wired link-layer protocols do not provide a reliable delivery service.</li><li><em>Error detection and correction</em>: signal attenuation and electromagnetic noise can introduce errors. Because there is no need to forward a datagram that has an error, may link-layer protocols provide a mechanism to detect such bit errors so that they can drop the frames. This can be accomplished transmitting error-detection bits in the frame. Link layer error detection is usually more sophisticated and <em>implemented in hardware</em>.</li></ul><h3 id=512-where-is-the-link-layer-implemented>5.1.2 Where Is the Link Layer Implemented?<a hidden class=anchor aria-hidden=true href=#512-where-is-the-link-layer-implemented>#</a></h3><p>In routers, the link layer is implemented in the line card. Is a host&rsquo;s link layer implemented in hardware or software?
For the most part, the link layer is implemented in a <strong>network adapter</strong>, sometimes known as <strong>network interface card (NIC)</strong>. At the heart of the NIC is the link-layer controller, usually a single, special purpose chip that implements many of the link-layer services. Thus, much of a link-layer controller&rsquo;s functionality is implemented in hardware.
Part of the link layer is implemented in software that runs on the host&rsquo;s CPU, this part implement higher-level functionalities.
Link-Layer is a combination of hardware and software, the place in the protocol stack where software meets hardware.</p><h2 id=52-error-detection-and--correction-techniques>5.2 Error-Detection and -Correction Techniques<a hidden class=anchor aria-hidden=true href=#52-error-detection-and--correction-techniques>#</a></h2><p>Error detection and correction allow the receiver to sometimes, <em>but not always</em>, detect that bit errors have occurred. Even with the use of error-detection bits, there still may be <strong>undetected bit errors</strong> (the receiver is unaware of the presence of corrupted bits).
We want to keep the probability of such an event small. Let&rsquo;s now consider three techniques for detecting errors in the transmitted data: parity checks, checksumming methods and cyclic redundancy checks</p><h3 id=521-parity-checks>5.2.1 Parity Checks<a hidden class=anchor aria-hidden=true href=#521-parity-checks>#</a></h3><p>Perhaps the simplest form of error detection is the use of a single <strong>parity bit</strong>. Suppose that the information to be sent, <em>D</em>, has <em>d</em> bits.
In an even parity scheme, the sender simply includes one additional bit and chooses its value such that the total number of 1s in the <em>d+1</em> bits (original + parity bit) is even. (odd parity scheme, parity bit to one if #1s % 2 != 0).
The receiver only needs to count the number of 1s in the <em>d+1</em> bits. If an odd number of 1 valued bits are found with an even parity scheme, the receiver knows that <em>some odd number</em> of bit error has occurred.
If an even number of bit errors occur, this would result in an undetected error.
Another approach is to use a <em><strong>two dimensional even parity</strong></em>: the <em>d</em> bits are divided into <em>i</em> rows and <em>j</em> columns. A parity value is computed for each row and for each column. The result <em>i + j + 1</em> parity bits comprise the error-detection bits.
A single bit error in the original <em>d</em> bits will cause the parity of both the column and the row containing the flipped bit to to be in error. The receiver can not only detect the error, but also use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted and <em>correct</em> the error.
This technique also allows to detect an error in the <em>parity bits</em>.
The ability of the receiver to both detect and correct errors is known as <strong>forward error correction (FEC)</strong></p><h3 id=522-checksumming-methods>5.2.2 Checksumming Methods<a hidden class=anchor aria-hidden=true href=#522-checksumming-methods>#</a></h3><p>The <em>d</em> bits of data are treated as a sequence of <em>k</em>-bit integers for example the Internet checksum already studied: bytes of data are treated as integers and summed, the 1s complement of this sum forms the Internet checksum carried in the header. The receiver checks the checksum by taking the 1s complement of the sum of the received data (including checksum) and checking whether the result is all 1 bits, if there are any 0, an error is indicated. In TCP and UDP the checksum is computed over all fields (header and data).
Checksumming methods require little packet overhead but they provide relatively weak protection against errors.
Why is checksumming used in transport layer and cyclic redundancy check used at the link layer?
Transport layer is implemented in software (OS) and therefore needs a simple and fast error detection scheme while error detection at link layer is implemented in hardware which can perform the more complex CRC operations.</p><h3 id=523-cyclic-redundancy-check-crc>5.2.3 Cyclic Redundancy Check (CRC)<a hidden class=anchor aria-hidden=true href=#523-cyclic-redundancy-check-crc>#</a></h3><p><strong>Cyclic Redundancy Check (CRC) codes</strong> are also known as <strong>polynomial codes</strong> since it is possible to view the string to be sent as a polynomial whose coefficients are the 0 and 1 values in the bit string with operation interpreted as polynomial arithmetic.
Sender and receiver must agree on a <em>r+1</em> bit pattern know as <strong>generator</strong> which we&rsquo;ll denote as <em>G</em>. We require the leftmost bit of G to be a 1. For a given piece of data <em>D</em> the sender will choose <em>r</em> additional bits, <em>R</em>, and append them to <em>D</em> such that the resulting <em>d + r</em> bit pattern, interpreted as a binary number, is exactly divisible by G using modulo-2 arithmetic.
Checking is therefore easy: the receiver divides the <em>d + r</em> received by bits by <em>G</em>, if the remainder is nonzero, an error has occurred, otherwise the data is accepted as being correct.
All CRC calculations are done in modulo 2 without carries in addition or borrows in subtraction (+ = - = xor).</p><h2 id=53-multiple-access-links-and-protocols>5.3 Multiple Access Links and Protocols<a hidden class=anchor aria-hidden=true href=#53-multiple-access-links-and-protocols>#</a></h2><p>There are two types of network links: point-to-point and broadcast links. A <strong>point-to-point link</strong> consists of a single sender at one end of the link and a single receiver at the other end of the link. A <strong>broadcast link</strong> can have multiple sending and receiving nodes all connected to the same, single, shared broadcast channel. The term <em>broadcast</em> is used because when any node transmits a frame, the channel broadcasts the frame and each other node receives a copy (ex: ethernet, wireless).</p><p>The <strong>multiple access problem</strong>: How to coordinate the access of multiple sending and receiving nodes to a shared broadcast channel?
Computer networks have <strong>multiple access protocols</strong> by which nodes regulate their transmission into the shared broadcast channel.
More than two nodes can transmit frames at the same time, which will result in all of the nodes receiving multiple frames at the same time: the frames <strong>collide</strong> at all of the receivers. Typically in case of collision, <em>none of the receiving nodes can make any sense of any of the frames</em>, they become inextricably tangled together and are therefore <strong>lost</strong>, the channel being wasted during collision.
Thus it is necessary to coordinate the transmission of the active nodes.
We can classify multiple access protocols in three categories: <strong>channel partitioning protocols, random access protocols, taking-turns protocols</strong>.</p><h3 id=531-channel-partitioning-protocols>5.3.1 Channel Partitioning Protocols<a hidden class=anchor aria-hidden=true href=#531-channel-partitioning-protocols>#</a></h3><p>TDM and FDM (from circuit switching) are in this category.
A third channel partitioning tool is <strong>code division multiple access (CDMA)</strong> which assigns a different <em>code</em> to each node. Each node then uses its unique code to encode the data bits it sends. If the codes are chosen carefully, then all nodes can transmit simultaneously and yet have their respective receivers correctly receive a sender&rsquo;s encoded data bits. Originally used in military systems, it&rsquo;s now widely used for civilian use, particularly in cellular telephony.</p><h3 id=532-random-access-protocols>5.3.2 Random Access Protocols<a hidden class=anchor aria-hidden=true href=#532-random-access-protocols>#</a></h3><p>A transmitting node always transmits at the full rate of the channel, <em>R</em> bps. When there is a collision, each node involved in the collision repeatedly retransmits its frame until the frame gets through without a collision.
But when a node experiences a collision, <em>it waits a random dely before retransmitting the frame</em>. The delay is chosen independently.
Here a few of the most commonly used random access protocols:</p><h4 id=slotted-aloha>Slotted ALOHA<a hidden class=anchor aria-hidden=true href=#slotted-aloha>#</a></h4><p>All frames consist of <em>L</em> bits, time is divided into slots of size <em>L/R</em> seconds, nodes start to transmit frames only at the beginning of slots. Moreover nodes are synchronized so that each node when the slot begins. If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.</p><p>If <em>p</em> is a probability then the operation of slotted ALOHA in each node is simple:</p><ul><li>each node waits the beginning of the next slot to transmit the entire frame in a slot</li><li>If no collision occurs, the frame is considered delivered</li><li>If collision, this is detect before the end of the slot. The node retransmits its frame <em>in each subsequent slot</em> with probability <em>p</em> (probability of retransmission) until the frame is transmitted without a collision.</li></ul><p>Slotted ALOHA allows transmission at full rate <em>R</em>, is highly decentralized, and is extremely simple.
The computed maximal efficiency (successfully used slots in transmission / total slots) of Slotted ALOHA) is 37% thus the effective transmission rate is 0.37<em>R</em> bps.</p><h4 id=aloha>Aloha<a hidden class=anchor aria-hidden=true href=#aloha>#</a></h4><p>all nodes synchronize their transmissions to start at the beginning of a slot. The node immediately transmits a frame in its entirety in the channel. In case of collision, the node will then immediately retransmit the frame with probability <em>p</em> otherwise the node waits for a frame transmission time, after which it transmits the frame with probability <em>p</em> or wait for another frame with probability <em>1-p</em>. The maximum efficiency is 1/(2e) but the protocol is fully decentralized.</p><h4 id=carrier-sense-multiple-access-csma>Carrier Sense Multiple Access (CSMA)<a hidden class=anchor aria-hidden=true href=#carrier-sense-multiple-access-csma>#</a></h4><p>CSMA and CSMA/CD (collision detection) embody two rules:</p><ul><li><strong>carrier sensing</strong>: if a node is transmitting, the others wait until they detect no transmission for a short amount of time and begin transmission.</li><li><strong>collision detection</strong>: a transmitting node listens to the channel while it&rsquo;s transmitting, if it detects that another node is transmitting, it stops transmitting and waits for a random amount of time before repeating the sense-and-transmit-when-idle-cycle.</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-csmaDIA.png alt=csmaDIA></p><p>It is evident that the <strong>propagation delay</strong> of the channel plays a crucial role: the longer, the larger the chance that a carrier sensing node is not yet able to sense a transmission that has already begun.</p><h4 id=carrier-sense-multiple-access-with-collision-detection-csmacd>Carrier Sense Multiple Access with Collision Detection (CSMA/CD)<a hidden class=anchor aria-hidden=true href=#carrier-sense-multiple-access-with-collision-detection-csmacd>#</a></h4><p>When a node detects a collision, it ceases transmission immediately in Collision Detection.
A link layer frame is prepared, if the node senses that the channel is idle (no energy is entering the adapter from the channel), it starts to transmit the frame, else it waits until it detects idle. While transmitting, the node monitors the channel for usage from other nodes, if the entire frame is transmitted without detecting usage, then the adapter is finished. If energy is detected from other adapters while transmitting, the node aborts transmission (stops), waits for a random amount of time and then returns to checking for idle.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-csmacdDIA.png alt=csmacdDIA></p><p>The wait for random amount of time is required in order to avoid the nodes to keep colliding.</p><h4 id=csmacd-efficiency>CSMA/CD Efficiency<a hidden class=anchor aria-hidden=true href=#csmacd-efficiency>#</a></h4><p>Is the long run fraction of time during which frames are being transmitted without collision. If the propagation delay approaches 0, the efficiency approaches 1.
Also if the propagation delay becomes very large, efficiency approaches 1.</p><h3 id=533-taking-turns-protocols>5.3.3 Taking-Turns Protocols<a hidden class=anchor aria-hidden=true href=#533-taking-turns-protocols>#</a></h3><p>There are a lot of them, we&rsquo;ll cover two of the more important, the first one being the <strong>polling protocol</strong>. It requires one of the nodes to be designated as a master node which <strong>polls</strong> each of the nodes in a round-robin fashion.
The master tells node 1 that it can transmit up to some maximum number of frames, when node 1 is finished (the master checks for energy in the channel) the master tells the same to node 2 and so on.
The polling protocol eliminates the collisions and empty slots that plague random access protocols, resulting in a much higher efficiency.
However it introduces a <em>polling delay</em> (the amount of time required to notify a node that it can transmit) [if only one is transmitting, it will have to wait for the master to poll all the others]. Moreover the master node represents a single point of failure.</p><p>The second protocol is the <strong>token-passing protocol</strong> in which there is no master method. A small, special purpose frame known as <strong>token</strong> is exchanged among the nodes in some fixed order. When a node receives a toke, it holds it only if it has some frames to transmit otherwise it immediately forwards it to the next node.If a node has frames to transmit when it receives the token, it sends up to a maximum number of frames and then passes the token. Token passing is decentralized and highly efficient but the failure of one node could crash the entire channel, or a node could neglect to release the token&mldr;.</p><h3 id=534-docsis-the-link-layer-protocol-for-cable-internet-access>5.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access<a hidden class=anchor aria-hidden=true href=#534-docsis-the-link-layer-protocol-for-cable-internet-access>#</a></h3><p>The Data-Over-Cable-Service-Interface-Specifications specifies the cable data network architecture and its protocols. DOCSIS uses FDM to divide the downstream and upstream network segments into multiple frequency channels. Each upstream and downstream channel is a broadcast channel. Several cable modems share the same upstream channel (frequency) to the CMTS and thus collision can potentially occur.
Each upstream channel is divided into intervals of time (TDM-like) each containing a sequence of mini-slots during which cable modems can transmit to the CMTS, which explicitly grants permission to individual modems to transmit during specific mini-slots. This is done sending a special control message known as a MAP message on a downstream channel to specify which cable modem can transmit during which mini-slot.
Modems send mini-slot-request frames to the CMTS during a special set of interval mini-slots dedicated for this purpose. The requests are transmitted in a random access manner and may collide with each other. The modem cannot detect activity nor collisions: it simply infers that its request experienced collision if it does not receive a response in the next downstream control message.
When a collision is inferred, a modem uses binary exponential backoff to defer the transmission to a future slot.</p><h2 id=54-switched-local-area-networks>5.4 Switched Local Area Networks<a hidden class=anchor aria-hidden=true href=#54-switched-local-area-networks>#</a></h2><p>Switched local networks connect hosts using link-layer switches which <strong>do not run networks-layer protocols</strong>.</p><h3 id=541-link-layer-addressing-and-arp>5.4.1 Link-Layer Addressing and ARP<a hidden class=anchor aria-hidden=true href=#541-link-layer-addressing-and-arp>#</a></h3><h4 id=mac-addresses>MAC Addresses<a hidden class=anchor aria-hidden=true href=#mac-addresses>#</a></h4><p>Network interfaces in hosts and routers have link-layer addresses, however <em>link-layer switches do not have link-layer addresses associated with their interfaces</em> so that they can carry datagrams without having routers or hosts having to explicitly address the frame to the intervening switch.
A link-layer address is called <strong>LAN address</strong>, <strong>physical address</strong> or <strong>MAC address</strong>, the last name being the most popular. This address is <strong>6 bytes long</strong>, typically expressed in hexadecimal notation. They are supposed to be permanent but can be changed via software.
<strong>No two adapters have the same address</strong>: the IEEE manages the MAC address space, usually assigning a 24 prefix to each manufacturer and letting him choose the content of the remaining 24 bits.
MAC address have a flat structure (no hierarchy such as in IP) and do not change.
When an adapter wants to send a frame to some destination adapter, it inserts the destination adapter&rsquo;s MAC address into the frame and then sends the frame into the LAN. An adapter might receive a frame that isn&rsquo;t addressed to it, when this happens, the adapter checks whether the frame&rsquo;s destination address matches its own, if not it discards the frame. When a sending adapter want to broadcast to the whole network, it inserts a special <strong>MAC broadcast address</strong> into the destination address field, for 6bytes addresses that is FF-FF-FF-FF-FF-FF</p><h4 id=address-resolution-protocol-arp>Address Resolution Protocol (ARP)<a hidden class=anchor aria-hidden=true href=#address-resolution-protocol-arp>#</a></h4><p>The <strong>Address Resolution Protocol (ARP)</strong> translates network-layer addresses into link-layer addresses, analogously to DNS, but ARP resolves IP addresses only for hosts and router interfaces on the same subnet.
Each host and router has an <strong>ARP table</strong> which contain mappings of IP addresses to MAC addresses and a time-to-live TTL value which indicates when each mapping will be deleted from the table. A typical TTL is 20 minutes from when an entry is placed in the ARP table.
The table does not necessarily contain an entry for every host and router on the subnet.
What if a frame has to be sent to an address which does not appear in the table?
The sender creates a special packet, an <strong>ARP packet</strong>, containing the sending and receiving IP and MAC addresses. Both ARP query and response have the same format: the sending forwards the ARP request to the broadcast address (destination address) the frame containing the query is received by all the other adapters in the subnet. Each adapter passes the frame to the ARP module which checks if its IP address matches the destination IP address in the query. The one with a match sends back the response with the desired mapping. The querying can update its table and send the IP datagram encapsulated in a link-layer frame.
ARP is plug and play: the table gets build automatically.
ARP stands in the boundary between the link and network layers.</p><h3 id=sending-a-datagram-off-the-subnet>Sending a Datagram off the Subnet<a hidden class=anchor aria-hidden=true href=#sending-a-datagram-off-the-subnet>#</a></h3><p>A datagram that has to be sent out of the subnet is first sent to the first-hop router on the path to the final destination (which is outside the subnet). How is its MAC acquired? Using ARP.
When the frame reaches the next-hop router of the destination subnet, it has to be moved inside, the router having to decide what interface to use. This is done using the forwarding table: the router extracts the datagram and checks the destination IP. The datagram is encapsulated again and sent into the subnet, this time the MAC address of the frame is indeed the destination MAC address of the ultimate destination, which the router acquire via ARP.</p><h3 id=542-ethernet>5.4.2 Ethernet<a hidden class=anchor aria-hidden=true href=#542-ethernet>#</a></h3><p>It has pretty much taken over the wired LAN market. Since its invention in the 70&rsquo;s, it has grown and become faster.
At the beginning the original Ethernet LAN used a coaxial bus to interconnect the nodes, creating a broadcast LAN. By the late 90s, most companies and universities had replaces their LANs with Ethernet installation using a hub-based star topology: hosts and routers are directly connected to a hub with twisted-pair copper wire. A <strong>hub</strong> is a physical layer device that acts on individual bits rather than frames. When a hub receives a bit, it simply recreates it boosting its energy strength and transmits the bit onto all the other interfaces (it&rsquo;s still a broadcast LAN). In the early 2000s, the star topology evolved: the hub was replaced with a <strong>switch</strong>, allowing a collision-less LAN.</p><h4 id=ethernet-frame-structure>Ethernet Frame Structure<a hidden class=anchor aria-hidden=true href=#ethernet-frame-structure>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-ethernetframe.png alt="ethernet frame"></p><ul><li><em>Data fields</em> (46 to 1,500 bytes): carries the IP datagram (or other network-layer datagram). The MTU (maximum transmission unit) is 1500 bytes, compensated with fragmentation. The minimum is 46, is less, the data is &ldquo;stuffed&rdquo; and the receiving network layer uses the length field to eliminate the stuffing</li><li><em>Destination address</em> (6 bytes) destination MAC address.</li><li><em>Source address</em> (6 bytes)</li><li><em>Type field</em> (2 bytes) allows to multiplex network layer protocols (if not only IP is used, also ARP has its own type number 0x0806)</li><li><em>Cyclic redundant check (CRC)</em> (4 bytes): used for bit error detection</li><li><em>Preamble</em> (8 bytes): the first seven have value 10101010, the last has value 10101011. The first seven serve as &ldquo;wake up&rdquo; the receiving side and to <em>synchronize their clocks to that of the sender&rsquo;s clock</em> the two 1s at the end of byte 8 alerts the receiver that the important stuff is about to come.</li></ul><p>All of the Ethernet technologies provide <strong>connectionless service</strong> (no handshaking, similar to UDP) and <strong>unrealiable service</strong> to the network layer (no ACK, drop in case of errors) which help to make Ethernet simple and cheap.
If there are gaps due to discarded Ethernet frames, the fact that the application sees the gaps or not depends on the transport layer protocol used: not with TCP (reliable data transfer), yes with UDP.</p><h4 id=ethernet-technologies>Ethernet Technologies<a hidden class=anchor aria-hidden=true href=#ethernet-technologies>#</a></h4><p>There are many variants and flavors of Ethernet which have been standardized over the years by the IEEE. They vary in speed: 10 Megabit, 100 Megabit, 1000 Megabit, 10 Gigabit&mldr;
They can also vary in the type of traffic they can transport&mldr;.</p><h3 id=543-link-layer-switches>5.4.3 Link-Layer Switches<a hidden class=anchor aria-hidden=true href=#543-link-layer-switches>#</a></h3><p>Switch receive and forward frames. They are <strong>transparent</strong>: adapters address each other, without knowing that the switch is sitting in the middle. As they&rsquo;re output rate might be smaller than the input rate, they also have buffers to queue frames.</p><h3 id=forwarding-and-filtering>Forwarding and Filtering<a hidden class=anchor aria-hidden=true href=#forwarding-and-filtering>#</a></h3><p><strong>Filtering</strong> is the switch function that determines whether a frame should be forwarded to some interface or should just be dropped.
<strong>Forwarding</strong> is the switch function that the determines the interfaces to which a frame should be directed and then moves the frame to those interfaces.
Switch filtering and forwarding are done with a <strong>switch table</strong> which contains entries for some (not necessarily all) of the hosts and routers on a LAN. Each entry contains:
<code>(MAC address, interface leading toward that MAC, time at which the entry was placed in the table)</code>
Switches forward frames based on the MAC addresses rather than on IP addresses.</p><p>When a switch receives a frame:</p><ul><li>There is no entry in the table associated with the destination address -> the packet is broadcast through all the interfaces (except the one through which the frame was received)</li><li>There is an entry in the table that point to the same interface through which the frame was received -> The frame is discarded (filtering)</li><li>There is an entry in the table that point to an interface different from the one through which the frame was received -> the frame is put in the output buffer preceding the interface discovered thanks to the table (forwarding)</li></ul><h4 id=self-learning>Self-Learning<a hidden class=anchor aria-hidden=true href=#self-learning>#</a></h4><p>The switch table is build <em><strong>automatically, dynamically and autonomously</strong></em> without any intervention from a network administrator: <strong>switches are self learning</strong>.</p><ol><li>The switch table is initially empty</li><li>For each incoming frame, the switch stores in its table<ol><li>the MAC address in the frame&rsquo;s <em>source address field</em></li><li>the interface from which the frame arrived</li><li>the current time</li></ol></li><li>The switch deletes an address in the table if no frame are received with that address as the source after some period (<strong>aging time</strong>) so that to eliminate unused entries from the table</li></ol><p>Thus switches are <strong>plug-and-play devices</strong>: they require no human intervention. Switches are also full-duplex, meaning any interface can send and receive at the same time.</p><h4 id=properties-of-link-layer-switching>Properties of Link-Layer Switching<a hidden class=anchor aria-hidden=true href=#properties-of-link-layer-switching>#</a></h4><p>Advantages over buses or hubs:</p><ul><li><em>Elimination of collisions</em>: the switch buffers frames and never transmit more than one frame on a segment at any one time. The maximum aggregated throughput is the sum of all the switch interface rates</li><li><em>Heterogeneous links</em>: The switch providing isolation, different links can operate at different speeds and run over different media. Therefore switches are ideal for mixing legacy equipment with new equipment.</li><li><em>Management</em>: A switch can disconnect a malfunctioning adapter and a cut cable isolates only one host. Switches can gather statistics useful for debugging and planning the evolution of the network.</li></ul><h4 id=switches-versus-routers>Switches Versus Routers<a hidden class=anchor aria-hidden=true href=#switches-versus-routers>#</a></h4><p>They are both packet switches but switches are layer-2 packet switches while routers are layer-3 packet switches.
Switches are plug-and-play, have relatively high filtering and forwarding rates.
However to <strong>prevent the cycling of broadcast frames, the active topology of a swtiched network is restricted to a spanning tree</strong>. A large network requires large ARP tables in hosts and routers and would generate substantial ARP traffic and processing. Switches are also susceptible to broadcast storms: if one goes crazy and send an endless stream of broadcast frames, the others will forward all of the frames resulting in a network collapse.
Routers network addressing is hierarchical, packets do not normally cycle and the topology is not limited to a spanning tree even when the network has redundant paths. Therefore packets can use the best path between source and destination. But routers are not plug-and-play (a host need the IP to connect) and often have a larger per-packet processing time than switches. Finally two pronunciation cause a lot of disputes.</p><p><img loading=lazy src=https://raw.githubusercontent.com/SamirPaulb/assets/main/blog-interconnectiondevices.png alt=interconnectiondevices></p><h3 id=pdf-note>PDF Note👇<a hidden class=anchor aria-hidden=true href=#pdf-note>#</a></h3><object data=https://samirpaulb.github.io/assets/computer_networking_notes_for_tech_placements.pdf loading=lazy type=application/pdf width=100% height=700px></object></div><footer class=post-footer><ul class=post-tags><li><a href=https://samirpaul1.github.io/blog/tags/blog/>blog</a></li><li><a href=https://samirpaul1.github.io/blog/tags/coding/>coding</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computer-science/>computer-science</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computer-networks/>computer-networks</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computer-networks-notes/>computer-networks-notes</a></li><li><a href=https://samirpaul1.github.io/blog/tags/notes/>notes</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computernetwork/>computernetwork</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computernetworking/>computernetworking</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computer/>computer</a></li><li><a href=https://samirpaul1.github.io/blog/tags/ipv/>ipv</a></li><li><a href=https://samirpaul1.github.io/blog/tags/icnd/>icnd</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computertechnology/>computertechnology</a></li><li><a href=https://samirpaul1.github.io/blog/tags/ccna/>ccna</a></li><li><a href=https://samirpaul1.github.io/blog/tags/routingandswitching/>routingandswitching</a></li><li><a href=https://samirpaul1.github.io/blog/tags/networking/>networking</a></li><li><a href=https://samirpaul1.github.io/blog/tags/osi-model/>osi-model</a></li><li><a href=https://samirpaul1.github.io/blog/tags/computernetworkingtechnology/>computernetworkingtechnology</a></li></ul><nav class=paginav><a class=prev href=https://samirpaul1.github.io/blog/posts/complete-computer-science-study-plan-to-become-a-software-engineer/><span class=title>« Prev</span><br><span>Complete Computer Science Study Plan to Become a Software Engineer</span></a>
<a class=next href=https://samirpaul1.github.io/blog/posts/curated-list-of-project-based-tutorials/><span class=title>Next »</span><br><span>Curated List of Project Based Tutorials</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on twitter" href="https://twitter.com/intent/tweet/?text=Computer%20Networks%20Notes&url=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f&hashtags=blog%2ccoding%2ccomputer-science%2ccomputer-networks%2ccomputer-networks-notes%2cnotes%2ccomputernetwork%2ccomputernetworking%2ccomputer%2cipv%2cicnd%2ccomputertechnology%2cccna%2croutingandswitching%2cnetworking%2cosi-model%2ccomputernetworkingtechnology"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f&title=Computer%20Networks%20Notes&summary=Computer%20Networks%20Notes&source=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f&title=Computer%20Networks%20Notes"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on whatsapp" href="https://api.whatsapp.com/send?text=Computer%20Networks%20Notes%20-%20https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Computer Networks Notes on telegram" href="https://telegram.me/share/url?text=Computer%20Networks%20Notes&url=https%3a%2f%2fsamirpaul1.github.io%2fblog%2fposts%2fcomputer-networks-notes%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>